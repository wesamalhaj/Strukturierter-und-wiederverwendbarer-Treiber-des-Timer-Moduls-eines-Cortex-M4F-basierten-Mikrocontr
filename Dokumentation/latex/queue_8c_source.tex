\doxysection{queue.\+c}
\label{queue_8c_source}\index{rtos/FreeRTOS/source/queue.c@{rtos/FreeRTOS/source/queue.c}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{/*}}
\DoxyCodeLine{00002 \textcolor{comment}{ * FreeRTOS Kernel V10.2.1}}
\DoxyCodeLine{00003 \textcolor{comment}{ * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.}}
\DoxyCodeLine{00004 \textcolor{comment}{ *}}
\DoxyCodeLine{00005 \textcolor{comment}{ * Permission is hereby granted, free of charge, to any person obtaining a copy of}}
\DoxyCodeLine{00006 \textcolor{comment}{ * this software and associated documentation files (the "{}Software"{}), to deal in}}
\DoxyCodeLine{00007 \textcolor{comment}{ * the Software without restriction, including without limitation the rights to}}
\DoxyCodeLine{00008 \textcolor{comment}{ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of}}
\DoxyCodeLine{00009 \textcolor{comment}{ * the Software, and to permit persons to whom the Software is furnished to do so,}}
\DoxyCodeLine{00010 \textcolor{comment}{ * subject to the following conditions:}}
\DoxyCodeLine{00011 \textcolor{comment}{ *}}
\DoxyCodeLine{00012 \textcolor{comment}{ * The above copyright notice and this permission notice shall be included in all}}
\DoxyCodeLine{00013 \textcolor{comment}{ * copies or substantial portions of the Software.}}
\DoxyCodeLine{00014 \textcolor{comment}{ *}}
\DoxyCodeLine{00015 \textcolor{comment}{ * THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{00016 \textcolor{comment}{ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS}}
\DoxyCodeLine{00017 \textcolor{comment}{ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR}}
\DoxyCodeLine{00018 \textcolor{comment}{ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER}}
\DoxyCodeLine{00019 \textcolor{comment}{ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN}}
\DoxyCodeLine{00020 \textcolor{comment}{ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{00021 \textcolor{comment}{ *}}
\DoxyCodeLine{00022 \textcolor{comment}{ * http://www.FreeRTOS.org}}
\DoxyCodeLine{00023 \textcolor{comment}{ * http://aws.amazon.com/freertos}}
\DoxyCodeLine{00024 \textcolor{comment}{ *}}
\DoxyCodeLine{00025 \textcolor{comment}{ * 1 tab == 4 spaces!}}
\DoxyCodeLine{00026 \textcolor{comment}{ */}}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 \textcolor{preprocessor}{\#include <stdlib.h>}}
\DoxyCodeLine{00029 \textcolor{preprocessor}{\#include <string.h>}}
\DoxyCodeLine{00030 }
\DoxyCodeLine{00031 \textcolor{comment}{/* Defining MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE prevents task.h from redefining}}
\DoxyCodeLine{00032 \textcolor{comment}{all the API functions to use the MPU wrappers.  That should only be done when}}
\DoxyCodeLine{00033 \textcolor{comment}{task.h is included from an application file. */}}
\DoxyCodeLine{00034 \textcolor{preprocessor}{\#define MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE}}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036 \textcolor{preprocessor}{\#include "{}FreeRTOS.h"{}}}
\DoxyCodeLine{00037 \textcolor{preprocessor}{\#include "{}task.h"{}}}
\DoxyCodeLine{00038 \textcolor{preprocessor}{\#include "{}queue.h"{}}}
\DoxyCodeLine{00039 }
\DoxyCodeLine{00040 \textcolor{preprocessor}{\#if ( configUSE\_CO\_ROUTINES == 1 )}}
\DoxyCodeLine{00041 \textcolor{preprocessor}{    \#include "{}croutine.h"{}}}
\DoxyCodeLine{00042 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00043 }
\DoxyCodeLine{00044 \textcolor{comment}{/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified}}
\DoxyCodeLine{00045 \textcolor{comment}{because the MPU ports require MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE to be defined}}
\DoxyCodeLine{00046 \textcolor{comment}{for the header files above, but not in this file, in order to generate the}}
\DoxyCodeLine{00047 \textcolor{comment}{correct privileged Vs unprivileged linkage and placement. */}}
\DoxyCodeLine{00048 \textcolor{preprocessor}{\#undef MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE }\textcolor{comment}{/*lint !e961 !e750 !e9021. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00049 }
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051 \textcolor{comment}{/* Constants used with the cRxLock and cTxLock structure members. */}}
\DoxyCodeLine{00052 \textcolor{preprocessor}{\#define queueUNLOCKED                   ( ( int8\_t ) -\/1 )}}
\DoxyCodeLine{00053 \textcolor{preprocessor}{\#define queueLOCKED\_UNMODIFIED          ( ( int8\_t ) 0 )}}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055 \textcolor{comment}{/* When the Queue\_t structure is used to represent a base queue its pcHead and}}
\DoxyCodeLine{00056 \textcolor{comment}{pcTail members are used as pointers into the queue storage area.  When the}}
\DoxyCodeLine{00057 \textcolor{comment}{Queue\_t structure is used to represent a mutex pcHead and pcTail pointers are}}
\DoxyCodeLine{00058 \textcolor{comment}{not necessary, and the pcHead pointer is set to NULL to indicate that the}}
\DoxyCodeLine{00059 \textcolor{comment}{structure instead holds a pointer to the mutex holder (if any).  Map alternative}}
\DoxyCodeLine{00060 \textcolor{comment}{names to the pcHead and structure member to ensure the readability of the code}}
\DoxyCodeLine{00061 \textcolor{comment}{is maintained.  The QueuePointers\_t and SemaphoreData\_t types are used to form}}
\DoxyCodeLine{00062 \textcolor{comment}{a union as their usage is mutually exclusive dependent on what the queue is}}
\DoxyCodeLine{00063 \textcolor{comment}{being used for. */}}
\DoxyCodeLine{00064 \textcolor{preprocessor}{\#define uxQueueType                     pcHead}}
\DoxyCodeLine{00065 \textcolor{preprocessor}{\#define queueQUEUE\_IS\_MUTEX             NULL}}
\DoxyCodeLine{00066 }
\DoxyCodeLine{00067 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }QueuePointers}
\DoxyCodeLine{00068 \{}
\DoxyCodeLine{00069     int8\_t *pcTail;                 \textcolor{comment}{/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */}}
\DoxyCodeLine{00070     int8\_t *pcReadFrom;             \textcolor{comment}{/*< Points to the last place that a queued item was read from when the structure is used as a queue. */}}
\DoxyCodeLine{00071 \} QueuePointers\_t;}
\DoxyCodeLine{00072 }
\DoxyCodeLine{00073 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }SemaphoreData}
\DoxyCodeLine{00074 \{}
\DoxyCodeLine{00075     TaskHandle\_t xMutexHolder;       \textcolor{comment}{/*< The handle of the task that holds the mutex. */}}
\DoxyCodeLine{00076     UBaseType\_t uxRecursiveCallCount;\textcolor{comment}{/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */}}
\DoxyCodeLine{00077 \} SemaphoreData\_t;}
\DoxyCodeLine{00078 }
\DoxyCodeLine{00079 \textcolor{comment}{/* Semaphores do not actually store or copy data, so have an item size of}}
\DoxyCodeLine{00080 \textcolor{comment}{zero. */}}
\DoxyCodeLine{00081 \textcolor{preprocessor}{\#define queueSEMAPHORE\_QUEUE\_ITEM\_LENGTH ( ( UBaseType\_t ) 0 )}}
\DoxyCodeLine{00082 \textcolor{preprocessor}{\#define queueMUTEX\_GIVE\_BLOCK\_TIME       ( ( TickType\_t ) 0U )}}
\DoxyCodeLine{00083 }
\DoxyCodeLine{00084 \textcolor{preprocessor}{\#if( configUSE\_PREEMPTION == 0 )}}
\DoxyCodeLine{00085     \textcolor{comment}{/* If the cooperative scheduler is being used then a yield should not be}}
\DoxyCodeLine{00086 \textcolor{comment}{    performed just because a higher priority task has been woken. */}}
\DoxyCodeLine{00087 \textcolor{preprocessor}{    \#define queueYIELD\_IF\_USING\_PREEMPTION()}}
\DoxyCodeLine{00088 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00089 \textcolor{preprocessor}{    \#define queueYIELD\_IF\_USING\_PREEMPTION() portYIELD\_WITHIN\_API()}}
\DoxyCodeLine{00090 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 \textcolor{comment}{/*}}
\DoxyCodeLine{00093 \textcolor{comment}{ * Definition of the queue used by the scheduler.}}
\DoxyCodeLine{00094 \textcolor{comment}{ * Items are queued by copy, not reference.  See the following link for the}}
\DoxyCodeLine{00095 \textcolor{comment}{ * rationale: https://www.freertos.org/Embedded-\/RTOS-\/Queues.html}}
\DoxyCodeLine{00096 \textcolor{comment}{ */}}
\DoxyCodeLine{00097 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }QueueDefinition       \textcolor{comment}{/* The old naming convention is used to prevent breaking kernel aware debuggers. */}}
\DoxyCodeLine{00098 \{}
\DoxyCodeLine{00099     int8\_t *pcHead;                 \textcolor{comment}{/*< Points to the beginning of the queue storage area. */}}
\DoxyCodeLine{00100     int8\_t *pcWriteTo;              \textcolor{comment}{/*< Points to the free next place in the storage area. */}}
\DoxyCodeLine{00101 }
\DoxyCodeLine{00102     \textcolor{keyword}{union}}
\DoxyCodeLine{00103     \{}
\DoxyCodeLine{00104         QueuePointers\_t xQueue;      \textcolor{comment}{/*< Data required exclusively when this structure is used as a queue. */}}
\DoxyCodeLine{00105         SemaphoreData\_t xSemaphore; \textcolor{comment}{/*< Data required exclusively when this structure is used as a semaphore. */}}
\DoxyCodeLine{00106     \} u;}
\DoxyCodeLine{00107 }
\DoxyCodeLine{00108     List\_t xTasksWaitingToSend;       \textcolor{comment}{/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */}}
\DoxyCodeLine{00109     List\_t xTasksWaitingToReceive;    \textcolor{comment}{/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */}}
\DoxyCodeLine{00110 }
\DoxyCodeLine{00111     \textcolor{keyword}{volatile} UBaseType\_t uxMessagesWaiting;\textcolor{comment}{/*< The number of items currently in the queue. */}}
\DoxyCodeLine{00112     UBaseType\_t uxLength;           \textcolor{comment}{/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */}}
\DoxyCodeLine{00113     UBaseType\_t uxItemSize;         \textcolor{comment}{/*< The size of each items that the queue will hold. */}}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115     \textcolor{keyword}{volatile} int8\_t cRxLock;        \textcolor{comment}{/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */}}
\DoxyCodeLine{00116     \textcolor{keyword}{volatile} int8\_t cTxLock;        \textcolor{comment}{/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */}}
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118 \textcolor{preprocessor}{    \#if( ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{00119         uint8\_t ucStaticallyAllocated;  \textcolor{comment}{/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */}}
\DoxyCodeLine{00120 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00121 }
\DoxyCodeLine{00122 \textcolor{preprocessor}{    \#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{00123         \textcolor{keyword}{struct }QueueDefinition *pxQueueSetContainer;}
\DoxyCodeLine{00124 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126 \textcolor{preprocessor}{    \#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{00127         UBaseType\_t uxQueueNumber;}
\DoxyCodeLine{00128         uint8\_t ucQueueType;}
\DoxyCodeLine{00129 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00130 }
\DoxyCodeLine{00131 \} xQUEUE;}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133 \textcolor{comment}{/* The old xQUEUE name is maintained above then typedefed to the new Queue\_t}}
\DoxyCodeLine{00134 \textcolor{comment}{name below to enable the use of older kernel aware debuggers. */}}
\DoxyCodeLine{00135 \textcolor{keyword}{typedef} xQUEUE Queue\_t;}
\DoxyCodeLine{00136 }
\DoxyCodeLine{00137 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139 \textcolor{comment}{/*}}
\DoxyCodeLine{00140 \textcolor{comment}{ * The queue registry is just a means for kernel aware debuggers to locate}}
\DoxyCodeLine{00141 \textcolor{comment}{ * queue structures.  It has no other purpose so is an optional component.}}
\DoxyCodeLine{00142 \textcolor{comment}{ */}}
\DoxyCodeLine{00143 \textcolor{preprocessor}{\#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{00144 }
\DoxyCodeLine{00145     \textcolor{comment}{/* The type stored within the queue registry array.  This allows a name}}
\DoxyCodeLine{00146 \textcolor{comment}{    to be assigned to each queue making kernel aware debugging a little}}
\DoxyCodeLine{00147 \textcolor{comment}{    more user friendly. */}}
\DoxyCodeLine{00148     \textcolor{keyword}{typedef} \textcolor{keyword}{struct }QUEUE\_REGISTRY\_ITEM}
\DoxyCodeLine{00149     \{}
\DoxyCodeLine{00150         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pcQueueName; \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{00151         QueueHandle\_t xHandle;}
\DoxyCodeLine{00152     \} xQueueRegistryItem;}
\DoxyCodeLine{00153 }
\DoxyCodeLine{00154     \textcolor{comment}{/* The old xQueueRegistryItem name is maintained above then typedefed to the}}
\DoxyCodeLine{00155 \textcolor{comment}{    new xQueueRegistryItem name below to enable the use of older kernel aware}}
\DoxyCodeLine{00156 \textcolor{comment}{    debuggers. */}}
\DoxyCodeLine{00157     \textcolor{keyword}{typedef} xQueueRegistryItem QueueRegistryItem\_t;}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159     \textcolor{comment}{/* The queue registry is simply an array of QueueRegistryItem\_t structures.}}
\DoxyCodeLine{00160 \textcolor{comment}{    The pcQueueName member of a structure being NULL is indicative of the}}
\DoxyCodeLine{00161 \textcolor{comment}{    array position being vacant. */}}
\DoxyCodeLine{00162     PRIVILEGED\_DATA QueueRegistryItem\_t xQueueRegistry[ configQUEUE\_REGISTRY\_SIZE ];}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configQUEUE\_REGISTRY\_SIZE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00165 }
\DoxyCodeLine{00166 \textcolor{comment}{/*}}
\DoxyCodeLine{00167 \textcolor{comment}{ * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not}}
\DoxyCodeLine{00168 \textcolor{comment}{ * prevent an ISR from adding or removing items to the queue, but does prevent}}
\DoxyCodeLine{00169 \textcolor{comment}{ * an ISR from removing tasks from the queue event lists.  If an ISR finds a}}
\DoxyCodeLine{00170 \textcolor{comment}{ * queue is locked it will instead increment the appropriate queue lock count}}
\DoxyCodeLine{00171 \textcolor{comment}{ * to indicate that a task may require unblocking.  When the queue in unlocked}}
\DoxyCodeLine{00172 \textcolor{comment}{ * these lock counts are inspected, and the appropriate action taken.}}
\DoxyCodeLine{00173 \textcolor{comment}{ */}}
\DoxyCodeLine{00174 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvUnlockQueue( Queue\_t * \textcolor{keyword}{const} pxQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00175 }
\DoxyCodeLine{00176 \textcolor{comment}{/*}}
\DoxyCodeLine{00177 \textcolor{comment}{ * Uses a critical section to determine if there is any data in a queue.}}
\DoxyCodeLine{00178 \textcolor{comment}{ *}}
\DoxyCodeLine{00179 \textcolor{comment}{ * @return pdTRUE if the queue contains no items, otherwise pdFALSE.}}
\DoxyCodeLine{00180 \textcolor{comment}{ */}}
\DoxyCodeLine{00181 \textcolor{keyword}{static} BaseType\_t prvIsQueueEmpty( \textcolor{keyword}{const} Queue\_t *pxQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00182 }
\DoxyCodeLine{00183 \textcolor{comment}{/*}}
\DoxyCodeLine{00184 \textcolor{comment}{ * Uses a critical section to determine if there is any space in a queue.}}
\DoxyCodeLine{00185 \textcolor{comment}{ *}}
\DoxyCodeLine{00186 \textcolor{comment}{ * @return pdTRUE if there is no space, otherwise pdFALSE;}}
\DoxyCodeLine{00187 \textcolor{comment}{ */}}
\DoxyCodeLine{00188 \textcolor{keyword}{static} BaseType\_t prvIsQueueFull( \textcolor{keyword}{const} Queue\_t *pxQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00189 }
\DoxyCodeLine{00190 \textcolor{comment}{/*}}
\DoxyCodeLine{00191 \textcolor{comment}{ * Copies an item into the queue, either at the front of the queue or the}}
\DoxyCodeLine{00192 \textcolor{comment}{ * back of the queue.}}
\DoxyCodeLine{00193 \textcolor{comment}{ */}}
\DoxyCodeLine{00194 \textcolor{keyword}{static} BaseType\_t prvCopyDataToQueue( Queue\_t * \textcolor{keyword}{const} pxQueue, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *pvItemToQueue, \textcolor{keyword}{const} BaseType\_t xPosition ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00195 }
\DoxyCodeLine{00196 \textcolor{comment}{/*}}
\DoxyCodeLine{00197 \textcolor{comment}{ * Copies an item out of a queue.}}
\DoxyCodeLine{00198 \textcolor{comment}{ */}}
\DoxyCodeLine{00199 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvCopyDataFromQueue( Queue\_t * \textcolor{keyword}{const} pxQueue, \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00200 }
\DoxyCodeLine{00201 \textcolor{preprocessor}{\#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{00202     \textcolor{comment}{/*}}
\DoxyCodeLine{00203 \textcolor{comment}{     * Checks to see if a queue is a member of a queue set, and if so, notifies}}
\DoxyCodeLine{00204 \textcolor{comment}{     * the queue set that the queue contains data.}}
\DoxyCodeLine{00205 \textcolor{comment}{     */}}
\DoxyCodeLine{00206     \textcolor{keyword}{static} BaseType\_t prvNotifyQueueSetContainer( \textcolor{keyword}{const} Queue\_t * \textcolor{keyword}{const} pxQueue, \textcolor{keyword}{const} BaseType\_t xCopyPosition ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00207 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00208 }
\DoxyCodeLine{00209 \textcolor{comment}{/*}}
\DoxyCodeLine{00210 \textcolor{comment}{ * Called after a Queue\_t structure has been allocated either statically or}}
\DoxyCodeLine{00211 \textcolor{comment}{ * dynamically to fill in the structure's members.}}
\DoxyCodeLine{00212 \textcolor{comment}{ */}}
\DoxyCodeLine{00213 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseNewQueue( \textcolor{keyword}{const} UBaseType\_t uxQueueLength, \textcolor{keyword}{const} UBaseType\_t uxItemSize, uint8\_t *pucQueueStorage, \textcolor{keyword}{const} uint8\_t ucQueueType, Queue\_t *pxNewQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00214 }
\DoxyCodeLine{00215 \textcolor{comment}{/*}}
\DoxyCodeLine{00216 \textcolor{comment}{ * Mutexes are a special type of queue.  When a mutex is created, first the}}
\DoxyCodeLine{00217 \textcolor{comment}{ * queue is created, then prvInitialiseMutex() is called to configure the queue}}
\DoxyCodeLine{00218 \textcolor{comment}{ * as a mutex.}}
\DoxyCodeLine{00219 \textcolor{comment}{ */}}
\DoxyCodeLine{00220 \textcolor{preprocessor}{\#if( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{00221     \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseMutex( Queue\_t *pxNewQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00222 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00223 }
\DoxyCodeLine{00224 \textcolor{preprocessor}{\#if( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{00225     \textcolor{comment}{/*}}
\DoxyCodeLine{00226 \textcolor{comment}{     * If a task waiting for a mutex causes the mutex holder to inherit a}}
\DoxyCodeLine{00227 \textcolor{comment}{     * priority, but the waiting task times out, then the holder should}}
\DoxyCodeLine{00228 \textcolor{comment}{     * disinherit the priority -\/ but only down to the highest priority of any}}
\DoxyCodeLine{00229 \textcolor{comment}{     * other tasks that are waiting for the same mutex.  This function returns}}
\DoxyCodeLine{00230 \textcolor{comment}{     * that priority.}}
\DoxyCodeLine{00231 \textcolor{comment}{     */}}
\DoxyCodeLine{00232     \textcolor{keyword}{static} UBaseType\_t prvGetDisinheritPriorityAfterTimeout( \textcolor{keyword}{const} Queue\_t * \textcolor{keyword}{const} pxQueue ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00233 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00234 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00235 }
\DoxyCodeLine{00236 \textcolor{comment}{/*}}
\DoxyCodeLine{00237 \textcolor{comment}{ * Macro to mark a queue as locked.  Locking a queue prevents an ISR from}}
\DoxyCodeLine{00238 \textcolor{comment}{ * accessing the queue event lists.}}
\DoxyCodeLine{00239 \textcolor{comment}{ */}}
\DoxyCodeLine{00240 \textcolor{preprocessor}{\#define prvLockQueue( pxQueue )                             \(\backslash\)}}
\DoxyCodeLine{00241 \textcolor{preprocessor}{    taskENTER\_CRITICAL();                                   \(\backslash\)}}
\DoxyCodeLine{00242 \textcolor{preprocessor}{    \{                                                       \(\backslash\)}}
\DoxyCodeLine{00243 \textcolor{preprocessor}{        if( ( pxQueue )-\/>cRxLock == queueUNLOCKED )         \(\backslash\)}}
\DoxyCodeLine{00244 \textcolor{preprocessor}{        \{                                                   \(\backslash\)}}
\DoxyCodeLine{00245 \textcolor{preprocessor}{            ( pxQueue )-\/>cRxLock = queueLOCKED\_UNMODIFIED;  \(\backslash\)}}
\DoxyCodeLine{00246 \textcolor{preprocessor}{        \}                                                   \(\backslash\)}}
\DoxyCodeLine{00247 \textcolor{preprocessor}{        if( ( pxQueue )-\/>cTxLock == queueUNLOCKED )         \(\backslash\)}}
\DoxyCodeLine{00248 \textcolor{preprocessor}{        \{                                                   \(\backslash\)}}
\DoxyCodeLine{00249 \textcolor{preprocessor}{            ( pxQueue )-\/>cTxLock = queueLOCKED\_UNMODIFIED;  \(\backslash\)}}
\DoxyCodeLine{00250 \textcolor{preprocessor}{        \}                                                   \(\backslash\)}}
\DoxyCodeLine{00251 \textcolor{preprocessor}{    \}                                                       \(\backslash\)}}
\DoxyCodeLine{00252 \textcolor{preprocessor}{    taskEXIT\_CRITICAL()}}
\DoxyCodeLine{00253 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00254 }
\DoxyCodeLine{00255 BaseType\_t xQueueGenericReset( QueueHandle\_t xQueue, BaseType\_t xNewQueue )}
\DoxyCodeLine{00256 \{}
\DoxyCodeLine{00257 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{00258 }
\DoxyCodeLine{00259     configASSERT( pxQueue );}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     taskENTER\_CRITICAL();}
\DoxyCodeLine{00262     \{}
\DoxyCodeLine{00263         pxQueue-\/>u.xQueue.pcTail = pxQueue-\/>pcHead + ( pxQueue-\/>uxLength * pxQueue-\/>uxItemSize ); \textcolor{comment}{/*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */}}
\DoxyCodeLine{00264         pxQueue-\/>uxMessagesWaiting = ( UBaseType\_t ) 0U;}
\DoxyCodeLine{00265         pxQueue-\/>pcWriteTo = pxQueue-\/>pcHead;}
\DoxyCodeLine{00266         pxQueue-\/>u.xQueue.pcReadFrom = pxQueue-\/>pcHead + ( ( pxQueue-\/>uxLength -\/ 1U ) * pxQueue-\/>uxItemSize ); \textcolor{comment}{/*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */}}
\DoxyCodeLine{00267         pxQueue-\/>cRxLock = queueUNLOCKED;}
\DoxyCodeLine{00268         pxQueue-\/>cTxLock = queueUNLOCKED;}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270         \textcolor{keywordflow}{if}( xNewQueue == pdFALSE )}
\DoxyCodeLine{00271         \{}
\DoxyCodeLine{00272             \textcolor{comment}{/* If there are tasks blocked waiting to read from the queue, then}}
\DoxyCodeLine{00273 \textcolor{comment}{            the tasks will remain blocked as after this function exits the queue}}
\DoxyCodeLine{00274 \textcolor{comment}{            will still be empty.  If there are tasks blocked waiting to write to}}
\DoxyCodeLine{00275 \textcolor{comment}{            the queue, then one should be unblocked as after this function exits}}
\DoxyCodeLine{00276 \textcolor{comment}{            it will be possible to write to it. */}}
\DoxyCodeLine{00277             \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToSend ) ) == pdFALSE )}
\DoxyCodeLine{00278             \{}
\DoxyCodeLine{00279                 \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToSend ) ) != pdFALSE )}
\DoxyCodeLine{00280                 \{}
\DoxyCodeLine{00281                     queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{00282                 \}}
\DoxyCodeLine{00283                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{00284                 \{}
\DoxyCodeLine{00285                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00286                 \}}
\DoxyCodeLine{00287             \}}
\DoxyCodeLine{00288             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00289             \{}
\DoxyCodeLine{00290                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00291             \}}
\DoxyCodeLine{00292         \}}
\DoxyCodeLine{00293         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00294         \{}
\DoxyCodeLine{00295             \textcolor{comment}{/* Ensure the event queues start in the correct state. */}}
\DoxyCodeLine{00296             vListInitialise( \&( pxQueue-\/>xTasksWaitingToSend ) );}
\DoxyCodeLine{00297             vListInitialise( \&( pxQueue-\/>xTasksWaitingToReceive ) );}
\DoxyCodeLine{00298         \}}
\DoxyCodeLine{00299     \}}
\DoxyCodeLine{00300     taskEXIT\_CRITICAL();}
\DoxyCodeLine{00301 }
\DoxyCodeLine{00302     \textcolor{comment}{/* A value is returned for calling semantic consistency with previous}}
\DoxyCodeLine{00303 \textcolor{comment}{    versions. */}}
\DoxyCodeLine{00304     \textcolor{keywordflow}{return} pdPASS;}
\DoxyCodeLine{00305 \}}
\DoxyCodeLine{00306 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308 \textcolor{preprocessor}{\#if( configSUPPORT\_STATIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{00309 }
\DoxyCodeLine{00310     QueueHandle\_t xQueueGenericCreateStatic( \textcolor{keyword}{const} UBaseType\_t uxQueueLength, \textcolor{keyword}{const} UBaseType\_t uxItemSize, uint8\_t *pucQueueStorage, StaticQueue\_t *pxStaticQueue, \textcolor{keyword}{const} uint8\_t ucQueueType )}
\DoxyCodeLine{00311     \{}
\DoxyCodeLine{00312     Queue\_t *pxNewQueue;}
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314         configASSERT( uxQueueLength > ( UBaseType\_t ) 0 );}
\DoxyCodeLine{00315 }
\DoxyCodeLine{00316         \textcolor{comment}{/* The StaticQueue\_t structure and the queue storage area must be}}
\DoxyCodeLine{00317 \textcolor{comment}{        supplied. */}}
\DoxyCodeLine{00318         configASSERT( pxStaticQueue != NULL );}
\DoxyCodeLine{00319 }
\DoxyCodeLine{00320         \textcolor{comment}{/* A queue storage area should be provided if the item size is not 0, and}}
\DoxyCodeLine{00321 \textcolor{comment}{        should not be provided if the item size is 0. */}}
\DoxyCodeLine{00322         configASSERT( !( ( pucQueueStorage != NULL ) \&\& ( uxItemSize == 0 ) ) );}
\DoxyCodeLine{00323         configASSERT( !( ( pucQueueStorage == NULL ) \&\& ( uxItemSize != 0 ) ) );}
\DoxyCodeLine{00324 }
\DoxyCodeLine{00325 \textcolor{preprocessor}{        \#if( configASSERT\_DEFINED == 1 )}}
\DoxyCodeLine{00326         \{}
\DoxyCodeLine{00327             \textcolor{comment}{/* Sanity check that the size of the structure used to declare a}}
\DoxyCodeLine{00328 \textcolor{comment}{            variable of type StaticQueue\_t or StaticSemaphore\_t equals the size of}}
\DoxyCodeLine{00329 \textcolor{comment}{            the real queue and semaphore structures. */}}
\DoxyCodeLine{00330             \textcolor{keyword}{volatile} \textcolor{keywordtype}{size\_t} xSize = \textcolor{keyword}{sizeof}( StaticQueue\_t );}
\DoxyCodeLine{00331             configASSERT( xSize == \textcolor{keyword}{sizeof}( Queue\_t ) );}
\DoxyCodeLine{00332             ( void ) xSize; \textcolor{comment}{/* Keeps lint quiet when configASSERT() is not defined. */}}
\DoxyCodeLine{00333         \}}
\DoxyCodeLine{00334 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configASSERT\_DEFINED */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336         \textcolor{comment}{/* The address of a statically allocated queue was passed in, use it.}}
\DoxyCodeLine{00337 \textcolor{comment}{        The address of a statically allocated storage area was also passed in}}
\DoxyCodeLine{00338 \textcolor{comment}{        but is already set. */}}
\DoxyCodeLine{00339         pxNewQueue = ( Queue\_t * ) pxStaticQueue; \textcolor{comment}{/*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */}}
\DoxyCodeLine{00340 }
\DoxyCodeLine{00341         \textcolor{keywordflow}{if}( pxNewQueue != NULL )}
\DoxyCodeLine{00342         \{}
\DoxyCodeLine{00343 \textcolor{preprocessor}{            \#if( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{00344             \{}
\DoxyCodeLine{00345                 \textcolor{comment}{/* Queues can be allocated wither statically or dynamically, so}}
\DoxyCodeLine{00346 \textcolor{comment}{                note this queue was allocated statically in case the queue is}}
\DoxyCodeLine{00347 \textcolor{comment}{                later deleted. */}}
\DoxyCodeLine{00348                 pxNewQueue-\/>ucStaticallyAllocated = pdTRUE;}
\DoxyCodeLine{00349             \}}
\DoxyCodeLine{00350 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* configSUPPORT\_DYNAMIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00351 }
\DoxyCodeLine{00352             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );}
\DoxyCodeLine{00353         \}}
\DoxyCodeLine{00354         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00355         \{}
\DoxyCodeLine{00356             traceQUEUE\_CREATE\_FAILED( ucQueueType );}
\DoxyCodeLine{00357             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00358         \}}
\DoxyCodeLine{00359 }
\DoxyCodeLine{00360         \textcolor{keywordflow}{return} pxNewQueue;}
\DoxyCodeLine{00361     \}}
\DoxyCodeLine{00362 }
\DoxyCodeLine{00363 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configSUPPORT\_STATIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00364 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00365 }
\DoxyCodeLine{00366 \textcolor{preprocessor}{\#if( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{00367 }
\DoxyCodeLine{00368     QueueHandle\_t xQueueGenericCreate( \textcolor{keyword}{const} UBaseType\_t uxQueueLength, \textcolor{keyword}{const} UBaseType\_t uxItemSize, \textcolor{keyword}{const} uint8\_t ucQueueType )}
\DoxyCodeLine{00369     \{}
\DoxyCodeLine{00370     Queue\_t *pxNewQueue;}
\DoxyCodeLine{00371     \textcolor{keywordtype}{size\_t} xQueueSizeInBytes;}
\DoxyCodeLine{00372     uint8\_t *pucQueueStorage;}
\DoxyCodeLine{00373 }
\DoxyCodeLine{00374         configASSERT( uxQueueLength > ( UBaseType\_t ) 0 );}
\DoxyCodeLine{00375 }
\DoxyCodeLine{00376         \textcolor{keywordflow}{if}( uxItemSize == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{00377         \{}
\DoxyCodeLine{00378             \textcolor{comment}{/* There is not going to be a queue storage area. */}}
\DoxyCodeLine{00379             xQueueSizeInBytes = ( size\_t ) 0;}
\DoxyCodeLine{00380         \}}
\DoxyCodeLine{00381         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00382         \{}
\DoxyCodeLine{00383             \textcolor{comment}{/* Allocate enough space to hold the maximum number of items that}}
\DoxyCodeLine{00384 \textcolor{comment}{            can be in the queue at any time. */}}
\DoxyCodeLine{00385             xQueueSizeInBytes = ( size\_t ) ( uxQueueLength * uxItemSize ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{00386         \}}
\DoxyCodeLine{00387 }
\DoxyCodeLine{00388         \textcolor{comment}{/* Allocate the queue and storage area.  Justification for MISRA}}
\DoxyCodeLine{00389 \textcolor{comment}{        deviation as follows:  pvPortMalloc() always ensures returned memory}}
\DoxyCodeLine{00390 \textcolor{comment}{        blocks are aligned per the requirements of the MCU stack.  In this case}}
\DoxyCodeLine{00391 \textcolor{comment}{        pvPortMalloc() must return a pointer that is guaranteed to meet the}}
\DoxyCodeLine{00392 \textcolor{comment}{        alignment requirements of the Queue\_t structure -\/ which in this case}}
\DoxyCodeLine{00393 \textcolor{comment}{        is an int8\_t *.  Therefore, whenever the stack alignment requirements}}
\DoxyCodeLine{00394 \textcolor{comment}{        are greater than or equal to the pointer to char requirements the cast}}
\DoxyCodeLine{00395 \textcolor{comment}{        is safe.  In other cases alignment requirements are not strict (one or}}
\DoxyCodeLine{00396 \textcolor{comment}{        two bytes). */}}
\DoxyCodeLine{00397         pxNewQueue = ( Queue\_t * ) pvPortMalloc( \textcolor{keyword}{sizeof}( Queue\_t ) + xQueueSizeInBytes ); \textcolor{comment}{/*lint !e9087 !e9079 see comment above. */}}
\DoxyCodeLine{00398 }
\DoxyCodeLine{00399         \textcolor{keywordflow}{if}( pxNewQueue != NULL )}
\DoxyCodeLine{00400         \{}
\DoxyCodeLine{00401             \textcolor{comment}{/* Jump past the queue structure to find the location of the queue}}
\DoxyCodeLine{00402 \textcolor{comment}{            storage area. */}}
\DoxyCodeLine{00403             pucQueueStorage = ( uint8\_t * ) pxNewQueue;}
\DoxyCodeLine{00404             pucQueueStorage += \textcolor{keyword}{sizeof}( Queue\_t ); \textcolor{comment}{/*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */}}
\DoxyCodeLine{00405 }
\DoxyCodeLine{00406 \textcolor{preprocessor}{            \#if( configSUPPORT\_STATIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{00407             \{}
\DoxyCodeLine{00408                 \textcolor{comment}{/* Queues can be created either statically or dynamically, so}}
\DoxyCodeLine{00409 \textcolor{comment}{                note this task was created dynamically in case it is later}}
\DoxyCodeLine{00410 \textcolor{comment}{                deleted. */}}
\DoxyCodeLine{00411                 pxNewQueue-\/>ucStaticallyAllocated = pdFALSE;}
\DoxyCodeLine{00412             \}}
\DoxyCodeLine{00413 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* configSUPPORT\_STATIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00414 }
\DoxyCodeLine{00415             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );}
\DoxyCodeLine{00416         \}}
\DoxyCodeLine{00417         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00418         \{}
\DoxyCodeLine{00419             traceQUEUE\_CREATE\_FAILED( ucQueueType );}
\DoxyCodeLine{00420             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00421         \}}
\DoxyCodeLine{00422 }
\DoxyCodeLine{00423         \textcolor{keywordflow}{return} pxNewQueue;}
\DoxyCodeLine{00424     \}}
\DoxyCodeLine{00425 }
\DoxyCodeLine{00426 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configSUPPORT\_STATIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00427 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00428 }
\DoxyCodeLine{00429 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseNewQueue( \textcolor{keyword}{const} UBaseType\_t uxQueueLength, \textcolor{keyword}{const} UBaseType\_t uxItemSize, uint8\_t *pucQueueStorage, \textcolor{keyword}{const} uint8\_t ucQueueType, Queue\_t *pxNewQueue )}
\DoxyCodeLine{00430 \{}
\DoxyCodeLine{00431     \textcolor{comment}{/* Remove compiler warnings about unused parameters should}}
\DoxyCodeLine{00432 \textcolor{comment}{    configUSE\_TRACE\_FACILITY not be set to 1. */}}
\DoxyCodeLine{00433     ( void ) ucQueueType;}
\DoxyCodeLine{00434 }
\DoxyCodeLine{00435     \textcolor{keywordflow}{if}( uxItemSize == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{00436     \{}
\DoxyCodeLine{00437         \textcolor{comment}{/* No RAM was allocated for the queue storage area, but PC head cannot}}
\DoxyCodeLine{00438 \textcolor{comment}{        be set to NULL because NULL is used as a key to say the queue is used as}}
\DoxyCodeLine{00439 \textcolor{comment}{        a mutex.  Therefore just set pcHead to point to the queue as a benign}}
\DoxyCodeLine{00440 \textcolor{comment}{        value that is known to be within the memory map. */}}
\DoxyCodeLine{00441         pxNewQueue-\/>pcHead = ( int8\_t * ) pxNewQueue;}
\DoxyCodeLine{00442     \}}
\DoxyCodeLine{00443     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00444     \{}
\DoxyCodeLine{00445         \textcolor{comment}{/* Set the head to the start of the queue storage area. */}}
\DoxyCodeLine{00446         pxNewQueue-\/>pcHead = ( int8\_t * ) pucQueueStorage;}
\DoxyCodeLine{00447     \}}
\DoxyCodeLine{00448 }
\DoxyCodeLine{00449     \textcolor{comment}{/* Initialise the queue members as described where the queue type is}}
\DoxyCodeLine{00450 \textcolor{comment}{    defined. */}}
\DoxyCodeLine{00451     pxNewQueue-\/>uxLength = uxQueueLength;}
\DoxyCodeLine{00452     pxNewQueue-\/>uxItemSize = uxItemSize;}
\DoxyCodeLine{00453     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );}
\DoxyCodeLine{00454 }
\DoxyCodeLine{00455 \textcolor{preprocessor}{    \#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{00456     \{}
\DoxyCodeLine{00457         pxNewQueue-\/>ucQueueType = ucQueueType;}
\DoxyCodeLine{00458     \}}
\DoxyCodeLine{00459 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00460 }
\DoxyCodeLine{00461 \textcolor{preprocessor}{    \#if( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{00462     \{}
\DoxyCodeLine{00463         pxNewQueue-\/>pxQueueSetContainer = NULL;}
\DoxyCodeLine{00464     \}}
\DoxyCodeLine{00465 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00466 }
\DoxyCodeLine{00467     traceQUEUE\_CREATE( pxNewQueue );}
\DoxyCodeLine{00468 \}}
\DoxyCodeLine{00469 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00470 }
\DoxyCodeLine{00471 \textcolor{preprocessor}{\#if( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{00472 }
\DoxyCodeLine{00473     \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseMutex( Queue\_t *pxNewQueue )}
\DoxyCodeLine{00474     \{}
\DoxyCodeLine{00475         \textcolor{keywordflow}{if}( pxNewQueue != NULL )}
\DoxyCodeLine{00476         \{}
\DoxyCodeLine{00477             \textcolor{comment}{/* The queue create function will set all the queue structure members}}
\DoxyCodeLine{00478 \textcolor{comment}{            correctly for a generic queue, but this function is creating a}}
\DoxyCodeLine{00479 \textcolor{comment}{            mutex.  Overwrite those members that need to be set differently -\/}}
\DoxyCodeLine{00480 \textcolor{comment}{            in particular the information required for priority inheritance. */}}
\DoxyCodeLine{00481             pxNewQueue-\/>u.xSemaphore.xMutexHolder = NULL;}
\DoxyCodeLine{00482             pxNewQueue-\/>uxQueueType = queueQUEUE\_IS\_MUTEX;}
\DoxyCodeLine{00483 }
\DoxyCodeLine{00484             \textcolor{comment}{/* In case this is a recursive mutex. */}}
\DoxyCodeLine{00485             pxNewQueue-\/>u.xSemaphore.uxRecursiveCallCount = 0;}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487             traceCREATE\_MUTEX( pxNewQueue );}
\DoxyCodeLine{00488 }
\DoxyCodeLine{00489             \textcolor{comment}{/* Start with the semaphore in the expected state. */}}
\DoxyCodeLine{00490             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType\_t ) 0U, queueSEND\_TO\_BACK );}
\DoxyCodeLine{00491         \}}
\DoxyCodeLine{00492         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00493         \{}
\DoxyCodeLine{00494             traceCREATE\_MUTEX\_FAILED();}
\DoxyCodeLine{00495         \}}
\DoxyCodeLine{00496     \}}
\DoxyCodeLine{00497 }
\DoxyCodeLine{00498 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00499 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00500 }
\DoxyCodeLine{00501 \textcolor{preprocessor}{\#if( ( configUSE\_MUTEXES == 1 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{00502 }
\DoxyCodeLine{00503     QueueHandle\_t xQueueCreateMutex( \textcolor{keyword}{const} uint8\_t ucQueueType )}
\DoxyCodeLine{00504     \{}
\DoxyCodeLine{00505     QueueHandle\_t xNewQueue;}
\DoxyCodeLine{00506     \textcolor{keyword}{const} UBaseType\_t uxMutexLength = ( UBaseType\_t ) 1, uxMutexSize = ( UBaseType\_t ) 0;}
\DoxyCodeLine{00507 }
\DoxyCodeLine{00508         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );}
\DoxyCodeLine{00509         prvInitialiseMutex( ( Queue\_t * ) xNewQueue );}
\DoxyCodeLine{00510 }
\DoxyCodeLine{00511         \textcolor{keywordflow}{return} xNewQueue;}
\DoxyCodeLine{00512     \}}
\DoxyCodeLine{00513 }
\DoxyCodeLine{00514 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00515 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00516 }
\DoxyCodeLine{00517 \textcolor{preprocessor}{\#if( ( configUSE\_MUTEXES == 1 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{00518 }
\DoxyCodeLine{00519     QueueHandle\_t xQueueCreateMutexStatic( \textcolor{keyword}{const} uint8\_t ucQueueType, StaticQueue\_t *pxStaticQueue )}
\DoxyCodeLine{00520     \{}
\DoxyCodeLine{00521     QueueHandle\_t xNewQueue;}
\DoxyCodeLine{00522     \textcolor{keyword}{const} UBaseType\_t uxMutexLength = ( UBaseType\_t ) 1, uxMutexSize = ( UBaseType\_t ) 0;}
\DoxyCodeLine{00523 }
\DoxyCodeLine{00524         \textcolor{comment}{/* Prevent compiler warnings about unused parameters if}}
\DoxyCodeLine{00525 \textcolor{comment}{        configUSE\_TRACE\_FACILITY does not equal 1. */}}
\DoxyCodeLine{00526         ( void ) ucQueueType;}
\DoxyCodeLine{00527 }
\DoxyCodeLine{00528         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );}
\DoxyCodeLine{00529         prvInitialiseMutex( ( Queue\_t * ) xNewQueue );}
\DoxyCodeLine{00530 }
\DoxyCodeLine{00531         \textcolor{keywordflow}{return} xNewQueue;}
\DoxyCodeLine{00532     \}}
\DoxyCodeLine{00533 }
\DoxyCodeLine{00534 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00535 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00536 }
\DoxyCodeLine{00537 \textcolor{preprocessor}{\#if ( ( configUSE\_MUTEXES == 1 ) \&\& ( INCLUDE\_xSemaphoreGetMutexHolder == 1 ) )}}
\DoxyCodeLine{00538 }
\DoxyCodeLine{00539     TaskHandle\_t xQueueGetMutexHolder( QueueHandle\_t xSemaphore )}
\DoxyCodeLine{00540     \{}
\DoxyCodeLine{00541     TaskHandle\_t pxReturn;}
\DoxyCodeLine{00542     Queue\_t * \textcolor{keyword}{const} pxSemaphore = ( Queue\_t * ) xSemaphore;}
\DoxyCodeLine{00543 }
\DoxyCodeLine{00544         \textcolor{comment}{/* This function is called by xSemaphoreGetMutexHolder(), and should not}}
\DoxyCodeLine{00545 \textcolor{comment}{        be called directly.  Note:  This is a good way of determining if the}}
\DoxyCodeLine{00546 \textcolor{comment}{        calling task is the mutex holder, but not a good way of determining the}}
\DoxyCodeLine{00547 \textcolor{comment}{        identity of the mutex holder, as the holder may change between the}}
\DoxyCodeLine{00548 \textcolor{comment}{        following critical section exiting and the function returning. */}}
\DoxyCodeLine{00549         taskENTER\_CRITICAL();}
\DoxyCodeLine{00550         \{}
\DoxyCodeLine{00551             \textcolor{keywordflow}{if}( pxSemaphore-\/>uxQueueType == queueQUEUE\_IS\_MUTEX )}
\DoxyCodeLine{00552             \{}
\DoxyCodeLine{00553                 pxReturn = pxSemaphore-\/>u.xSemaphore.xMutexHolder;}
\DoxyCodeLine{00554             \}}
\DoxyCodeLine{00555             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00556             \{}
\DoxyCodeLine{00557                 pxReturn = NULL;}
\DoxyCodeLine{00558             \}}
\DoxyCodeLine{00559         \}}
\DoxyCodeLine{00560         taskEXIT\_CRITICAL();}
\DoxyCodeLine{00561 }
\DoxyCodeLine{00562         \textcolor{keywordflow}{return} pxReturn;}
\DoxyCodeLine{00563     \} \textcolor{comment}{/*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */}}
\DoxyCodeLine{00564 }
\DoxyCodeLine{00565 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00566 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00567 }
\DoxyCodeLine{00568 \textcolor{preprocessor}{\#if ( ( configUSE\_MUTEXES == 1 ) \&\& ( INCLUDE\_xSemaphoreGetMutexHolder == 1 ) )}}
\DoxyCodeLine{00569 }
\DoxyCodeLine{00570     TaskHandle\_t xQueueGetMutexHolderFromISR( QueueHandle\_t xSemaphore )}
\DoxyCodeLine{00571     \{}
\DoxyCodeLine{00572     TaskHandle\_t pxReturn;}
\DoxyCodeLine{00573 }
\DoxyCodeLine{00574         configASSERT( xSemaphore );}
\DoxyCodeLine{00575 }
\DoxyCodeLine{00576         \textcolor{comment}{/* Mutexes cannot be used in interrupt service routines, so the mutex}}
\DoxyCodeLine{00577 \textcolor{comment}{        holder should not change in an ISR, and therefore a critical section is}}
\DoxyCodeLine{00578 \textcolor{comment}{        not required here. */}}
\DoxyCodeLine{00579         \textcolor{keywordflow}{if}( ( ( Queue\_t * ) xSemaphore )-\/>uxQueueType == queueQUEUE\_IS\_MUTEX )}
\DoxyCodeLine{00580         \{}
\DoxyCodeLine{00581             pxReturn = ( ( Queue\_t * ) xSemaphore )-\/>u.xSemaphore.xMutexHolder;}
\DoxyCodeLine{00582         \}}
\DoxyCodeLine{00583         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00584         \{}
\DoxyCodeLine{00585             pxReturn = NULL;}
\DoxyCodeLine{00586         \}}
\DoxyCodeLine{00587 }
\DoxyCodeLine{00588         \textcolor{keywordflow}{return} pxReturn;}
\DoxyCodeLine{00589     \} \textcolor{comment}{/*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */}}
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00592 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00593 }
\DoxyCodeLine{00594 \textcolor{preprocessor}{\#if ( configUSE\_RECURSIVE\_MUTEXES == 1 )}}
\DoxyCodeLine{00595 }
\DoxyCodeLine{00596     BaseType\_t xQueueGiveMutexRecursive( QueueHandle\_t xMutex )}
\DoxyCodeLine{00597     \{}
\DoxyCodeLine{00598     BaseType\_t xReturn;}
\DoxyCodeLine{00599     Queue\_t * \textcolor{keyword}{const} pxMutex = ( Queue\_t * ) xMutex;}
\DoxyCodeLine{00600 }
\DoxyCodeLine{00601         configASSERT( pxMutex );}
\DoxyCodeLine{00602 }
\DoxyCodeLine{00603         \textcolor{comment}{/* If this is the task that holds the mutex then xMutexHolder will not}}
\DoxyCodeLine{00604 \textcolor{comment}{        change outside of this task.  If this task does not hold the mutex then}}
\DoxyCodeLine{00605 \textcolor{comment}{        pxMutexHolder can never coincidentally equal the tasks handle, and as}}
\DoxyCodeLine{00606 \textcolor{comment}{        this is the only condition we are interested in it does not matter if}}
\DoxyCodeLine{00607 \textcolor{comment}{        pxMutexHolder is accessed simultaneously by another task.  Therefore no}}
\DoxyCodeLine{00608 \textcolor{comment}{        mutual exclusion is required to test the pxMutexHolder variable. */}}
\DoxyCodeLine{00609         \textcolor{keywordflow}{if}( pxMutex-\/>u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )}
\DoxyCodeLine{00610         \{}
\DoxyCodeLine{00611             traceGIVE\_MUTEX\_RECURSIVE( pxMutex );}
\DoxyCodeLine{00612 }
\DoxyCodeLine{00613             \textcolor{comment}{/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to}}
\DoxyCodeLine{00614 \textcolor{comment}{            the task handle, therefore no underflow check is required.  Also,}}
\DoxyCodeLine{00615 \textcolor{comment}{            uxRecursiveCallCount is only modified by the mutex holder, and as}}
\DoxyCodeLine{00616 \textcolor{comment}{            there can only be one, no mutual exclusion is required to modify the}}
\DoxyCodeLine{00617 \textcolor{comment}{            uxRecursiveCallCount member. */}}
\DoxyCodeLine{00618             ( pxMutex-\/>u.xSemaphore.uxRecursiveCallCount )-\/-\/;}
\DoxyCodeLine{00619 }
\DoxyCodeLine{00620             \textcolor{comment}{/* Has the recursive call count unwound to 0? */}}
\DoxyCodeLine{00621             \textcolor{keywordflow}{if}( pxMutex-\/>u.xSemaphore.uxRecursiveCallCount == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{00622             \{}
\DoxyCodeLine{00623                 \textcolor{comment}{/* Return the mutex.  This will automatically unblock any other}}
\DoxyCodeLine{00624 \textcolor{comment}{                task that might be waiting to access the mutex. */}}
\DoxyCodeLine{00625                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX\_GIVE\_BLOCK\_TIME, queueSEND\_TO\_BACK );}
\DoxyCodeLine{00626             \}}
\DoxyCodeLine{00627             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00628             \{}
\DoxyCodeLine{00629                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00630             \}}
\DoxyCodeLine{00631 }
\DoxyCodeLine{00632             xReturn = pdPASS;}
\DoxyCodeLine{00633         \}}
\DoxyCodeLine{00634         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00635         \{}
\DoxyCodeLine{00636             \textcolor{comment}{/* The mutex cannot be given because the calling task is not the}}
\DoxyCodeLine{00637 \textcolor{comment}{            holder. */}}
\DoxyCodeLine{00638             xReturn = pdFAIL;}
\DoxyCodeLine{00639 }
\DoxyCodeLine{00640             traceGIVE\_MUTEX\_RECURSIVE\_FAILED( pxMutex );}
\DoxyCodeLine{00641         \}}
\DoxyCodeLine{00642 }
\DoxyCodeLine{00643         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{00644     \}}
\DoxyCodeLine{00645 }
\DoxyCodeLine{00646 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_RECURSIVE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00647 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00648 }
\DoxyCodeLine{00649 \textcolor{preprocessor}{\#if ( configUSE\_RECURSIVE\_MUTEXES == 1 )}}
\DoxyCodeLine{00650 }
\DoxyCodeLine{00651     BaseType\_t xQueueTakeMutexRecursive( QueueHandle\_t xMutex, TickType\_t xTicksToWait )}
\DoxyCodeLine{00652     \{}
\DoxyCodeLine{00653     BaseType\_t xReturn;}
\DoxyCodeLine{00654     Queue\_t * \textcolor{keyword}{const} pxMutex = ( Queue\_t * ) xMutex;}
\DoxyCodeLine{00655 }
\DoxyCodeLine{00656         configASSERT( pxMutex );}
\DoxyCodeLine{00657 }
\DoxyCodeLine{00658         \textcolor{comment}{/* Comments regarding mutual exclusion as per those within}}
\DoxyCodeLine{00659 \textcolor{comment}{        xQueueGiveMutexRecursive(). */}}
\DoxyCodeLine{00660 }
\DoxyCodeLine{00661         traceTAKE\_MUTEX\_RECURSIVE( pxMutex );}
\DoxyCodeLine{00662 }
\DoxyCodeLine{00663         \textcolor{keywordflow}{if}( pxMutex-\/>u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )}
\DoxyCodeLine{00664         \{}
\DoxyCodeLine{00665             ( pxMutex-\/>u.xSemaphore.uxRecursiveCallCount )++;}
\DoxyCodeLine{00666             xReturn = pdPASS;}
\DoxyCodeLine{00667         \}}
\DoxyCodeLine{00668         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00669         \{}
\DoxyCodeLine{00670             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );}
\DoxyCodeLine{00671 }
\DoxyCodeLine{00672             \textcolor{comment}{/* pdPASS will only be returned if the mutex was successfully}}
\DoxyCodeLine{00673 \textcolor{comment}{            obtained.  The calling task may have entered the Blocked state}}
\DoxyCodeLine{00674 \textcolor{comment}{            before reaching here. */}}
\DoxyCodeLine{00675             \textcolor{keywordflow}{if}( xReturn != pdFAIL )}
\DoxyCodeLine{00676             \{}
\DoxyCodeLine{00677                 ( pxMutex-\/>u.xSemaphore.uxRecursiveCallCount )++;}
\DoxyCodeLine{00678             \}}
\DoxyCodeLine{00679             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00680             \{}
\DoxyCodeLine{00681                 traceTAKE\_MUTEX\_RECURSIVE\_FAILED( pxMutex );}
\DoxyCodeLine{00682             \}}
\DoxyCodeLine{00683         \}}
\DoxyCodeLine{00684 }
\DoxyCodeLine{00685         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{00686     \}}
\DoxyCodeLine{00687 }
\DoxyCodeLine{00688 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_RECURSIVE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00689 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00690 }
\DoxyCodeLine{00691 \textcolor{preprocessor}{\#if( ( configUSE\_COUNTING\_SEMAPHORES == 1 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{00692 }
\DoxyCodeLine{00693     QueueHandle\_t xQueueCreateCountingSemaphoreStatic( \textcolor{keyword}{const} UBaseType\_t uxMaxCount, \textcolor{keyword}{const} UBaseType\_t uxInitialCount, StaticQueue\_t *pxStaticQueue )}
\DoxyCodeLine{00694     \{}
\DoxyCodeLine{00695     QueueHandle\_t xHandle;}
\DoxyCodeLine{00696 }
\DoxyCodeLine{00697         configASSERT( uxMaxCount != 0 );}
\DoxyCodeLine{00698         configASSERT( uxInitialCount <= uxMaxCount );}
\DoxyCodeLine{00699 }
\DoxyCodeLine{00700         xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE\_QUEUE\_ITEM\_LENGTH, NULL, pxStaticQueue, queueQUEUE\_TYPE\_COUNTING\_SEMAPHORE );}
\DoxyCodeLine{00701 }
\DoxyCodeLine{00702         \textcolor{keywordflow}{if}( xHandle != NULL )}
\DoxyCodeLine{00703         \{}
\DoxyCodeLine{00704             ( ( Queue\_t * ) xHandle )-\/>uxMessagesWaiting = uxInitialCount;}
\DoxyCodeLine{00705 }
\DoxyCodeLine{00706             traceCREATE\_COUNTING\_SEMAPHORE();}
\DoxyCodeLine{00707         \}}
\DoxyCodeLine{00708         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00709         \{}
\DoxyCodeLine{00710             traceCREATE\_COUNTING\_SEMAPHORE\_FAILED();}
\DoxyCodeLine{00711         \}}
\DoxyCodeLine{00712 }
\DoxyCodeLine{00713         \textcolor{keywordflow}{return} xHandle;}
\DoxyCodeLine{00714     \}}
\DoxyCodeLine{00715 }
\DoxyCodeLine{00716 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( configUSE\_COUNTING\_SEMAPHORES == 1 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00717 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00718 }
\DoxyCodeLine{00719 \textcolor{preprocessor}{\#if( ( configUSE\_COUNTING\_SEMAPHORES == 1 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{00720 }
\DoxyCodeLine{00721     QueueHandle\_t xQueueCreateCountingSemaphore( \textcolor{keyword}{const} UBaseType\_t uxMaxCount, \textcolor{keyword}{const} UBaseType\_t uxInitialCount )}
\DoxyCodeLine{00722     \{}
\DoxyCodeLine{00723     QueueHandle\_t xHandle;}
\DoxyCodeLine{00724 }
\DoxyCodeLine{00725         configASSERT( uxMaxCount != 0 );}
\DoxyCodeLine{00726         configASSERT( uxInitialCount <= uxMaxCount );}
\DoxyCodeLine{00727 }
\DoxyCodeLine{00728         xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE\_QUEUE\_ITEM\_LENGTH, queueQUEUE\_TYPE\_COUNTING\_SEMAPHORE );}
\DoxyCodeLine{00729 }
\DoxyCodeLine{00730         \textcolor{keywordflow}{if}( xHandle != NULL )}
\DoxyCodeLine{00731         \{}
\DoxyCodeLine{00732             ( ( Queue\_t * ) xHandle )-\/>uxMessagesWaiting = uxInitialCount;}
\DoxyCodeLine{00733 }
\DoxyCodeLine{00734             traceCREATE\_COUNTING\_SEMAPHORE();}
\DoxyCodeLine{00735         \}}
\DoxyCodeLine{00736         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00737         \{}
\DoxyCodeLine{00738             traceCREATE\_COUNTING\_SEMAPHORE\_FAILED();}
\DoxyCodeLine{00739         \}}
\DoxyCodeLine{00740 }
\DoxyCodeLine{00741         \textcolor{keywordflow}{return} xHandle;}
\DoxyCodeLine{00742     \}}
\DoxyCodeLine{00743 }
\DoxyCodeLine{00744 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( configUSE\_COUNTING\_SEMAPHORES == 1 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00745 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00746 }
\DoxyCodeLine{00747 BaseType\_t xQueueGenericSend( QueueHandle\_t xQueue, \textcolor{keyword}{const} \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvItemToQueue, TickType\_t xTicksToWait, \textcolor{keyword}{const} BaseType\_t xCopyPosition )}
\DoxyCodeLine{00748 \{}
\DoxyCodeLine{00749 BaseType\_t xEntryTimeSet = pdFALSE, xYieldRequired;}
\DoxyCodeLine{00750 TimeOut\_t xTimeOut;}
\DoxyCodeLine{00751 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{00752 }
\DoxyCodeLine{00753     configASSERT( pxQueue );}
\DoxyCodeLine{00754     configASSERT( !( ( pvItemToQueue == NULL ) \&\& ( pxQueue-\/>uxItemSize != ( UBaseType\_t ) 0U ) ) );}
\DoxyCodeLine{00755     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) \&\& ( pxQueue-\/>uxLength != 1 ) ) );}
\DoxyCodeLine{00756 \textcolor{preprocessor}{    \#if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}}
\DoxyCodeLine{00757     \{}
\DoxyCodeLine{00758         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER\_SUSPENDED ) \&\& ( xTicksToWait != 0 ) ) );}
\DoxyCodeLine{00759     \}}
\DoxyCodeLine{00760 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00761 }
\DoxyCodeLine{00762 }
\DoxyCodeLine{00763     \textcolor{comment}{/*lint -\/save -\/e904 This function relaxes the coding standard somewhat to}}
\DoxyCodeLine{00764 \textcolor{comment}{    allow return statements within the function itself.  This is done in the}}
\DoxyCodeLine{00765 \textcolor{comment}{    interest of execution time efficiency. */}}
\DoxyCodeLine{00766     \textcolor{keywordflow}{for}( ;; )}
\DoxyCodeLine{00767     \{}
\DoxyCodeLine{00768         taskENTER\_CRITICAL();}
\DoxyCodeLine{00769         \{}
\DoxyCodeLine{00770             \textcolor{comment}{/* Is there room on the queue now?  The running task must be the}}
\DoxyCodeLine{00771 \textcolor{comment}{            highest priority task wanting to access the queue.  If the head item}}
\DoxyCodeLine{00772 \textcolor{comment}{            in the queue is to be overwritten then it does not matter if the}}
\DoxyCodeLine{00773 \textcolor{comment}{            queue is full. */}}
\DoxyCodeLine{00774             \textcolor{keywordflow}{if}( ( pxQueue-\/>uxMessagesWaiting < pxQueue-\/>uxLength ) || ( xCopyPosition == queueOVERWRITE ) )}
\DoxyCodeLine{00775             \{}
\DoxyCodeLine{00776                 traceQUEUE\_SEND( pxQueue );}
\DoxyCodeLine{00777 }
\DoxyCodeLine{00778 \textcolor{preprocessor}{                \#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{00779                 \{}
\DoxyCodeLine{00780                 UBaseType\_t uxPreviousMessagesWaiting = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{00781 }
\DoxyCodeLine{00782                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );}
\DoxyCodeLine{00783 }
\DoxyCodeLine{00784                     \textcolor{keywordflow}{if}( pxQueue-\/>pxQueueSetContainer != NULL )}
\DoxyCodeLine{00785                     \{}
\DoxyCodeLine{00786                         \textcolor{keywordflow}{if}( ( xCopyPosition == queueOVERWRITE ) \&\& ( uxPreviousMessagesWaiting != ( UBaseType\_t ) 0 ) )}
\DoxyCodeLine{00787                         \{}
\DoxyCodeLine{00788                             \textcolor{comment}{/* Do not notify the queue set as an existing item}}
\DoxyCodeLine{00789 \textcolor{comment}{                            was overwritten in the queue so the number of items}}
\DoxyCodeLine{00790 \textcolor{comment}{                            in the queue has not changed. */}}
\DoxyCodeLine{00791                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00792                         \}}
\DoxyCodeLine{00793                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )}
\DoxyCodeLine{00794                         \{}
\DoxyCodeLine{00795                             \textcolor{comment}{/* The queue is a member of a queue set, and posting}}
\DoxyCodeLine{00796 \textcolor{comment}{                            to the queue set caused a higher priority task to}}
\DoxyCodeLine{00797 \textcolor{comment}{                            unblock. A context switch is required. */}}
\DoxyCodeLine{00798                             queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{00799                         \}}
\DoxyCodeLine{00800                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00801                         \{}
\DoxyCodeLine{00802                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00803                         \}}
\DoxyCodeLine{00804                     \}}
\DoxyCodeLine{00805                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00806                     \{}
\DoxyCodeLine{00807                         \textcolor{comment}{/* If there was a task waiting for data to arrive on the}}
\DoxyCodeLine{00808 \textcolor{comment}{                        queue then unblock it now. */}}
\DoxyCodeLine{00809                         \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{00810                         \{}
\DoxyCodeLine{00811                             \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{00812                             \{}
\DoxyCodeLine{00813                                 \textcolor{comment}{/* The unblocked task has a priority higher than}}
\DoxyCodeLine{00814 \textcolor{comment}{                                our own so yield immediately.  Yes it is ok to}}
\DoxyCodeLine{00815 \textcolor{comment}{                                do this from within the critical section -\/ the}}
\DoxyCodeLine{00816 \textcolor{comment}{                                kernel takes care of that. */}}
\DoxyCodeLine{00817                                 queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{00818                             \}}
\DoxyCodeLine{00819                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00820                             \{}
\DoxyCodeLine{00821                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00822                             \}}
\DoxyCodeLine{00823                         \}}
\DoxyCodeLine{00824                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xYieldRequired != pdFALSE )}
\DoxyCodeLine{00825                         \{}
\DoxyCodeLine{00826                             \textcolor{comment}{/* This path is a special case that will only get}}
\DoxyCodeLine{00827 \textcolor{comment}{                            executed if the task was holding multiple mutexes}}
\DoxyCodeLine{00828 \textcolor{comment}{                            and the mutexes were given back in an order that is}}
\DoxyCodeLine{00829 \textcolor{comment}{                            different to that in which they were taken. */}}
\DoxyCodeLine{00830                             queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{00831                         \}}
\DoxyCodeLine{00832                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00833                         \{}
\DoxyCodeLine{00834                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00835                         \}}
\DoxyCodeLine{00836                     \}}
\DoxyCodeLine{00837                 \}}
\DoxyCodeLine{00838 \textcolor{preprocessor}{                \#else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00839                 \{}
\DoxyCodeLine{00840                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );}
\DoxyCodeLine{00841 }
\DoxyCodeLine{00842                     \textcolor{comment}{/* If there was a task waiting for data to arrive on the}}
\DoxyCodeLine{00843 \textcolor{comment}{                    queue then unblock it now. */}}
\DoxyCodeLine{00844                     \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{00845                     \{}
\DoxyCodeLine{00846                         \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{00847                         \{}
\DoxyCodeLine{00848                             \textcolor{comment}{/* The unblocked task has a priority higher than}}
\DoxyCodeLine{00849 \textcolor{comment}{                            our own so yield immediately.  Yes it is ok to do}}
\DoxyCodeLine{00850 \textcolor{comment}{                            this from within the critical section -\/ the kernel}}
\DoxyCodeLine{00851 \textcolor{comment}{                            takes care of that. */}}
\DoxyCodeLine{00852                             queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{00853                         \}}
\DoxyCodeLine{00854                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00855                         \{}
\DoxyCodeLine{00856                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00857                         \}}
\DoxyCodeLine{00858                     \}}
\DoxyCodeLine{00859                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xYieldRequired != pdFALSE )}
\DoxyCodeLine{00860                     \{}
\DoxyCodeLine{00861                         \textcolor{comment}{/* This path is a special case that will only get}}
\DoxyCodeLine{00862 \textcolor{comment}{                        executed if the task was holding multiple mutexes and}}
\DoxyCodeLine{00863 \textcolor{comment}{                        the mutexes were given back in an order that is}}
\DoxyCodeLine{00864 \textcolor{comment}{                        different to that in which they were taken. */}}
\DoxyCodeLine{00865                         queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{00866                     \}}
\DoxyCodeLine{00867                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00868                     \{}
\DoxyCodeLine{00869                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00870                     \}}
\DoxyCodeLine{00871                 \}}
\DoxyCodeLine{00872 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00873 }
\DoxyCodeLine{00874                 taskEXIT\_CRITICAL();}
\DoxyCodeLine{00875                 \textcolor{keywordflow}{return} pdPASS;}
\DoxyCodeLine{00876             \}}
\DoxyCodeLine{00877             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00878             \{}
\DoxyCodeLine{00879                 \textcolor{keywordflow}{if}( xTicksToWait == ( TickType\_t ) 0 )}
\DoxyCodeLine{00880                 \{}
\DoxyCodeLine{00881                     \textcolor{comment}{/* The queue was full and no block time is specified (or}}
\DoxyCodeLine{00882 \textcolor{comment}{                    the block time has expired) so leave now. */}}
\DoxyCodeLine{00883                     taskEXIT\_CRITICAL();}
\DoxyCodeLine{00884 }
\DoxyCodeLine{00885                     \textcolor{comment}{/* Return to the original privilege level before exiting}}
\DoxyCodeLine{00886 \textcolor{comment}{                    the function. */}}
\DoxyCodeLine{00887                     traceQUEUE\_SEND\_FAILED( pxQueue );}
\DoxyCodeLine{00888                     \textcolor{keywordflow}{return} errQUEUE\_FULL;}
\DoxyCodeLine{00889                 \}}
\DoxyCodeLine{00890                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == pdFALSE )}
\DoxyCodeLine{00891                 \{}
\DoxyCodeLine{00892                     \textcolor{comment}{/* The queue was full and a block time was specified so}}
\DoxyCodeLine{00893 \textcolor{comment}{                    configure the timeout structure. */}}
\DoxyCodeLine{00894                     vTaskInternalSetTimeOutState( \&xTimeOut );}
\DoxyCodeLine{00895                     xEntryTimeSet = pdTRUE;}
\DoxyCodeLine{00896                 \}}
\DoxyCodeLine{00897                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{00898                 \{}
\DoxyCodeLine{00899                     \textcolor{comment}{/* Entry time was already set. */}}
\DoxyCodeLine{00900                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00901                 \}}
\DoxyCodeLine{00902             \}}
\DoxyCodeLine{00903         \}}
\DoxyCodeLine{00904         taskEXIT\_CRITICAL();}
\DoxyCodeLine{00905 }
\DoxyCodeLine{00906         \textcolor{comment}{/* Interrupts and other tasks can send to and receive from the queue}}
\DoxyCodeLine{00907 \textcolor{comment}{        now the critical section has been exited. */}}
\DoxyCodeLine{00908 }
\DoxyCodeLine{00909         vTaskSuspendAll();}
\DoxyCodeLine{00910         prvLockQueue( pxQueue );}
\DoxyCodeLine{00911 }
\DoxyCodeLine{00912         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}}
\DoxyCodeLine{00913         \textcolor{keywordflow}{if}( xTaskCheckForTimeOut( \&xTimeOut, \&xTicksToWait ) == pdFALSE )}
\DoxyCodeLine{00914         \{}
\DoxyCodeLine{00915             \textcolor{keywordflow}{if}( prvIsQueueFull( pxQueue ) != pdFALSE )}
\DoxyCodeLine{00916             \{}
\DoxyCodeLine{00917                 traceBLOCKING\_ON\_QUEUE\_SEND( pxQueue );}
\DoxyCodeLine{00918                 vTaskPlaceOnEventList( \&( pxQueue-\/>xTasksWaitingToSend ), xTicksToWait );}
\DoxyCodeLine{00919 }
\DoxyCodeLine{00920                 \textcolor{comment}{/* Unlocking the queue means queue events can effect the}}
\DoxyCodeLine{00921 \textcolor{comment}{                event list.  It is possible that interrupts occurring now}}
\DoxyCodeLine{00922 \textcolor{comment}{                remove this task from the event list again -\/ but as the}}
\DoxyCodeLine{00923 \textcolor{comment}{                scheduler is suspended the task will go onto the pending}}
\DoxyCodeLine{00924 \textcolor{comment}{                ready last instead of the actual ready list. */}}
\DoxyCodeLine{00925                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{00926 }
\DoxyCodeLine{00927                 \textcolor{comment}{/* Resuming the scheduler will move tasks from the pending}}
\DoxyCodeLine{00928 \textcolor{comment}{                ready list into the ready list -\/ so it is feasible that this}}
\DoxyCodeLine{00929 \textcolor{comment}{                task is already in a ready list before it yields -\/ in which}}
\DoxyCodeLine{00930 \textcolor{comment}{                case the yield will not cause a context switch unless there}}
\DoxyCodeLine{00931 \textcolor{comment}{                is also a higher priority task in the pending ready list. */}}
\DoxyCodeLine{00932                 \textcolor{keywordflow}{if}( xTaskResumeAll() == pdFALSE )}
\DoxyCodeLine{00933                 \{}
\DoxyCodeLine{00934                     portYIELD\_WITHIN\_API();}
\DoxyCodeLine{00935                 \}}
\DoxyCodeLine{00936             \}}
\DoxyCodeLine{00937             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00938             \{}
\DoxyCodeLine{00939                 \textcolor{comment}{/* Try again. */}}
\DoxyCodeLine{00940                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{00941                 ( void ) xTaskResumeAll();}
\DoxyCodeLine{00942             \}}
\DoxyCodeLine{00943         \}}
\DoxyCodeLine{00944         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00945         \{}
\DoxyCodeLine{00946             \textcolor{comment}{/* The timeout has expired. */}}
\DoxyCodeLine{00947             prvUnlockQueue( pxQueue );}
\DoxyCodeLine{00948             ( void ) xTaskResumeAll();}
\DoxyCodeLine{00949 }
\DoxyCodeLine{00950             traceQUEUE\_SEND\_FAILED( pxQueue );}
\DoxyCodeLine{00951             \textcolor{keywordflow}{return} errQUEUE\_FULL;}
\DoxyCodeLine{00952         \}}
\DoxyCodeLine{00953     \} \textcolor{comment}{/*lint -\/restore */}}
\DoxyCodeLine{00954 \}}
\DoxyCodeLine{00955 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00956 }
\DoxyCodeLine{00957 BaseType\_t xQueueGenericSendFromISR( QueueHandle\_t xQueue, \textcolor{keyword}{const} \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvItemToQueue, BaseType\_t * \textcolor{keyword}{const} pxHigherPriorityTaskWoken, \textcolor{keyword}{const} BaseType\_t xCopyPosition )}
\DoxyCodeLine{00958 \{}
\DoxyCodeLine{00959 BaseType\_t xReturn;}
\DoxyCodeLine{00960 UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{00961 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{00962 }
\DoxyCodeLine{00963     configASSERT( pxQueue );}
\DoxyCodeLine{00964     configASSERT( !( ( pvItemToQueue == NULL ) \&\& ( pxQueue-\/>uxItemSize != ( UBaseType\_t ) 0U ) ) );}
\DoxyCodeLine{00965     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) \&\& ( pxQueue-\/>uxLength != 1 ) ) );}
\DoxyCodeLine{00966 }
\DoxyCodeLine{00967     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}}
\DoxyCodeLine{00968 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}}
\DoxyCodeLine{00969 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}}
\DoxyCodeLine{00970 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}}
\DoxyCodeLine{00971 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}}
\DoxyCodeLine{00972 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{00973 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}}
\DoxyCodeLine{00974 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}}
\DoxyCodeLine{00975 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}}
\DoxyCodeLine{00976 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}}
\DoxyCodeLine{00977 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}}
\DoxyCodeLine{00978 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}}
\DoxyCodeLine{00979 \textcolor{comment}{    More information (albeit Cortex-\/M specific) is provided on the following}}
\DoxyCodeLine{00980 \textcolor{comment}{    link: http://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{00981     portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{00982 }
\DoxyCodeLine{00983     \textcolor{comment}{/* Similar to xQueueGenericSend, except without blocking if there is no room}}
\DoxyCodeLine{00984 \textcolor{comment}{    in the queue.  Also don't directly wake a task that was blocked on a queue}}
\DoxyCodeLine{00985 \textcolor{comment}{    read, instead return a flag to say whether a context switch is required or}}
\DoxyCodeLine{00986 \textcolor{comment}{    not (i.e. has a task with a higher priority than us been woken by this}}
\DoxyCodeLine{00987 \textcolor{comment}{    post). */}}
\DoxyCodeLine{00988     uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{00989     \{}
\DoxyCodeLine{00990         \textcolor{keywordflow}{if}( ( pxQueue-\/>uxMessagesWaiting < pxQueue-\/>uxLength ) || ( xCopyPosition == queueOVERWRITE ) )}
\DoxyCodeLine{00991         \{}
\DoxyCodeLine{00992             \textcolor{keyword}{const} int8\_t cTxLock = pxQueue-\/>cTxLock;}
\DoxyCodeLine{00993 }
\DoxyCodeLine{00994             traceQUEUE\_SEND\_FROM\_ISR( pxQueue );}
\DoxyCodeLine{00995 }
\DoxyCodeLine{00996             \textcolor{comment}{/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a}}
\DoxyCodeLine{00997 \textcolor{comment}{            semaphore or mutex.  That means prvCopyDataToQueue() cannot result}}
\DoxyCodeLine{00998 \textcolor{comment}{            in a task disinheriting a priority and prvCopyDataToQueue() can be}}
\DoxyCodeLine{00999 \textcolor{comment}{            called here even though the disinherit function does not check if}}
\DoxyCodeLine{01000 \textcolor{comment}{            the scheduler is suspended before accessing the ready lists. */}}
\DoxyCodeLine{01001             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );}
\DoxyCodeLine{01002 }
\DoxyCodeLine{01003             \textcolor{comment}{/* The event list is not altered if the queue is locked.  This will}}
\DoxyCodeLine{01004 \textcolor{comment}{            be done when the queue is unlocked later. */}}
\DoxyCodeLine{01005             \textcolor{keywordflow}{if}( cTxLock == queueUNLOCKED )}
\DoxyCodeLine{01006             \{}
\DoxyCodeLine{01007 \textcolor{preprocessor}{                \#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{01008                 \{}
\DoxyCodeLine{01009                     \textcolor{keywordflow}{if}( pxQueue-\/>pxQueueSetContainer != NULL )}
\DoxyCodeLine{01010                     \{}
\DoxyCodeLine{01011                         \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )}
\DoxyCodeLine{01012                         \{}
\DoxyCodeLine{01013                             \textcolor{comment}{/* The queue is a member of a queue set, and posting}}
\DoxyCodeLine{01014 \textcolor{comment}{                            to the queue set caused a higher priority task to}}
\DoxyCodeLine{01015 \textcolor{comment}{                            unblock.  A context switch is required. */}}
\DoxyCodeLine{01016                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{01017                             \{}
\DoxyCodeLine{01018                                 *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{01019                             \}}
\DoxyCodeLine{01020                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01021                             \{}
\DoxyCodeLine{01022                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01023                             \}}
\DoxyCodeLine{01024                         \}}
\DoxyCodeLine{01025                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01026                         \{}
\DoxyCodeLine{01027                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01028                         \}}
\DoxyCodeLine{01029                     \}}
\DoxyCodeLine{01030                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01031                     \{}
\DoxyCodeLine{01032                         \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{01033                         \{}
\DoxyCodeLine{01034                             \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{01035                             \{}
\DoxyCodeLine{01036                                 \textcolor{comment}{/* The task waiting has a higher priority so}}
\DoxyCodeLine{01037 \textcolor{comment}{                                record that a context switch is required. */}}
\DoxyCodeLine{01038                                 \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{01039                                 \{}
\DoxyCodeLine{01040                                     *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{01041                                 \}}
\DoxyCodeLine{01042                                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01043                                 \{}
\DoxyCodeLine{01044                                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01045                                 \}}
\DoxyCodeLine{01046                             \}}
\DoxyCodeLine{01047                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01048                             \{}
\DoxyCodeLine{01049                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01050                             \}}
\DoxyCodeLine{01051                         \}}
\DoxyCodeLine{01052                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01053                         \{}
\DoxyCodeLine{01054                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01055                         \}}
\DoxyCodeLine{01056                     \}}
\DoxyCodeLine{01057                 \}}
\DoxyCodeLine{01058 \textcolor{preprocessor}{                \#else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01059                 \{}
\DoxyCodeLine{01060                     \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{01061                     \{}
\DoxyCodeLine{01062                         \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{01063                         \{}
\DoxyCodeLine{01064                             \textcolor{comment}{/* The task waiting has a higher priority so record that a}}
\DoxyCodeLine{01065 \textcolor{comment}{                            context switch is required. */}}
\DoxyCodeLine{01066                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{01067                             \{}
\DoxyCodeLine{01068                                 *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{01069                             \}}
\DoxyCodeLine{01070                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01071                             \{}
\DoxyCodeLine{01072                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01073                             \}}
\DoxyCodeLine{01074                         \}}
\DoxyCodeLine{01075                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01076                         \{}
\DoxyCodeLine{01077                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01078                         \}}
\DoxyCodeLine{01079                     \}}
\DoxyCodeLine{01080                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01081                     \{}
\DoxyCodeLine{01082                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01083                     \}}
\DoxyCodeLine{01084                 \}}
\DoxyCodeLine{01085 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01086             \}}
\DoxyCodeLine{01087             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01088             \{}
\DoxyCodeLine{01089                 \textcolor{comment}{/* Increment the lock count so the task that unlocks the queue}}
\DoxyCodeLine{01090 \textcolor{comment}{                knows that data was posted while it was locked. */}}
\DoxyCodeLine{01091                 pxQueue-\/>cTxLock = ( int8\_t ) ( cTxLock + 1 );}
\DoxyCodeLine{01092             \}}
\DoxyCodeLine{01093 }
\DoxyCodeLine{01094             xReturn = pdPASS;}
\DoxyCodeLine{01095         \}}
\DoxyCodeLine{01096         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01097         \{}
\DoxyCodeLine{01098             traceQUEUE\_SEND\_FROM\_ISR\_FAILED( pxQueue );}
\DoxyCodeLine{01099             xReturn = errQUEUE\_FULL;}
\DoxyCodeLine{01100         \}}
\DoxyCodeLine{01101     \}}
\DoxyCodeLine{01102     portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{01103 }
\DoxyCodeLine{01104     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{01105 \}}
\DoxyCodeLine{01106 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01107 }
\DoxyCodeLine{01108 BaseType\_t xQueueGiveFromISR( QueueHandle\_t xQueue, BaseType\_t * \textcolor{keyword}{const} pxHigherPriorityTaskWoken )}
\DoxyCodeLine{01109 \{}
\DoxyCodeLine{01110 BaseType\_t xReturn;}
\DoxyCodeLine{01111 UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{01112 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01113 }
\DoxyCodeLine{01114     \textcolor{comment}{/* Similar to xQueueGenericSendFromISR() but used with semaphores where the}}
\DoxyCodeLine{01115 \textcolor{comment}{    item size is 0.  Don't directly wake a task that was blocked on a queue}}
\DoxyCodeLine{01116 \textcolor{comment}{    read, instead return a flag to say whether a context switch is required or}}
\DoxyCodeLine{01117 \textcolor{comment}{    not (i.e. has a task with a higher priority than us been woken by this}}
\DoxyCodeLine{01118 \textcolor{comment}{    post). */}}
\DoxyCodeLine{01119 }
\DoxyCodeLine{01120     configASSERT( pxQueue );}
\DoxyCodeLine{01121 }
\DoxyCodeLine{01122     \textcolor{comment}{/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()}}
\DoxyCodeLine{01123 \textcolor{comment}{    if the item size is not 0. */}}
\DoxyCodeLine{01124     configASSERT( pxQueue-\/>uxItemSize == 0 );}
\DoxyCodeLine{01125 }
\DoxyCodeLine{01126     \textcolor{comment}{/* Normally a mutex would not be given from an interrupt, especially if}}
\DoxyCodeLine{01127 \textcolor{comment}{    there is a mutex holder, as priority inheritance makes no sense for an}}
\DoxyCodeLine{01128 \textcolor{comment}{    interrupts, only tasks. */}}
\DoxyCodeLine{01129     configASSERT( !( ( pxQueue-\/>uxQueueType == queueQUEUE\_IS\_MUTEX ) \&\& ( pxQueue-\/>u.xSemaphore.xMutexHolder != NULL ) ) );}
\DoxyCodeLine{01130 }
\DoxyCodeLine{01131     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}}
\DoxyCodeLine{01132 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}}
\DoxyCodeLine{01133 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}}
\DoxyCodeLine{01134 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}}
\DoxyCodeLine{01135 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}}
\DoxyCodeLine{01136 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{01137 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}}
\DoxyCodeLine{01138 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}}
\DoxyCodeLine{01139 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}}
\DoxyCodeLine{01140 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}}
\DoxyCodeLine{01141 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}}
\DoxyCodeLine{01142 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}}
\DoxyCodeLine{01143 \textcolor{comment}{    More information (albeit Cortex-\/M specific) is provided on the following}}
\DoxyCodeLine{01144 \textcolor{comment}{    link: http://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{01145     portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{01146 }
\DoxyCodeLine{01147     uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{01148     \{}
\DoxyCodeLine{01149         \textcolor{keyword}{const} UBaseType\_t uxMessagesWaiting = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{01150 }
\DoxyCodeLine{01151         \textcolor{comment}{/* When the queue is used to implement a semaphore no data is ever}}
\DoxyCodeLine{01152 \textcolor{comment}{        moved through the queue but it is still valid to see if the queue 'has}}
\DoxyCodeLine{01153 \textcolor{comment}{        space'. */}}
\DoxyCodeLine{01154         \textcolor{keywordflow}{if}( uxMessagesWaiting < pxQueue-\/>uxLength )}
\DoxyCodeLine{01155         \{}
\DoxyCodeLine{01156             \textcolor{keyword}{const} int8\_t cTxLock = pxQueue-\/>cTxLock;}
\DoxyCodeLine{01157 }
\DoxyCodeLine{01158             traceQUEUE\_SEND\_FROM\_ISR( pxQueue );}
\DoxyCodeLine{01159 }
\DoxyCodeLine{01160             \textcolor{comment}{/* A task can only have an inherited priority if it is a mutex}}
\DoxyCodeLine{01161 \textcolor{comment}{            holder -\/ and if there is a mutex holder then the mutex cannot be}}
\DoxyCodeLine{01162 \textcolor{comment}{            given from an ISR.  As this is the ISR version of the function it}}
\DoxyCodeLine{01163 \textcolor{comment}{            can be assumed there is no mutex holder and no need to determine if}}
\DoxyCodeLine{01164 \textcolor{comment}{            priority disinheritance is needed.  Simply increase the count of}}
\DoxyCodeLine{01165 \textcolor{comment}{            messages (semaphores) available. */}}
\DoxyCodeLine{01166             pxQueue-\/>uxMessagesWaiting = uxMessagesWaiting + ( UBaseType\_t ) 1;}
\DoxyCodeLine{01167 }
\DoxyCodeLine{01168             \textcolor{comment}{/* The event list is not altered if the queue is locked.  This will}}
\DoxyCodeLine{01169 \textcolor{comment}{            be done when the queue is unlocked later. */}}
\DoxyCodeLine{01170             \textcolor{keywordflow}{if}( cTxLock == queueUNLOCKED )}
\DoxyCodeLine{01171             \{}
\DoxyCodeLine{01172 \textcolor{preprocessor}{                \#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{01173                 \{}
\DoxyCodeLine{01174                     \textcolor{keywordflow}{if}( pxQueue-\/>pxQueueSetContainer != NULL )}
\DoxyCodeLine{01175                     \{}
\DoxyCodeLine{01176                         \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, queueSEND\_TO\_BACK ) != pdFALSE )}
\DoxyCodeLine{01177                         \{}
\DoxyCodeLine{01178                             \textcolor{comment}{/* The semaphore is a member of a queue set, and}}
\DoxyCodeLine{01179 \textcolor{comment}{                            posting to the queue set caused a higher priority}}
\DoxyCodeLine{01180 \textcolor{comment}{                            task to unblock.  A context switch is required. */}}
\DoxyCodeLine{01181                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{01182                             \{}
\DoxyCodeLine{01183                                 *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{01184                             \}}
\DoxyCodeLine{01185                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01186                             \{}
\DoxyCodeLine{01187                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01188                             \}}
\DoxyCodeLine{01189                         \}}
\DoxyCodeLine{01190                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01191                         \{}
\DoxyCodeLine{01192                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01193                         \}}
\DoxyCodeLine{01194                     \}}
\DoxyCodeLine{01195                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01196                     \{}
\DoxyCodeLine{01197                         \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{01198                         \{}
\DoxyCodeLine{01199                             \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{01200                             \{}
\DoxyCodeLine{01201                                 \textcolor{comment}{/* The task waiting has a higher priority so}}
\DoxyCodeLine{01202 \textcolor{comment}{                                record that a context switch is required. */}}
\DoxyCodeLine{01203                                 \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{01204                                 \{}
\DoxyCodeLine{01205                                     *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{01206                                 \}}
\DoxyCodeLine{01207                                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01208                                 \{}
\DoxyCodeLine{01209                                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01210                                 \}}
\DoxyCodeLine{01211                             \}}
\DoxyCodeLine{01212                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01213                             \{}
\DoxyCodeLine{01214                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01215                             \}}
\DoxyCodeLine{01216                         \}}
\DoxyCodeLine{01217                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01218                         \{}
\DoxyCodeLine{01219                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01220                         \}}
\DoxyCodeLine{01221                     \}}
\DoxyCodeLine{01222                 \}}
\DoxyCodeLine{01223 \textcolor{preprocessor}{                \#else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01224                 \{}
\DoxyCodeLine{01225                     \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{01226                     \{}
\DoxyCodeLine{01227                         \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{01228                         \{}
\DoxyCodeLine{01229                             \textcolor{comment}{/* The task waiting has a higher priority so record that a}}
\DoxyCodeLine{01230 \textcolor{comment}{                            context switch is required. */}}
\DoxyCodeLine{01231                             \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{01232                             \{}
\DoxyCodeLine{01233                                 *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{01234                             \}}
\DoxyCodeLine{01235                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01236                             \{}
\DoxyCodeLine{01237                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01238                             \}}
\DoxyCodeLine{01239                         \}}
\DoxyCodeLine{01240                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01241                         \{}
\DoxyCodeLine{01242                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01243                         \}}
\DoxyCodeLine{01244                     \}}
\DoxyCodeLine{01245                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01246                     \{}
\DoxyCodeLine{01247                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01248                     \}}
\DoxyCodeLine{01249                 \}}
\DoxyCodeLine{01250 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01251             \}}
\DoxyCodeLine{01252             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01253             \{}
\DoxyCodeLine{01254                 \textcolor{comment}{/* Increment the lock count so the task that unlocks the queue}}
\DoxyCodeLine{01255 \textcolor{comment}{                knows that data was posted while it was locked. */}}
\DoxyCodeLine{01256                 pxQueue-\/>cTxLock = ( int8\_t ) ( cTxLock + 1 );}
\DoxyCodeLine{01257             \}}
\DoxyCodeLine{01258 }
\DoxyCodeLine{01259             xReturn = pdPASS;}
\DoxyCodeLine{01260         \}}
\DoxyCodeLine{01261         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01262         \{}
\DoxyCodeLine{01263             traceQUEUE\_SEND\_FROM\_ISR\_FAILED( pxQueue );}
\DoxyCodeLine{01264             xReturn = errQUEUE\_FULL;}
\DoxyCodeLine{01265         \}}
\DoxyCodeLine{01266     \}}
\DoxyCodeLine{01267     portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{01268 }
\DoxyCodeLine{01269     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{01270 \}}
\DoxyCodeLine{01271 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01272 }
\DoxyCodeLine{01273 BaseType\_t xQueueReceive( QueueHandle\_t xQueue, \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer, TickType\_t xTicksToWait )}
\DoxyCodeLine{01274 \{}
\DoxyCodeLine{01275 BaseType\_t xEntryTimeSet = pdFALSE;}
\DoxyCodeLine{01276 TimeOut\_t xTimeOut;}
\DoxyCodeLine{01277 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01278 }
\DoxyCodeLine{01279     \textcolor{comment}{/* Check the pointer is not NULL. */}}
\DoxyCodeLine{01280     configASSERT( ( pxQueue ) );}
\DoxyCodeLine{01281 }
\DoxyCodeLine{01282     \textcolor{comment}{/* The buffer into which data is received can only be NULL if the data size}}
\DoxyCodeLine{01283 \textcolor{comment}{    is zero (so no data is copied into the buffer. */}}
\DoxyCodeLine{01284     configASSERT( !( ( ( pvBuffer ) == NULL ) \&\& ( ( pxQueue )-\/>uxItemSize != ( UBaseType\_t ) 0U ) ) );}
\DoxyCodeLine{01285 }
\DoxyCodeLine{01286     \textcolor{comment}{/* Cannot block if the scheduler is suspended. */}}
\DoxyCodeLine{01287 \textcolor{preprocessor}{    \#if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}}
\DoxyCodeLine{01288     \{}
\DoxyCodeLine{01289         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER\_SUSPENDED ) \&\& ( xTicksToWait != 0 ) ) );}
\DoxyCodeLine{01290     \}}
\DoxyCodeLine{01291 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{01292 }
\DoxyCodeLine{01293 }
\DoxyCodeLine{01294     \textcolor{comment}{/*lint -\/save -\/e904  This function relaxes the coding standard somewhat to}}
\DoxyCodeLine{01295 \textcolor{comment}{    allow return statements within the function itself.  This is done in the}}
\DoxyCodeLine{01296 \textcolor{comment}{    interest of execution time efficiency. */}}
\DoxyCodeLine{01297     \textcolor{keywordflow}{for}( ;; )}
\DoxyCodeLine{01298     \{}
\DoxyCodeLine{01299         taskENTER\_CRITICAL();}
\DoxyCodeLine{01300         \{}
\DoxyCodeLine{01301             \textcolor{keyword}{const} UBaseType\_t uxMessagesWaiting = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{01302 }
\DoxyCodeLine{01303             \textcolor{comment}{/* Is there data in the queue now?  To be running the calling task}}
\DoxyCodeLine{01304 \textcolor{comment}{            must be the highest priority task wanting to access the queue. */}}
\DoxyCodeLine{01305             \textcolor{keywordflow}{if}( uxMessagesWaiting > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01306             \{}
\DoxyCodeLine{01307                 \textcolor{comment}{/* Data available, remove one item. */}}
\DoxyCodeLine{01308                 prvCopyDataFromQueue( pxQueue, pvBuffer );}
\DoxyCodeLine{01309                 traceQUEUE\_RECEIVE( pxQueue );}
\DoxyCodeLine{01310                 pxQueue-\/>uxMessagesWaiting = uxMessagesWaiting -\/ ( UBaseType\_t ) 1;}
\DoxyCodeLine{01311 }
\DoxyCodeLine{01312                 \textcolor{comment}{/* There is now space in the queue, were any tasks waiting to}}
\DoxyCodeLine{01313 \textcolor{comment}{                post to the queue?  If so, unblock the highest priority waiting}}
\DoxyCodeLine{01314 \textcolor{comment}{                task. */}}
\DoxyCodeLine{01315                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToSend ) ) == pdFALSE )}
\DoxyCodeLine{01316                 \{}
\DoxyCodeLine{01317                     \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToSend ) ) != pdFALSE )}
\DoxyCodeLine{01318                     \{}
\DoxyCodeLine{01319                         queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{01320                     \}}
\DoxyCodeLine{01321                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01322                     \{}
\DoxyCodeLine{01323                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01324                     \}}
\DoxyCodeLine{01325                 \}}
\DoxyCodeLine{01326                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01327                 \{}
\DoxyCodeLine{01328                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01329                 \}}
\DoxyCodeLine{01330 }
\DoxyCodeLine{01331                 taskEXIT\_CRITICAL();}
\DoxyCodeLine{01332                 \textcolor{keywordflow}{return} pdPASS;}
\DoxyCodeLine{01333             \}}
\DoxyCodeLine{01334             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01335             \{}
\DoxyCodeLine{01336                 \textcolor{keywordflow}{if}( xTicksToWait == ( TickType\_t ) 0 )}
\DoxyCodeLine{01337                 \{}
\DoxyCodeLine{01338                     \textcolor{comment}{/* The queue was empty and no block time is specified (or}}
\DoxyCodeLine{01339 \textcolor{comment}{                    the block time has expired) so leave now. */}}
\DoxyCodeLine{01340                     taskEXIT\_CRITICAL();}
\DoxyCodeLine{01341                     traceQUEUE\_RECEIVE\_FAILED( pxQueue );}
\DoxyCodeLine{01342                     \textcolor{keywordflow}{return} errQUEUE\_EMPTY;}
\DoxyCodeLine{01343                 \}}
\DoxyCodeLine{01344                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == pdFALSE )}
\DoxyCodeLine{01345                 \{}
\DoxyCodeLine{01346                     \textcolor{comment}{/* The queue was empty and a block time was specified so}}
\DoxyCodeLine{01347 \textcolor{comment}{                    configure the timeout structure. */}}
\DoxyCodeLine{01348                     vTaskInternalSetTimeOutState( \&xTimeOut );}
\DoxyCodeLine{01349                     xEntryTimeSet = pdTRUE;}
\DoxyCodeLine{01350                 \}}
\DoxyCodeLine{01351                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01352                 \{}
\DoxyCodeLine{01353                     \textcolor{comment}{/* Entry time was already set. */}}
\DoxyCodeLine{01354                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01355                 \}}
\DoxyCodeLine{01356             \}}
\DoxyCodeLine{01357         \}}
\DoxyCodeLine{01358         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01359 }
\DoxyCodeLine{01360         \textcolor{comment}{/* Interrupts and other tasks can send to and receive from the queue}}
\DoxyCodeLine{01361 \textcolor{comment}{        now the critical section has been exited. */}}
\DoxyCodeLine{01362 }
\DoxyCodeLine{01363         vTaskSuspendAll();}
\DoxyCodeLine{01364         prvLockQueue( pxQueue );}
\DoxyCodeLine{01365 }
\DoxyCodeLine{01366         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}}
\DoxyCodeLine{01367         \textcolor{keywordflow}{if}( xTaskCheckForTimeOut( \&xTimeOut, \&xTicksToWait ) == pdFALSE )}
\DoxyCodeLine{01368         \{}
\DoxyCodeLine{01369             \textcolor{comment}{/* The timeout has not expired.  If the queue is still empty place}}
\DoxyCodeLine{01370 \textcolor{comment}{            the task on the list of tasks waiting to receive from the queue. */}}
\DoxyCodeLine{01371             \textcolor{keywordflow}{if}( prvIsQueueEmpty( pxQueue ) != pdFALSE )}
\DoxyCodeLine{01372             \{}
\DoxyCodeLine{01373                 traceBLOCKING\_ON\_QUEUE\_RECEIVE( pxQueue );}
\DoxyCodeLine{01374                 vTaskPlaceOnEventList( \&( pxQueue-\/>xTasksWaitingToReceive ), xTicksToWait );}
\DoxyCodeLine{01375                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01376                 \textcolor{keywordflow}{if}( xTaskResumeAll() == pdFALSE )}
\DoxyCodeLine{01377                 \{}
\DoxyCodeLine{01378                     portYIELD\_WITHIN\_API();}
\DoxyCodeLine{01379                 \}}
\DoxyCodeLine{01380                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01381                 \{}
\DoxyCodeLine{01382                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01383                 \}}
\DoxyCodeLine{01384             \}}
\DoxyCodeLine{01385             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01386             \{}
\DoxyCodeLine{01387                 \textcolor{comment}{/* The queue contains data again.  Loop back to try and read the}}
\DoxyCodeLine{01388 \textcolor{comment}{                data. */}}
\DoxyCodeLine{01389                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01390                 ( void ) xTaskResumeAll();}
\DoxyCodeLine{01391             \}}
\DoxyCodeLine{01392         \}}
\DoxyCodeLine{01393         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01394         \{}
\DoxyCodeLine{01395             \textcolor{comment}{/* Timed out.  If there is no data in the queue exit, otherwise loop}}
\DoxyCodeLine{01396 \textcolor{comment}{            back and attempt to read the data. */}}
\DoxyCodeLine{01397             prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01398             ( void ) xTaskResumeAll();}
\DoxyCodeLine{01399 }
\DoxyCodeLine{01400             \textcolor{keywordflow}{if}( prvIsQueueEmpty( pxQueue ) != pdFALSE )}
\DoxyCodeLine{01401             \{}
\DoxyCodeLine{01402                 traceQUEUE\_RECEIVE\_FAILED( pxQueue );}
\DoxyCodeLine{01403                 \textcolor{keywordflow}{return} errQUEUE\_EMPTY;}
\DoxyCodeLine{01404             \}}
\DoxyCodeLine{01405             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01406             \{}
\DoxyCodeLine{01407                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01408             \}}
\DoxyCodeLine{01409         \}}
\DoxyCodeLine{01410     \} \textcolor{comment}{/*lint -\/restore */}}
\DoxyCodeLine{01411 \}}
\DoxyCodeLine{01412 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01413 }
\DoxyCodeLine{01414 BaseType\_t xQueueSemaphoreTake( QueueHandle\_t xQueue, TickType\_t xTicksToWait )}
\DoxyCodeLine{01415 \{}
\DoxyCodeLine{01416 BaseType\_t xEntryTimeSet = pdFALSE;}
\DoxyCodeLine{01417 TimeOut\_t xTimeOut;}
\DoxyCodeLine{01418 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01419 }
\DoxyCodeLine{01420 \textcolor{preprocessor}{\#if( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{01421     BaseType\_t xInheritanceOccurred = pdFALSE;}
\DoxyCodeLine{01422 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01423 }
\DoxyCodeLine{01424     \textcolor{comment}{/* Check the queue pointer is not NULL. */}}
\DoxyCodeLine{01425     configASSERT( ( pxQueue ) );}
\DoxyCodeLine{01426 }
\DoxyCodeLine{01427     \textcolor{comment}{/* Check this really is a semaphore, in which case the item size will be}}
\DoxyCodeLine{01428 \textcolor{comment}{    0. */}}
\DoxyCodeLine{01429     configASSERT( pxQueue-\/>uxItemSize == 0 );}
\DoxyCodeLine{01430 }
\DoxyCodeLine{01431     \textcolor{comment}{/* Cannot block if the scheduler is suspended. */}}
\DoxyCodeLine{01432 \textcolor{preprocessor}{    \#if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}}
\DoxyCodeLine{01433     \{}
\DoxyCodeLine{01434         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER\_SUSPENDED ) \&\& ( xTicksToWait != 0 ) ) );}
\DoxyCodeLine{01435     \}}
\DoxyCodeLine{01436 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{01437 }
\DoxyCodeLine{01438 }
\DoxyCodeLine{01439     \textcolor{comment}{/*lint -\/save -\/e904 This function relaxes the coding standard somewhat to allow return}}
\DoxyCodeLine{01440 \textcolor{comment}{    statements within the function itself.  This is done in the interest}}
\DoxyCodeLine{01441 \textcolor{comment}{    of execution time efficiency. */}}
\DoxyCodeLine{01442     \textcolor{keywordflow}{for}( ;; )}
\DoxyCodeLine{01443     \{}
\DoxyCodeLine{01444         taskENTER\_CRITICAL();}
\DoxyCodeLine{01445         \{}
\DoxyCodeLine{01446             \textcolor{comment}{/* Semaphores are queues with an item size of 0, and where the}}
\DoxyCodeLine{01447 \textcolor{comment}{            number of messages in the queue is the semaphore's count value. */}}
\DoxyCodeLine{01448             \textcolor{keyword}{const} UBaseType\_t uxSemaphoreCount = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{01449 }
\DoxyCodeLine{01450             \textcolor{comment}{/* Is there data in the queue now?  To be running the calling task}}
\DoxyCodeLine{01451 \textcolor{comment}{            must be the highest priority task wanting to access the queue. */}}
\DoxyCodeLine{01452             \textcolor{keywordflow}{if}( uxSemaphoreCount > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01453             \{}
\DoxyCodeLine{01454                 traceQUEUE\_RECEIVE( pxQueue );}
\DoxyCodeLine{01455 }
\DoxyCodeLine{01456                 \textcolor{comment}{/* Semaphores are queues with a data size of zero and where the}}
\DoxyCodeLine{01457 \textcolor{comment}{                messages waiting is the semaphore's count.  Reduce the count. */}}
\DoxyCodeLine{01458                 pxQueue-\/>uxMessagesWaiting = uxSemaphoreCount -\/ ( UBaseType\_t ) 1;}
\DoxyCodeLine{01459 }
\DoxyCodeLine{01460 \textcolor{preprocessor}{                \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{01461                 \{}
\DoxyCodeLine{01462                     \textcolor{keywordflow}{if}( pxQueue-\/>uxQueueType == queueQUEUE\_IS\_MUTEX )}
\DoxyCodeLine{01463                     \{}
\DoxyCodeLine{01464                         \textcolor{comment}{/* Record the information required to implement}}
\DoxyCodeLine{01465 \textcolor{comment}{                        priority inheritance should it become necessary. */}}
\DoxyCodeLine{01466                         pxQueue-\/>u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();}
\DoxyCodeLine{01467                     \}}
\DoxyCodeLine{01468                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01469                     \{}
\DoxyCodeLine{01470                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01471                     \}}
\DoxyCodeLine{01472                 \}}
\DoxyCodeLine{01473 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01474 }
\DoxyCodeLine{01475                 \textcolor{comment}{/* Check to see if other tasks are blocked waiting to give the}}
\DoxyCodeLine{01476 \textcolor{comment}{                semaphore, and if so, unblock the highest priority such task. */}}
\DoxyCodeLine{01477                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToSend ) ) == pdFALSE )}
\DoxyCodeLine{01478                 \{}
\DoxyCodeLine{01479                     \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToSend ) ) != pdFALSE )}
\DoxyCodeLine{01480                     \{}
\DoxyCodeLine{01481                         queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{01482                     \}}
\DoxyCodeLine{01483                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01484                     \{}
\DoxyCodeLine{01485                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01486                     \}}
\DoxyCodeLine{01487                 \}}
\DoxyCodeLine{01488                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01489                 \{}
\DoxyCodeLine{01490                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01491                 \}}
\DoxyCodeLine{01492 }
\DoxyCodeLine{01493                 taskEXIT\_CRITICAL();}
\DoxyCodeLine{01494                 \textcolor{keywordflow}{return} pdPASS;}
\DoxyCodeLine{01495             \}}
\DoxyCodeLine{01496             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01497             \{}
\DoxyCodeLine{01498                 \textcolor{keywordflow}{if}( xTicksToWait == ( TickType\_t ) 0 )}
\DoxyCodeLine{01499                 \{}
\DoxyCodeLine{01500                     \textcolor{comment}{/* For inheritance to have occurred there must have been an}}
\DoxyCodeLine{01501 \textcolor{comment}{                    initial timeout, and an adjusted timeout cannot become 0, as}}
\DoxyCodeLine{01502 \textcolor{comment}{                    if it were 0 the function would have exited. */}}
\DoxyCodeLine{01503 \textcolor{preprocessor}{                    \#if( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{01504                     \{}
\DoxyCodeLine{01505                         configASSERT( xInheritanceOccurred == pdFALSE );}
\DoxyCodeLine{01506                     \}}
\DoxyCodeLine{01507 \textcolor{preprocessor}{                    \#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01508 }
\DoxyCodeLine{01509                     \textcolor{comment}{/* The semaphore count was 0 and no block time is specified}}
\DoxyCodeLine{01510 \textcolor{comment}{                    (or the block time has expired) so exit now. */}}
\DoxyCodeLine{01511                     taskEXIT\_CRITICAL();}
\DoxyCodeLine{01512                     traceQUEUE\_RECEIVE\_FAILED( pxQueue );}
\DoxyCodeLine{01513                     \textcolor{keywordflow}{return} errQUEUE\_EMPTY;}
\DoxyCodeLine{01514                 \}}
\DoxyCodeLine{01515                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == pdFALSE )}
\DoxyCodeLine{01516                 \{}
\DoxyCodeLine{01517                     \textcolor{comment}{/* The semaphore count was 0 and a block time was specified}}
\DoxyCodeLine{01518 \textcolor{comment}{                    so configure the timeout structure ready to block. */}}
\DoxyCodeLine{01519                     vTaskInternalSetTimeOutState( \&xTimeOut );}
\DoxyCodeLine{01520                     xEntryTimeSet = pdTRUE;}
\DoxyCodeLine{01521                 \}}
\DoxyCodeLine{01522                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01523                 \{}
\DoxyCodeLine{01524                     \textcolor{comment}{/* Entry time was already set. */}}
\DoxyCodeLine{01525                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01526                 \}}
\DoxyCodeLine{01527             \}}
\DoxyCodeLine{01528         \}}
\DoxyCodeLine{01529         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01530 }
\DoxyCodeLine{01531         \textcolor{comment}{/* Interrupts and other tasks can give to and take from the semaphore}}
\DoxyCodeLine{01532 \textcolor{comment}{        now the critical section has been exited. */}}
\DoxyCodeLine{01533 }
\DoxyCodeLine{01534         vTaskSuspendAll();}
\DoxyCodeLine{01535         prvLockQueue( pxQueue );}
\DoxyCodeLine{01536 }
\DoxyCodeLine{01537         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}}
\DoxyCodeLine{01538         \textcolor{keywordflow}{if}( xTaskCheckForTimeOut( \&xTimeOut, \&xTicksToWait ) == pdFALSE )}
\DoxyCodeLine{01539         \{}
\DoxyCodeLine{01540             \textcolor{comment}{/* A block time is specified and not expired.  If the semaphore}}
\DoxyCodeLine{01541 \textcolor{comment}{            count is 0 then enter the Blocked state to wait for a semaphore to}}
\DoxyCodeLine{01542 \textcolor{comment}{            become available.  As semaphores are implemented with queues the}}
\DoxyCodeLine{01543 \textcolor{comment}{            queue being empty is equivalent to the semaphore count being 0. */}}
\DoxyCodeLine{01544             \textcolor{keywordflow}{if}( prvIsQueueEmpty( pxQueue ) != pdFALSE )}
\DoxyCodeLine{01545             \{}
\DoxyCodeLine{01546                 traceBLOCKING\_ON\_QUEUE\_RECEIVE( pxQueue );}
\DoxyCodeLine{01547 }
\DoxyCodeLine{01548 \textcolor{preprocessor}{                \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{01549                 \{}
\DoxyCodeLine{01550                     \textcolor{keywordflow}{if}( pxQueue-\/>uxQueueType == queueQUEUE\_IS\_MUTEX )}
\DoxyCodeLine{01551                     \{}
\DoxyCodeLine{01552                         taskENTER\_CRITICAL();}
\DoxyCodeLine{01553                         \{}
\DoxyCodeLine{01554                             xInheritanceOccurred = xTaskPriorityInherit( pxQueue-\/>u.xSemaphore.xMutexHolder );}
\DoxyCodeLine{01555                         \}}
\DoxyCodeLine{01556                         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01557                     \}}
\DoxyCodeLine{01558                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01559                     \{}
\DoxyCodeLine{01560                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01561                     \}}
\DoxyCodeLine{01562                 \}}
\DoxyCodeLine{01563 \textcolor{preprocessor}{                \#endif}}
\DoxyCodeLine{01564 }
\DoxyCodeLine{01565                 vTaskPlaceOnEventList( \&( pxQueue-\/>xTasksWaitingToReceive ), xTicksToWait );}
\DoxyCodeLine{01566                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01567                 \textcolor{keywordflow}{if}( xTaskResumeAll() == pdFALSE )}
\DoxyCodeLine{01568                 \{}
\DoxyCodeLine{01569                     portYIELD\_WITHIN\_API();}
\DoxyCodeLine{01570                 \}}
\DoxyCodeLine{01571                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01572                 \{}
\DoxyCodeLine{01573                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01574                 \}}
\DoxyCodeLine{01575             \}}
\DoxyCodeLine{01576             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01577             \{}
\DoxyCodeLine{01578                 \textcolor{comment}{/* There was no timeout and the semaphore count was not 0, so}}
\DoxyCodeLine{01579 \textcolor{comment}{                attempt to take the semaphore again. */}}
\DoxyCodeLine{01580                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01581                 ( void ) xTaskResumeAll();}
\DoxyCodeLine{01582             \}}
\DoxyCodeLine{01583         \}}
\DoxyCodeLine{01584         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01585         \{}
\DoxyCodeLine{01586             \textcolor{comment}{/* Timed out. */}}
\DoxyCodeLine{01587             prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01588             ( void ) xTaskResumeAll();}
\DoxyCodeLine{01589 }
\DoxyCodeLine{01590             \textcolor{comment}{/* If the semaphore count is 0 exit now as the timeout has}}
\DoxyCodeLine{01591 \textcolor{comment}{            expired.  Otherwise return to attempt to take the semaphore that is}}
\DoxyCodeLine{01592 \textcolor{comment}{            known to be available.  As semaphores are implemented by queues the}}
\DoxyCodeLine{01593 \textcolor{comment}{            queue being empty is equivalent to the semaphore count being 0. */}}
\DoxyCodeLine{01594             \textcolor{keywordflow}{if}( prvIsQueueEmpty( pxQueue ) != pdFALSE )}
\DoxyCodeLine{01595             \{}
\DoxyCodeLine{01596 \textcolor{preprocessor}{                \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{01597                 \{}
\DoxyCodeLine{01598                     \textcolor{comment}{/* xInheritanceOccurred could only have be set if}}
\DoxyCodeLine{01599 \textcolor{comment}{                    pxQueue-\/>uxQueueType == queueQUEUE\_IS\_MUTEX so no need to}}
\DoxyCodeLine{01600 \textcolor{comment}{                    test the mutex type again to check it is actually a mutex. */}}
\DoxyCodeLine{01601                     \textcolor{keywordflow}{if}( xInheritanceOccurred != pdFALSE )}
\DoxyCodeLine{01602                     \{}
\DoxyCodeLine{01603                         taskENTER\_CRITICAL();}
\DoxyCodeLine{01604                         \{}
\DoxyCodeLine{01605                             UBaseType\_t uxHighestWaitingPriority;}
\DoxyCodeLine{01606 }
\DoxyCodeLine{01607                             \textcolor{comment}{/* This task blocking on the mutex caused another}}
\DoxyCodeLine{01608 \textcolor{comment}{                            task to inherit this task's priority.  Now this task}}
\DoxyCodeLine{01609 \textcolor{comment}{                            has timed out the priority should be disinherited}}
\DoxyCodeLine{01610 \textcolor{comment}{                            again, but only as low as the next highest priority}}
\DoxyCodeLine{01611 \textcolor{comment}{                            task that is waiting for the same mutex. */}}
\DoxyCodeLine{01612                             uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );}
\DoxyCodeLine{01613                             vTaskPriorityDisinheritAfterTimeout( pxQueue-\/>u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );}
\DoxyCodeLine{01614                         \}}
\DoxyCodeLine{01615                         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01616                     \}}
\DoxyCodeLine{01617                 \}}
\DoxyCodeLine{01618 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01619 }
\DoxyCodeLine{01620                 traceQUEUE\_RECEIVE\_FAILED( pxQueue );}
\DoxyCodeLine{01621                 \textcolor{keywordflow}{return} errQUEUE\_EMPTY;}
\DoxyCodeLine{01622             \}}
\DoxyCodeLine{01623             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01624             \{}
\DoxyCodeLine{01625                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01626             \}}
\DoxyCodeLine{01627         \}}
\DoxyCodeLine{01628     \} \textcolor{comment}{/*lint -\/restore */}}
\DoxyCodeLine{01629 \}}
\DoxyCodeLine{01630 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01631 }
\DoxyCodeLine{01632 BaseType\_t xQueuePeek( QueueHandle\_t xQueue, \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer, TickType\_t xTicksToWait )}
\DoxyCodeLine{01633 \{}
\DoxyCodeLine{01634 BaseType\_t xEntryTimeSet = pdFALSE;}
\DoxyCodeLine{01635 TimeOut\_t xTimeOut;}
\DoxyCodeLine{01636 int8\_t *pcOriginalReadPosition;}
\DoxyCodeLine{01637 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01638 }
\DoxyCodeLine{01639     \textcolor{comment}{/* Check the pointer is not NULL. */}}
\DoxyCodeLine{01640     configASSERT( ( pxQueue ) );}
\DoxyCodeLine{01641 }
\DoxyCodeLine{01642     \textcolor{comment}{/* The buffer into which data is received can only be NULL if the data size}}
\DoxyCodeLine{01643 \textcolor{comment}{    is zero (so no data is copied into the buffer. */}}
\DoxyCodeLine{01644     configASSERT( !( ( ( pvBuffer ) == NULL ) \&\& ( ( pxQueue )-\/>uxItemSize != ( UBaseType\_t ) 0U ) ) );}
\DoxyCodeLine{01645 }
\DoxyCodeLine{01646     \textcolor{comment}{/* Cannot block if the scheduler is suspended. */}}
\DoxyCodeLine{01647 \textcolor{preprocessor}{    \#if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}}
\DoxyCodeLine{01648     \{}
\DoxyCodeLine{01649         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER\_SUSPENDED ) \&\& ( xTicksToWait != 0 ) ) );}
\DoxyCodeLine{01650     \}}
\DoxyCodeLine{01651 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{01652 }
\DoxyCodeLine{01653 }
\DoxyCodeLine{01654     \textcolor{comment}{/*lint -\/save -\/e904  This function relaxes the coding standard somewhat to}}
\DoxyCodeLine{01655 \textcolor{comment}{    allow return statements within the function itself.  This is done in the}}
\DoxyCodeLine{01656 \textcolor{comment}{    interest of execution time efficiency. */}}
\DoxyCodeLine{01657     \textcolor{keywordflow}{for}( ;; )}
\DoxyCodeLine{01658     \{}
\DoxyCodeLine{01659         taskENTER\_CRITICAL();}
\DoxyCodeLine{01660         \{}
\DoxyCodeLine{01661             \textcolor{keyword}{const} UBaseType\_t uxMessagesWaiting = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{01662 }
\DoxyCodeLine{01663             \textcolor{comment}{/* Is there data in the queue now?  To be running the calling task}}
\DoxyCodeLine{01664 \textcolor{comment}{            must be the highest priority task wanting to access the queue. */}}
\DoxyCodeLine{01665             \textcolor{keywordflow}{if}( uxMessagesWaiting > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01666             \{}
\DoxyCodeLine{01667                 \textcolor{comment}{/* Remember the read position so it can be reset after the data}}
\DoxyCodeLine{01668 \textcolor{comment}{                is read from the queue as this function is only peeking the}}
\DoxyCodeLine{01669 \textcolor{comment}{                data, not removing it. */}}
\DoxyCodeLine{01670                 pcOriginalReadPosition = pxQueue-\/>u.xQueue.pcReadFrom;}
\DoxyCodeLine{01671 }
\DoxyCodeLine{01672                 prvCopyDataFromQueue( pxQueue, pvBuffer );}
\DoxyCodeLine{01673                 traceQUEUE\_PEEK( pxQueue );}
\DoxyCodeLine{01674 }
\DoxyCodeLine{01675                 \textcolor{comment}{/* The data is not being removed, so reset the read pointer. */}}
\DoxyCodeLine{01676                 pxQueue-\/>u.xQueue.pcReadFrom = pcOriginalReadPosition;}
\DoxyCodeLine{01677 }
\DoxyCodeLine{01678                 \textcolor{comment}{/* The data is being left in the queue, so see if there are}}
\DoxyCodeLine{01679 \textcolor{comment}{                any other tasks waiting for the data. */}}
\DoxyCodeLine{01680                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{01681                 \{}
\DoxyCodeLine{01682                     \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{01683                     \{}
\DoxyCodeLine{01684                         \textcolor{comment}{/* The task waiting has a higher priority than this task. */}}
\DoxyCodeLine{01685                         queueYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{01686                     \}}
\DoxyCodeLine{01687                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01688                     \{}
\DoxyCodeLine{01689                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01690                     \}}
\DoxyCodeLine{01691                 \}}
\DoxyCodeLine{01692                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01693                 \{}
\DoxyCodeLine{01694                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01695                 \}}
\DoxyCodeLine{01696 }
\DoxyCodeLine{01697                 taskEXIT\_CRITICAL();}
\DoxyCodeLine{01698                 \textcolor{keywordflow}{return} pdPASS;}
\DoxyCodeLine{01699             \}}
\DoxyCodeLine{01700             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01701             \{}
\DoxyCodeLine{01702                 \textcolor{keywordflow}{if}( xTicksToWait == ( TickType\_t ) 0 )}
\DoxyCodeLine{01703                 \{}
\DoxyCodeLine{01704                     \textcolor{comment}{/* The queue was empty and no block time is specified (or}}
\DoxyCodeLine{01705 \textcolor{comment}{                    the block time has expired) so leave now. */}}
\DoxyCodeLine{01706                     taskEXIT\_CRITICAL();}
\DoxyCodeLine{01707                     traceQUEUE\_PEEK\_FAILED( pxQueue );}
\DoxyCodeLine{01708                     \textcolor{keywordflow}{return} errQUEUE\_EMPTY;}
\DoxyCodeLine{01709                 \}}
\DoxyCodeLine{01710                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xEntryTimeSet == pdFALSE )}
\DoxyCodeLine{01711                 \{}
\DoxyCodeLine{01712                     \textcolor{comment}{/* The queue was empty and a block time was specified so}}
\DoxyCodeLine{01713 \textcolor{comment}{                    configure the timeout structure ready to enter the blocked}}
\DoxyCodeLine{01714 \textcolor{comment}{                    state. */}}
\DoxyCodeLine{01715                     vTaskInternalSetTimeOutState( \&xTimeOut );}
\DoxyCodeLine{01716                     xEntryTimeSet = pdTRUE;}
\DoxyCodeLine{01717                 \}}
\DoxyCodeLine{01718                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01719                 \{}
\DoxyCodeLine{01720                     \textcolor{comment}{/* Entry time was already set. */}}
\DoxyCodeLine{01721                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01722                 \}}
\DoxyCodeLine{01723             \}}
\DoxyCodeLine{01724         \}}
\DoxyCodeLine{01725         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01726 }
\DoxyCodeLine{01727         \textcolor{comment}{/* Interrupts and other tasks can send to and receive from the queue}}
\DoxyCodeLine{01728 \textcolor{comment}{        now the critical section has been exited. */}}
\DoxyCodeLine{01729 }
\DoxyCodeLine{01730         vTaskSuspendAll();}
\DoxyCodeLine{01731         prvLockQueue( pxQueue );}
\DoxyCodeLine{01732 }
\DoxyCodeLine{01733         \textcolor{comment}{/* Update the timeout state to see if it has expired yet. */}}
\DoxyCodeLine{01734         \textcolor{keywordflow}{if}( xTaskCheckForTimeOut( \&xTimeOut, \&xTicksToWait ) == pdFALSE )}
\DoxyCodeLine{01735         \{}
\DoxyCodeLine{01736             \textcolor{comment}{/* Timeout has not expired yet, check to see if there is data in the}}
\DoxyCodeLine{01737 \textcolor{comment}{            queue now, and if not enter the Blocked state to wait for data. */}}
\DoxyCodeLine{01738             \textcolor{keywordflow}{if}( prvIsQueueEmpty( pxQueue ) != pdFALSE )}
\DoxyCodeLine{01739             \{}
\DoxyCodeLine{01740                 traceBLOCKING\_ON\_QUEUE\_PEEK( pxQueue );}
\DoxyCodeLine{01741                 vTaskPlaceOnEventList( \&( pxQueue-\/>xTasksWaitingToReceive ), xTicksToWait );}
\DoxyCodeLine{01742                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01743                 \textcolor{keywordflow}{if}( xTaskResumeAll() == pdFALSE )}
\DoxyCodeLine{01744                 \{}
\DoxyCodeLine{01745                     portYIELD\_WITHIN\_API();}
\DoxyCodeLine{01746                 \}}
\DoxyCodeLine{01747                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01748                 \{}
\DoxyCodeLine{01749                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01750                 \}}
\DoxyCodeLine{01751             \}}
\DoxyCodeLine{01752             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01753             \{}
\DoxyCodeLine{01754                 \textcolor{comment}{/* There is data in the queue now, so don't enter the blocked}}
\DoxyCodeLine{01755 \textcolor{comment}{                state, instead return to try and obtain the data. */}}
\DoxyCodeLine{01756                 prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01757                 ( void ) xTaskResumeAll();}
\DoxyCodeLine{01758             \}}
\DoxyCodeLine{01759         \}}
\DoxyCodeLine{01760         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01761         \{}
\DoxyCodeLine{01762             \textcolor{comment}{/* The timeout has expired.  If there is still no data in the queue}}
\DoxyCodeLine{01763 \textcolor{comment}{            exit, otherwise go back and try to read the data again. */}}
\DoxyCodeLine{01764             prvUnlockQueue( pxQueue );}
\DoxyCodeLine{01765             ( void ) xTaskResumeAll();}
\DoxyCodeLine{01766 }
\DoxyCodeLine{01767             \textcolor{keywordflow}{if}( prvIsQueueEmpty( pxQueue ) != pdFALSE )}
\DoxyCodeLine{01768             \{}
\DoxyCodeLine{01769                 traceQUEUE\_PEEK\_FAILED( pxQueue );}
\DoxyCodeLine{01770                 \textcolor{keywordflow}{return} errQUEUE\_EMPTY;}
\DoxyCodeLine{01771             \}}
\DoxyCodeLine{01772             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01773             \{}
\DoxyCodeLine{01774                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01775             \}}
\DoxyCodeLine{01776         \}}
\DoxyCodeLine{01777     \} \textcolor{comment}{/*lint -\/restore */}}
\DoxyCodeLine{01778 \}}
\DoxyCodeLine{01779 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01780 }
\DoxyCodeLine{01781 BaseType\_t xQueueReceiveFromISR( QueueHandle\_t xQueue, \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer, BaseType\_t * \textcolor{keyword}{const} pxHigherPriorityTaskWoken )}
\DoxyCodeLine{01782 \{}
\DoxyCodeLine{01783 BaseType\_t xReturn;}
\DoxyCodeLine{01784 UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{01785 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01786 }
\DoxyCodeLine{01787     configASSERT( pxQueue );}
\DoxyCodeLine{01788     configASSERT( !( ( pvBuffer == NULL ) \&\& ( pxQueue-\/>uxItemSize != ( UBaseType\_t ) 0U ) ) );}
\DoxyCodeLine{01789 }
\DoxyCodeLine{01790     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}}
\DoxyCodeLine{01791 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}}
\DoxyCodeLine{01792 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}}
\DoxyCodeLine{01793 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}}
\DoxyCodeLine{01794 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}}
\DoxyCodeLine{01795 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{01796 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}}
\DoxyCodeLine{01797 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}}
\DoxyCodeLine{01798 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}}
\DoxyCodeLine{01799 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}}
\DoxyCodeLine{01800 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}}
\DoxyCodeLine{01801 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}}
\DoxyCodeLine{01802 \textcolor{comment}{    More information (albeit Cortex-\/M specific) is provided on the following}}
\DoxyCodeLine{01803 \textcolor{comment}{    link: http://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{01804     portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{01805 }
\DoxyCodeLine{01806     uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{01807     \{}
\DoxyCodeLine{01808         \textcolor{keyword}{const} UBaseType\_t uxMessagesWaiting = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{01809 }
\DoxyCodeLine{01810         \textcolor{comment}{/* Cannot block in an ISR, so check there is data available. */}}
\DoxyCodeLine{01811         \textcolor{keywordflow}{if}( uxMessagesWaiting > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01812         \{}
\DoxyCodeLine{01813             \textcolor{keyword}{const} int8\_t cRxLock = pxQueue-\/>cRxLock;}
\DoxyCodeLine{01814 }
\DoxyCodeLine{01815             traceQUEUE\_RECEIVE\_FROM\_ISR( pxQueue );}
\DoxyCodeLine{01816 }
\DoxyCodeLine{01817             prvCopyDataFromQueue( pxQueue, pvBuffer );}
\DoxyCodeLine{01818             pxQueue-\/>uxMessagesWaiting = uxMessagesWaiting -\/ ( UBaseType\_t ) 1;}
\DoxyCodeLine{01819 }
\DoxyCodeLine{01820             \textcolor{comment}{/* If the queue is locked the event list will not be modified.}}
\DoxyCodeLine{01821 \textcolor{comment}{            Instead update the lock count so the task that unlocks the queue}}
\DoxyCodeLine{01822 \textcolor{comment}{            will know that an ISR has removed data while the queue was}}
\DoxyCodeLine{01823 \textcolor{comment}{            locked. */}}
\DoxyCodeLine{01824             \textcolor{keywordflow}{if}( cRxLock == queueUNLOCKED )}
\DoxyCodeLine{01825             \{}
\DoxyCodeLine{01826                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToSend ) ) == pdFALSE )}
\DoxyCodeLine{01827                 \{}
\DoxyCodeLine{01828                     \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToSend ) ) != pdFALSE )}
\DoxyCodeLine{01829                     \{}
\DoxyCodeLine{01830                         \textcolor{comment}{/* The task waiting has a higher priority than us so}}
\DoxyCodeLine{01831 \textcolor{comment}{                        force a context switch. */}}
\DoxyCodeLine{01832                         \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{01833                         \{}
\DoxyCodeLine{01834                             *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{01835                         \}}
\DoxyCodeLine{01836                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01837                         \{}
\DoxyCodeLine{01838                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01839                         \}}
\DoxyCodeLine{01840                     \}}
\DoxyCodeLine{01841                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01842                     \{}
\DoxyCodeLine{01843                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01844                     \}}
\DoxyCodeLine{01845                 \}}
\DoxyCodeLine{01846                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01847                 \{}
\DoxyCodeLine{01848                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01849                 \}}
\DoxyCodeLine{01850             \}}
\DoxyCodeLine{01851             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01852             \{}
\DoxyCodeLine{01853                 \textcolor{comment}{/* Increment the lock count so the task that unlocks the queue}}
\DoxyCodeLine{01854 \textcolor{comment}{                knows that data was removed while it was locked. */}}
\DoxyCodeLine{01855                 pxQueue-\/>cRxLock = ( int8\_t ) ( cRxLock + 1 );}
\DoxyCodeLine{01856             \}}
\DoxyCodeLine{01857 }
\DoxyCodeLine{01858             xReturn = pdPASS;}
\DoxyCodeLine{01859         \}}
\DoxyCodeLine{01860         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01861         \{}
\DoxyCodeLine{01862             xReturn = pdFAIL;}
\DoxyCodeLine{01863             traceQUEUE\_RECEIVE\_FROM\_ISR\_FAILED( pxQueue );}
\DoxyCodeLine{01864         \}}
\DoxyCodeLine{01865     \}}
\DoxyCodeLine{01866     portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{01867 }
\DoxyCodeLine{01868     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{01869 \}}
\DoxyCodeLine{01870 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01871 }
\DoxyCodeLine{01872 BaseType\_t xQueuePeekFromISR( QueueHandle\_t xQueue,  \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer )}
\DoxyCodeLine{01873 \{}
\DoxyCodeLine{01874 BaseType\_t xReturn;}
\DoxyCodeLine{01875 UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{01876 int8\_t *pcOriginalReadPosition;}
\DoxyCodeLine{01877 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01878 }
\DoxyCodeLine{01879     configASSERT( pxQueue );}
\DoxyCodeLine{01880     configASSERT( !( ( pvBuffer == NULL ) \&\& ( pxQueue-\/>uxItemSize != ( UBaseType\_t ) 0U ) ) );}
\DoxyCodeLine{01881     configASSERT( pxQueue-\/>uxItemSize != 0 ); \textcolor{comment}{/* Can't peek a semaphore. */}}
\DoxyCodeLine{01882 }
\DoxyCodeLine{01883     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}}
\DoxyCodeLine{01884 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}}
\DoxyCodeLine{01885 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}}
\DoxyCodeLine{01886 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}}
\DoxyCodeLine{01887 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}}
\DoxyCodeLine{01888 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{01889 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}}
\DoxyCodeLine{01890 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}}
\DoxyCodeLine{01891 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}}
\DoxyCodeLine{01892 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}}
\DoxyCodeLine{01893 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}}
\DoxyCodeLine{01894 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}}
\DoxyCodeLine{01895 \textcolor{comment}{    More information (albeit Cortex-\/M specific) is provided on the following}}
\DoxyCodeLine{01896 \textcolor{comment}{    link: http://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{01897     portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{01898 }
\DoxyCodeLine{01899     uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{01900     \{}
\DoxyCodeLine{01901         \textcolor{comment}{/* Cannot block in an ISR, so check there is data available. */}}
\DoxyCodeLine{01902         \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01903         \{}
\DoxyCodeLine{01904             traceQUEUE\_PEEK\_FROM\_ISR( pxQueue );}
\DoxyCodeLine{01905 }
\DoxyCodeLine{01906             \textcolor{comment}{/* Remember the read position so it can be reset as nothing is}}
\DoxyCodeLine{01907 \textcolor{comment}{            actually being removed from the queue. */}}
\DoxyCodeLine{01908             pcOriginalReadPosition = pxQueue-\/>u.xQueue.pcReadFrom;}
\DoxyCodeLine{01909             prvCopyDataFromQueue( pxQueue, pvBuffer );}
\DoxyCodeLine{01910             pxQueue-\/>u.xQueue.pcReadFrom = pcOriginalReadPosition;}
\DoxyCodeLine{01911 }
\DoxyCodeLine{01912             xReturn = pdPASS;}
\DoxyCodeLine{01913         \}}
\DoxyCodeLine{01914         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01915         \{}
\DoxyCodeLine{01916             xReturn = pdFAIL;}
\DoxyCodeLine{01917             traceQUEUE\_PEEK\_FROM\_ISR\_FAILED( pxQueue );}
\DoxyCodeLine{01918         \}}
\DoxyCodeLine{01919     \}}
\DoxyCodeLine{01920     portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{01921 }
\DoxyCodeLine{01922     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{01923 \}}
\DoxyCodeLine{01924 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01925 }
\DoxyCodeLine{01926 UBaseType\_t uxQueueMessagesWaiting( \textcolor{keyword}{const} QueueHandle\_t xQueue )}
\DoxyCodeLine{01927 \{}
\DoxyCodeLine{01928 UBaseType\_t uxReturn;}
\DoxyCodeLine{01929 }
\DoxyCodeLine{01930     configASSERT( xQueue );}
\DoxyCodeLine{01931 }
\DoxyCodeLine{01932     taskENTER\_CRITICAL();}
\DoxyCodeLine{01933     \{}
\DoxyCodeLine{01934         uxReturn = ( ( Queue\_t * ) xQueue )-\/>uxMessagesWaiting;}
\DoxyCodeLine{01935     \}}
\DoxyCodeLine{01936     taskEXIT\_CRITICAL();}
\DoxyCodeLine{01937 }
\DoxyCodeLine{01938     \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{01939 \} \textcolor{comment}{/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */}}
\DoxyCodeLine{01940 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01941 }
\DoxyCodeLine{01942 UBaseType\_t uxQueueSpacesAvailable( \textcolor{keyword}{const} QueueHandle\_t xQueue )}
\DoxyCodeLine{01943 \{}
\DoxyCodeLine{01944 UBaseType\_t uxReturn;}
\DoxyCodeLine{01945 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01946 }
\DoxyCodeLine{01947     configASSERT( pxQueue );}
\DoxyCodeLine{01948 }
\DoxyCodeLine{01949     taskENTER\_CRITICAL();}
\DoxyCodeLine{01950     \{}
\DoxyCodeLine{01951         uxReturn = pxQueue-\/>uxLength -\/ pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{01952     \}}
\DoxyCodeLine{01953     taskEXIT\_CRITICAL();}
\DoxyCodeLine{01954 }
\DoxyCodeLine{01955     \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{01956 \} \textcolor{comment}{/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */}}
\DoxyCodeLine{01957 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01958 }
\DoxyCodeLine{01959 UBaseType\_t uxQueueMessagesWaitingFromISR( \textcolor{keyword}{const} QueueHandle\_t xQueue )}
\DoxyCodeLine{01960 \{}
\DoxyCodeLine{01961 UBaseType\_t uxReturn;}
\DoxyCodeLine{01962 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01963 }
\DoxyCodeLine{01964     configASSERT( pxQueue );}
\DoxyCodeLine{01965     uxReturn = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{01966 }
\DoxyCodeLine{01967     \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{01968 \} \textcolor{comment}{/*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */}}
\DoxyCodeLine{01969 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01970 }
\DoxyCodeLine{01971 \textcolor{keywordtype}{void} vQueueDelete( QueueHandle\_t xQueue )}
\DoxyCodeLine{01972 \{}
\DoxyCodeLine{01973 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{01974 }
\DoxyCodeLine{01975     configASSERT( pxQueue );}
\DoxyCodeLine{01976     traceQUEUE\_DELETE( pxQueue );}
\DoxyCodeLine{01977 }
\DoxyCodeLine{01978 \textcolor{preprocessor}{    \#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{01979     \{}
\DoxyCodeLine{01980         vQueueUnregisterQueue( pxQueue );}
\DoxyCodeLine{01981     \}}
\DoxyCodeLine{01982 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{01983 }
\DoxyCodeLine{01984 \textcolor{preprocessor}{    \#if( ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 0 ) )}}
\DoxyCodeLine{01985     \{}
\DoxyCodeLine{01986         \textcolor{comment}{/* The queue can only have been allocated dynamically -\/ free it}}
\DoxyCodeLine{01987 \textcolor{comment}{        again. */}}
\DoxyCodeLine{01988         vPortFree( pxQueue );}
\DoxyCodeLine{01989     \}}
\DoxyCodeLine{01990 \textcolor{preprocessor}{    \#elif( ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{01991     \{}
\DoxyCodeLine{01992         \textcolor{comment}{/* The queue could have been allocated statically or dynamically, so}}
\DoxyCodeLine{01993 \textcolor{comment}{        check before attempting to free the memory. */}}
\DoxyCodeLine{01994         \textcolor{keywordflow}{if}( pxQueue-\/>ucStaticallyAllocated == ( uint8\_t ) pdFALSE )}
\DoxyCodeLine{01995         \{}
\DoxyCodeLine{01996             vPortFree( pxQueue );}
\DoxyCodeLine{01997         \}}
\DoxyCodeLine{01998         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01999         \{}
\DoxyCodeLine{02000             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02001         \}}
\DoxyCodeLine{02002     \}}
\DoxyCodeLine{02003 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{02004     \{}
\DoxyCodeLine{02005         \textcolor{comment}{/* The queue must have been statically allocated, so is not going to be}}
\DoxyCodeLine{02006 \textcolor{comment}{        deleted.  Avoid compiler warnings about the unused parameter. */}}
\DoxyCodeLine{02007         ( void ) pxQueue;}
\DoxyCodeLine{02008     \}}
\DoxyCodeLine{02009 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configSUPPORT\_DYNAMIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02010 \}}
\DoxyCodeLine{02011 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02012 }
\DoxyCodeLine{02013 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{02014 }
\DoxyCodeLine{02015     UBaseType\_t uxQueueGetQueueNumber( QueueHandle\_t xQueue )}
\DoxyCodeLine{02016     \{}
\DoxyCodeLine{02017         \textcolor{keywordflow}{return} ( ( Queue\_t * ) xQueue )-\/>uxQueueNumber;}
\DoxyCodeLine{02018     \}}
\DoxyCodeLine{02019 }
\DoxyCodeLine{02020 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02021 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02022 }
\DoxyCodeLine{02023 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{02024 }
\DoxyCodeLine{02025     \textcolor{keywordtype}{void} vQueueSetQueueNumber( QueueHandle\_t xQueue, UBaseType\_t uxQueueNumber )}
\DoxyCodeLine{02026     \{}
\DoxyCodeLine{02027         ( ( Queue\_t * ) xQueue )-\/>uxQueueNumber = uxQueueNumber;}
\DoxyCodeLine{02028     \}}
\DoxyCodeLine{02029 }
\DoxyCodeLine{02030 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02031 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02032 }
\DoxyCodeLine{02033 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{02034 }
\DoxyCodeLine{02035     uint8\_t ucQueueGetQueueType( QueueHandle\_t xQueue )}
\DoxyCodeLine{02036     \{}
\DoxyCodeLine{02037         \textcolor{keywordflow}{return} ( ( Queue\_t * ) xQueue )-\/>ucQueueType;}
\DoxyCodeLine{02038     \}}
\DoxyCodeLine{02039 }
\DoxyCodeLine{02040 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02041 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02042 }
\DoxyCodeLine{02043 \textcolor{preprocessor}{\#if( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{02044 }
\DoxyCodeLine{02045     \textcolor{keyword}{static} UBaseType\_t prvGetDisinheritPriorityAfterTimeout( \textcolor{keyword}{const} Queue\_t * \textcolor{keyword}{const} pxQueue )}
\DoxyCodeLine{02046     \{}
\DoxyCodeLine{02047     UBaseType\_t uxHighestPriorityOfWaitingTasks;}
\DoxyCodeLine{02048 }
\DoxyCodeLine{02049         \textcolor{comment}{/* If a task waiting for a mutex causes the mutex holder to inherit a}}
\DoxyCodeLine{02050 \textcolor{comment}{        priority, but the waiting task times out, then the holder should}}
\DoxyCodeLine{02051 \textcolor{comment}{        disinherit the priority -\/ but only down to the highest priority of any}}
\DoxyCodeLine{02052 \textcolor{comment}{        other tasks that are waiting for the same mutex.  For this purpose,}}
\DoxyCodeLine{02053 \textcolor{comment}{        return the priority of the highest priority task that is waiting for the}}
\DoxyCodeLine{02054 \textcolor{comment}{        mutex. */}}
\DoxyCodeLine{02055         \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( \&( pxQueue-\/>xTasksWaitingToReceive ) ) > 0U )}
\DoxyCodeLine{02056         \{}
\DoxyCodeLine{02057             uxHighestPriorityOfWaitingTasks = ( UBaseType\_t ) configMAX\_PRIORITIES -\/ ( UBaseType\_t ) listGET\_ITEM\_VALUE\_OF\_HEAD\_ENTRY( \&( pxQueue-\/>xTasksWaitingToReceive ) );}
\DoxyCodeLine{02058         \}}
\DoxyCodeLine{02059         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02060         \{}
\DoxyCodeLine{02061             uxHighestPriorityOfWaitingTasks = tskIDLE\_PRIORITY;}
\DoxyCodeLine{02062         \}}
\DoxyCodeLine{02063 }
\DoxyCodeLine{02064         \textcolor{keywordflow}{return} uxHighestPriorityOfWaitingTasks;}
\DoxyCodeLine{02065     \}}
\DoxyCodeLine{02066 }
\DoxyCodeLine{02067 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02068 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02069 }
\DoxyCodeLine{02070 \textcolor{keyword}{static} BaseType\_t prvCopyDataToQueue( Queue\_t * \textcolor{keyword}{const} pxQueue, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *pvItemToQueue, \textcolor{keyword}{const} BaseType\_t xPosition )}
\DoxyCodeLine{02071 \{}
\DoxyCodeLine{02072 BaseType\_t xReturn = pdFALSE;}
\DoxyCodeLine{02073 UBaseType\_t uxMessagesWaiting;}
\DoxyCodeLine{02074 }
\DoxyCodeLine{02075     \textcolor{comment}{/* This function is called from a critical section. */}}
\DoxyCodeLine{02076 }
\DoxyCodeLine{02077     uxMessagesWaiting = pxQueue-\/>uxMessagesWaiting;}
\DoxyCodeLine{02078 }
\DoxyCodeLine{02079     \textcolor{keywordflow}{if}( pxQueue-\/>uxItemSize == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02080     \{}
\DoxyCodeLine{02081 \textcolor{preprocessor}{        \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{02082         \{}
\DoxyCodeLine{02083             \textcolor{keywordflow}{if}( pxQueue-\/>uxQueueType == queueQUEUE\_IS\_MUTEX )}
\DoxyCodeLine{02084             \{}
\DoxyCodeLine{02085                 \textcolor{comment}{/* The mutex is no longer being held. */}}
\DoxyCodeLine{02086                 xReturn = xTaskPriorityDisinherit( pxQueue-\/>u.xSemaphore.xMutexHolder );}
\DoxyCodeLine{02087                 pxQueue-\/>u.xSemaphore.xMutexHolder = NULL;}
\DoxyCodeLine{02088             \}}
\DoxyCodeLine{02089             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02090             \{}
\DoxyCodeLine{02091                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02092             \}}
\DoxyCodeLine{02093         \}}
\DoxyCodeLine{02094 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02095     \}}
\DoxyCodeLine{02096     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xPosition == queueSEND\_TO\_BACK )}
\DoxyCodeLine{02097     \{}
\DoxyCodeLine{02098         ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pxQueue-\/>pcWriteTo, pvItemToQueue, ( size\_t ) pxQueue-\/>uxItemSize ); \textcolor{comment}{/*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */}}
\DoxyCodeLine{02099         pxQueue-\/>pcWriteTo += pxQueue-\/>uxItemSize; \textcolor{comment}{/*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */}}
\DoxyCodeLine{02100         \textcolor{keywordflow}{if}( pxQueue-\/>pcWriteTo >= pxQueue-\/>u.xQueue.pcTail ) \textcolor{comment}{/*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */}}
\DoxyCodeLine{02101         \{}
\DoxyCodeLine{02102             pxQueue-\/>pcWriteTo = pxQueue-\/>pcHead;}
\DoxyCodeLine{02103         \}}
\DoxyCodeLine{02104         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02105         \{}
\DoxyCodeLine{02106             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02107         \}}
\DoxyCodeLine{02108     \}}
\DoxyCodeLine{02109     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02110     \{}
\DoxyCodeLine{02111         ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pxQueue-\/>u.xQueue.pcReadFrom, pvItemToQueue, ( size\_t ) pxQueue-\/>uxItemSize ); \textcolor{comment}{/*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */}}
\DoxyCodeLine{02112         pxQueue-\/>u.xQueue.pcReadFrom -\/= pxQueue-\/>uxItemSize;}
\DoxyCodeLine{02113         \textcolor{keywordflow}{if}( pxQueue-\/>u.xQueue.pcReadFrom < pxQueue-\/>pcHead ) \textcolor{comment}{/*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */}}
\DoxyCodeLine{02114         \{}
\DoxyCodeLine{02115             pxQueue-\/>u.xQueue.pcReadFrom = ( pxQueue-\/>u.xQueue.pcTail -\/ pxQueue-\/>uxItemSize );}
\DoxyCodeLine{02116         \}}
\DoxyCodeLine{02117         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02118         \{}
\DoxyCodeLine{02119             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02120         \}}
\DoxyCodeLine{02121 }
\DoxyCodeLine{02122         \textcolor{keywordflow}{if}( xPosition == queueOVERWRITE )}
\DoxyCodeLine{02123         \{}
\DoxyCodeLine{02124             \textcolor{keywordflow}{if}( uxMessagesWaiting > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02125             \{}
\DoxyCodeLine{02126                 \textcolor{comment}{/* An item is not being added but overwritten, so subtract}}
\DoxyCodeLine{02127 \textcolor{comment}{                one from the recorded number of items in the queue so when}}
\DoxyCodeLine{02128 \textcolor{comment}{                one is added again below the number of recorded items remains}}
\DoxyCodeLine{02129 \textcolor{comment}{                correct. */}}
\DoxyCodeLine{02130                 -\/-\/uxMessagesWaiting;}
\DoxyCodeLine{02131             \}}
\DoxyCodeLine{02132             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02133             \{}
\DoxyCodeLine{02134                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02135             \}}
\DoxyCodeLine{02136         \}}
\DoxyCodeLine{02137         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02138         \{}
\DoxyCodeLine{02139             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02140         \}}
\DoxyCodeLine{02141     \}}
\DoxyCodeLine{02142 }
\DoxyCodeLine{02143     pxQueue-\/>uxMessagesWaiting = uxMessagesWaiting + ( UBaseType\_t ) 1;}
\DoxyCodeLine{02144 }
\DoxyCodeLine{02145     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02146 \}}
\DoxyCodeLine{02147 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02148 }
\DoxyCodeLine{02149 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvCopyDataFromQueue( Queue\_t * \textcolor{keyword}{const} pxQueue, \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvBuffer )}
\DoxyCodeLine{02150 \{}
\DoxyCodeLine{02151     \textcolor{keywordflow}{if}( pxQueue-\/>uxItemSize != ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02152     \{}
\DoxyCodeLine{02153         pxQueue-\/>u.xQueue.pcReadFrom += pxQueue-\/>uxItemSize; \textcolor{comment}{/*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */}}
\DoxyCodeLine{02154         \textcolor{keywordflow}{if}( pxQueue-\/>u.xQueue.pcReadFrom >= pxQueue-\/>u.xQueue.pcTail ) \textcolor{comment}{/*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */}}
\DoxyCodeLine{02155         \{}
\DoxyCodeLine{02156             pxQueue-\/>u.xQueue.pcReadFrom = pxQueue-\/>pcHead;}
\DoxyCodeLine{02157         \}}
\DoxyCodeLine{02158         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02159         \{}
\DoxyCodeLine{02160             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02161         \}}
\DoxyCodeLine{02162         ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pvBuffer, ( \textcolor{keywordtype}{void} * ) pxQueue-\/>u.xQueue.pcReadFrom, ( \textcolor{keywordtype}{size\_t} ) pxQueue-\/>uxItemSize ); \textcolor{comment}{/*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */}}
\DoxyCodeLine{02163     \}}
\DoxyCodeLine{02164 \}}
\DoxyCodeLine{02165 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02166 }
\DoxyCodeLine{02167 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvUnlockQueue( Queue\_t * \textcolor{keyword}{const} pxQueue )}
\DoxyCodeLine{02168 \{}
\DoxyCodeLine{02169     \textcolor{comment}{/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */}}
\DoxyCodeLine{02170 }
\DoxyCodeLine{02171     \textcolor{comment}{/* The lock counts contains the number of extra data items placed or}}
\DoxyCodeLine{02172 \textcolor{comment}{    removed from the queue while the queue was locked.  When a queue is}}
\DoxyCodeLine{02173 \textcolor{comment}{    locked items can be added or removed, but the event lists cannot be}}
\DoxyCodeLine{02174 \textcolor{comment}{    updated. */}}
\DoxyCodeLine{02175     taskENTER\_CRITICAL();}
\DoxyCodeLine{02176     \{}
\DoxyCodeLine{02177         int8\_t cTxLock = pxQueue-\/>cTxLock;}
\DoxyCodeLine{02178 }
\DoxyCodeLine{02179         \textcolor{comment}{/* See if data was added to the queue while it was locked. */}}
\DoxyCodeLine{02180         \textcolor{keywordflow}{while}( cTxLock > queueLOCKED\_UNMODIFIED )}
\DoxyCodeLine{02181         \{}
\DoxyCodeLine{02182             \textcolor{comment}{/* Data was posted while the queue was locked.  Are any tasks}}
\DoxyCodeLine{02183 \textcolor{comment}{            blocked waiting for data to become available? */}}
\DoxyCodeLine{02184 \textcolor{preprocessor}{            \#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{02185             \{}
\DoxyCodeLine{02186                 \textcolor{keywordflow}{if}( pxQueue-\/>pxQueueSetContainer != NULL )}
\DoxyCodeLine{02187                 \{}
\DoxyCodeLine{02188                     \textcolor{keywordflow}{if}( prvNotifyQueueSetContainer( pxQueue, queueSEND\_TO\_BACK ) != pdFALSE )}
\DoxyCodeLine{02189                     \{}
\DoxyCodeLine{02190                         \textcolor{comment}{/* The queue is a member of a queue set, and posting to}}
\DoxyCodeLine{02191 \textcolor{comment}{                        the queue set caused a higher priority task to unblock.}}
\DoxyCodeLine{02192 \textcolor{comment}{                        A context switch is required. */}}
\DoxyCodeLine{02193                         vTaskMissedYield();}
\DoxyCodeLine{02194                     \}}
\DoxyCodeLine{02195                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02196                     \{}
\DoxyCodeLine{02197                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02198                     \}}
\DoxyCodeLine{02199                 \}}
\DoxyCodeLine{02200                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02201                 \{}
\DoxyCodeLine{02202                     \textcolor{comment}{/* Tasks that are removed from the event list will get}}
\DoxyCodeLine{02203 \textcolor{comment}{                    added to the pending ready list as the scheduler is still}}
\DoxyCodeLine{02204 \textcolor{comment}{                    suspended. */}}
\DoxyCodeLine{02205                     \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{02206                     \{}
\DoxyCodeLine{02207                         \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{02208                         \{}
\DoxyCodeLine{02209                             \textcolor{comment}{/* The task waiting has a higher priority so record that a}}
\DoxyCodeLine{02210 \textcolor{comment}{                            context switch is required. */}}
\DoxyCodeLine{02211                             vTaskMissedYield();}
\DoxyCodeLine{02212                         \}}
\DoxyCodeLine{02213                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02214                         \{}
\DoxyCodeLine{02215                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02216                         \}}
\DoxyCodeLine{02217                     \}}
\DoxyCodeLine{02218                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02219                     \{}
\DoxyCodeLine{02220                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{02221                     \}}
\DoxyCodeLine{02222                 \}}
\DoxyCodeLine{02223             \}}
\DoxyCodeLine{02224 \textcolor{preprocessor}{            \#else }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02225             \{}
\DoxyCodeLine{02226                 \textcolor{comment}{/* Tasks that are removed from the event list will get added to}}
\DoxyCodeLine{02227 \textcolor{comment}{                the pending ready list as the scheduler is still suspended. */}}
\DoxyCodeLine{02228                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{02229                 \{}
\DoxyCodeLine{02230                     \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{02231                     \{}
\DoxyCodeLine{02232                         \textcolor{comment}{/* The task waiting has a higher priority so record that}}
\DoxyCodeLine{02233 \textcolor{comment}{                        a context switch is required. */}}
\DoxyCodeLine{02234                         vTaskMissedYield();}
\DoxyCodeLine{02235                     \}}
\DoxyCodeLine{02236                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02237                     \{}
\DoxyCodeLine{02238                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02239                     \}}
\DoxyCodeLine{02240                 \}}
\DoxyCodeLine{02241                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02242                 \{}
\DoxyCodeLine{02243                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{02244                 \}}
\DoxyCodeLine{02245             \}}
\DoxyCodeLine{02246 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02247 }
\DoxyCodeLine{02248             -\/-\/cTxLock;}
\DoxyCodeLine{02249         \}}
\DoxyCodeLine{02250 }
\DoxyCodeLine{02251         pxQueue-\/>cTxLock = queueUNLOCKED;}
\DoxyCodeLine{02252     \}}
\DoxyCodeLine{02253     taskEXIT\_CRITICAL();}
\DoxyCodeLine{02254 }
\DoxyCodeLine{02255     \textcolor{comment}{/* Do the same for the Rx lock. */}}
\DoxyCodeLine{02256     taskENTER\_CRITICAL();}
\DoxyCodeLine{02257     \{}
\DoxyCodeLine{02258         int8\_t cRxLock = pxQueue-\/>cRxLock;}
\DoxyCodeLine{02259 }
\DoxyCodeLine{02260         \textcolor{keywordflow}{while}( cRxLock > queueLOCKED\_UNMODIFIED )}
\DoxyCodeLine{02261         \{}
\DoxyCodeLine{02262             \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToSend ) ) == pdFALSE )}
\DoxyCodeLine{02263             \{}
\DoxyCodeLine{02264                 \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToSend ) ) != pdFALSE )}
\DoxyCodeLine{02265                 \{}
\DoxyCodeLine{02266                     vTaskMissedYield();}
\DoxyCodeLine{02267                 \}}
\DoxyCodeLine{02268                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02269                 \{}
\DoxyCodeLine{02270                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02271                 \}}
\DoxyCodeLine{02272 }
\DoxyCodeLine{02273                 -\/-\/cRxLock;}
\DoxyCodeLine{02274             \}}
\DoxyCodeLine{02275             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02276             \{}
\DoxyCodeLine{02277                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{02278             \}}
\DoxyCodeLine{02279         \}}
\DoxyCodeLine{02280 }
\DoxyCodeLine{02281         pxQueue-\/>cRxLock = queueUNLOCKED;}
\DoxyCodeLine{02282     \}}
\DoxyCodeLine{02283     taskEXIT\_CRITICAL();}
\DoxyCodeLine{02284 \}}
\DoxyCodeLine{02285 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02286 }
\DoxyCodeLine{02287 \textcolor{keyword}{static} BaseType\_t prvIsQueueEmpty( \textcolor{keyword}{const} Queue\_t *pxQueue )}
\DoxyCodeLine{02288 \{}
\DoxyCodeLine{02289 BaseType\_t xReturn;}
\DoxyCodeLine{02290 }
\DoxyCodeLine{02291     taskENTER\_CRITICAL();}
\DoxyCodeLine{02292     \{}
\DoxyCodeLine{02293         \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting == ( UBaseType\_t )  0 )}
\DoxyCodeLine{02294         \{}
\DoxyCodeLine{02295             xReturn = pdTRUE;}
\DoxyCodeLine{02296         \}}
\DoxyCodeLine{02297         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02298         \{}
\DoxyCodeLine{02299             xReturn = pdFALSE;}
\DoxyCodeLine{02300         \}}
\DoxyCodeLine{02301     \}}
\DoxyCodeLine{02302     taskEXIT\_CRITICAL();}
\DoxyCodeLine{02303 }
\DoxyCodeLine{02304     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02305 \}}
\DoxyCodeLine{02306 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02307 }
\DoxyCodeLine{02308 BaseType\_t xQueueIsQueueEmptyFromISR( \textcolor{keyword}{const} QueueHandle\_t xQueue )}
\DoxyCodeLine{02309 \{}
\DoxyCodeLine{02310 BaseType\_t xReturn;}
\DoxyCodeLine{02311 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{02312 }
\DoxyCodeLine{02313     configASSERT( pxQueue );}
\DoxyCodeLine{02314     \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02315     \{}
\DoxyCodeLine{02316         xReturn = pdTRUE;}
\DoxyCodeLine{02317     \}}
\DoxyCodeLine{02318     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02319     \{}
\DoxyCodeLine{02320         xReturn = pdFALSE;}
\DoxyCodeLine{02321     \}}
\DoxyCodeLine{02322 }
\DoxyCodeLine{02323     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02324 \} \textcolor{comment}{/*lint !e818 xQueue could not be pointer to const because it is a typedef. */}}
\DoxyCodeLine{02325 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02326 }
\DoxyCodeLine{02327 \textcolor{keyword}{static} BaseType\_t prvIsQueueFull( \textcolor{keyword}{const} Queue\_t *pxQueue )}
\DoxyCodeLine{02328 \{}
\DoxyCodeLine{02329 BaseType\_t xReturn;}
\DoxyCodeLine{02330 }
\DoxyCodeLine{02331     taskENTER\_CRITICAL();}
\DoxyCodeLine{02332     \{}
\DoxyCodeLine{02333         \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting == pxQueue-\/>uxLength )}
\DoxyCodeLine{02334         \{}
\DoxyCodeLine{02335             xReturn = pdTRUE;}
\DoxyCodeLine{02336         \}}
\DoxyCodeLine{02337         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02338         \{}
\DoxyCodeLine{02339             xReturn = pdFALSE;}
\DoxyCodeLine{02340         \}}
\DoxyCodeLine{02341     \}}
\DoxyCodeLine{02342     taskEXIT\_CRITICAL();}
\DoxyCodeLine{02343 }
\DoxyCodeLine{02344     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02345 \}}
\DoxyCodeLine{02346 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02347 }
\DoxyCodeLine{02348 BaseType\_t xQueueIsQueueFullFromISR( \textcolor{keyword}{const} QueueHandle\_t xQueue )}
\DoxyCodeLine{02349 \{}
\DoxyCodeLine{02350 BaseType\_t xReturn;}
\DoxyCodeLine{02351 Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{02352 }
\DoxyCodeLine{02353     configASSERT( pxQueue );}
\DoxyCodeLine{02354     \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting == pxQueue-\/>uxLength )}
\DoxyCodeLine{02355     \{}
\DoxyCodeLine{02356         xReturn = pdTRUE;}
\DoxyCodeLine{02357     \}}
\DoxyCodeLine{02358     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02359     \{}
\DoxyCodeLine{02360         xReturn = pdFALSE;}
\DoxyCodeLine{02361     \}}
\DoxyCodeLine{02362 }
\DoxyCodeLine{02363     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02364 \} \textcolor{comment}{/*lint !e818 xQueue could not be pointer to const because it is a typedef. */}}
\DoxyCodeLine{02365 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02366 }
\DoxyCodeLine{02367 \textcolor{preprocessor}{\#if ( configUSE\_CO\_ROUTINES == 1 )}}
\DoxyCodeLine{02368 }
\DoxyCodeLine{02369     BaseType\_t xQueueCRSend( QueueHandle\_t xQueue, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *pvItemToQueue, TickType\_t xTicksToWait )}
\DoxyCodeLine{02370     \{}
\DoxyCodeLine{02371     BaseType\_t xReturn;}
\DoxyCodeLine{02372     Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{02373 }
\DoxyCodeLine{02374         \textcolor{comment}{/* If the queue is already full we may have to block.  A critical section}}
\DoxyCodeLine{02375 \textcolor{comment}{        is required to prevent an interrupt removing something from the queue}}
\DoxyCodeLine{02376 \textcolor{comment}{        between the check to see if the queue is full and blocking on the queue. */}}
\DoxyCodeLine{02377         portDISABLE\_INTERRUPTS();}
\DoxyCodeLine{02378         \{}
\DoxyCodeLine{02379             \textcolor{keywordflow}{if}( prvIsQueueFull( pxQueue ) != pdFALSE )}
\DoxyCodeLine{02380             \{}
\DoxyCodeLine{02381                 \textcolor{comment}{/* The queue is full -\/ do we want to block or just leave without}}
\DoxyCodeLine{02382 \textcolor{comment}{                posting? */}}
\DoxyCodeLine{02383                 \textcolor{keywordflow}{if}( xTicksToWait > ( TickType\_t ) 0 )}
\DoxyCodeLine{02384                 \{}
\DoxyCodeLine{02385                     \textcolor{comment}{/* As this is called from a coroutine we cannot block directly, but}}
\DoxyCodeLine{02386 \textcolor{comment}{                    return indicating that we need to block. */}}
\DoxyCodeLine{02387                     vCoRoutineAddToDelayedList( xTicksToWait, \&( pxQueue-\/>xTasksWaitingToSend ) );}
\DoxyCodeLine{02388                     portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02389                     \textcolor{keywordflow}{return} errQUEUE\_BLOCKED;}
\DoxyCodeLine{02390                 \}}
\DoxyCodeLine{02391                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02392                 \{}
\DoxyCodeLine{02393                     portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02394                     \textcolor{keywordflow}{return} errQUEUE\_FULL;}
\DoxyCodeLine{02395                 \}}
\DoxyCodeLine{02396             \}}
\DoxyCodeLine{02397         \}}
\DoxyCodeLine{02398         portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02399 }
\DoxyCodeLine{02400         portDISABLE\_INTERRUPTS();}
\DoxyCodeLine{02401         \{}
\DoxyCodeLine{02402             \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting < pxQueue-\/>uxLength )}
\DoxyCodeLine{02403             \{}
\DoxyCodeLine{02404                 \textcolor{comment}{/* There is room in the queue, copy the data into the queue. */}}
\DoxyCodeLine{02405                 prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND\_TO\_BACK );}
\DoxyCodeLine{02406                 xReturn = pdPASS;}
\DoxyCodeLine{02407 }
\DoxyCodeLine{02408                 \textcolor{comment}{/* Were any co-\/routines waiting for data to become available? */}}
\DoxyCodeLine{02409                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{02410                 \{}
\DoxyCodeLine{02411                     \textcolor{comment}{/* In this instance the co-\/routine could be placed directly}}
\DoxyCodeLine{02412 \textcolor{comment}{                    into the ready list as we are within a critical section.}}
\DoxyCodeLine{02413 \textcolor{comment}{                    Instead the same pending ready list mechanism is used as if}}
\DoxyCodeLine{02414 \textcolor{comment}{                    the event were caused from within an interrupt. */}}
\DoxyCodeLine{02415                     \textcolor{keywordflow}{if}( xCoRoutineRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{02416                     \{}
\DoxyCodeLine{02417                         \textcolor{comment}{/* The co-\/routine waiting has a higher priority so record}}
\DoxyCodeLine{02418 \textcolor{comment}{                        that a yield might be appropriate. */}}
\DoxyCodeLine{02419                         xReturn = errQUEUE\_YIELD;}
\DoxyCodeLine{02420                     \}}
\DoxyCodeLine{02421                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02422                     \{}
\DoxyCodeLine{02423                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02424                     \}}
\DoxyCodeLine{02425                 \}}
\DoxyCodeLine{02426                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02427                 \{}
\DoxyCodeLine{02428                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02429                 \}}
\DoxyCodeLine{02430             \}}
\DoxyCodeLine{02431             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02432             \{}
\DoxyCodeLine{02433                 xReturn = errQUEUE\_FULL;}
\DoxyCodeLine{02434             \}}
\DoxyCodeLine{02435         \}}
\DoxyCodeLine{02436         portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02437 }
\DoxyCodeLine{02438         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02439     \}}
\DoxyCodeLine{02440 }
\DoxyCodeLine{02441 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_CO\_ROUTINES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02442 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02443 }
\DoxyCodeLine{02444 \textcolor{preprocessor}{\#if ( configUSE\_CO\_ROUTINES == 1 )}}
\DoxyCodeLine{02445 }
\DoxyCodeLine{02446     BaseType\_t xQueueCRReceive( QueueHandle\_t xQueue, \textcolor{keywordtype}{void} *pvBuffer, TickType\_t xTicksToWait )}
\DoxyCodeLine{02447     \{}
\DoxyCodeLine{02448     BaseType\_t xReturn;}
\DoxyCodeLine{02449     Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{02450 }
\DoxyCodeLine{02451         \textcolor{comment}{/* If the queue is already empty we may have to block.  A critical section}}
\DoxyCodeLine{02452 \textcolor{comment}{        is required to prevent an interrupt adding something to the queue}}
\DoxyCodeLine{02453 \textcolor{comment}{        between the check to see if the queue is empty and blocking on the queue. */}}
\DoxyCodeLine{02454         portDISABLE\_INTERRUPTS();}
\DoxyCodeLine{02455         \{}
\DoxyCodeLine{02456             \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02457             \{}
\DoxyCodeLine{02458                 \textcolor{comment}{/* There are no messages in the queue, do we want to block or just}}
\DoxyCodeLine{02459 \textcolor{comment}{                leave with nothing? */}}
\DoxyCodeLine{02460                 \textcolor{keywordflow}{if}( xTicksToWait > ( TickType\_t ) 0 )}
\DoxyCodeLine{02461                 \{}
\DoxyCodeLine{02462                     \textcolor{comment}{/* As this is a co-\/routine we cannot block directly, but return}}
\DoxyCodeLine{02463 \textcolor{comment}{                    indicating that we need to block. */}}
\DoxyCodeLine{02464                     vCoRoutineAddToDelayedList( xTicksToWait, \&( pxQueue-\/>xTasksWaitingToReceive ) );}
\DoxyCodeLine{02465                     portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02466                     \textcolor{keywordflow}{return} errQUEUE\_BLOCKED;}
\DoxyCodeLine{02467                 \}}
\DoxyCodeLine{02468                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02469                 \{}
\DoxyCodeLine{02470                     portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02471                     \textcolor{keywordflow}{return} errQUEUE\_FULL;}
\DoxyCodeLine{02472                 \}}
\DoxyCodeLine{02473             \}}
\DoxyCodeLine{02474             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02475             \{}
\DoxyCodeLine{02476                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02477             \}}
\DoxyCodeLine{02478         \}}
\DoxyCodeLine{02479         portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02480 }
\DoxyCodeLine{02481         portDISABLE\_INTERRUPTS();}
\DoxyCodeLine{02482         \{}
\DoxyCodeLine{02483             \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02484             \{}
\DoxyCodeLine{02485                 \textcolor{comment}{/* Data is available from the queue. */}}
\DoxyCodeLine{02486                 pxQueue-\/>u.xQueue.pcReadFrom += pxQueue-\/>uxItemSize;}
\DoxyCodeLine{02487                 \textcolor{keywordflow}{if}( pxQueue-\/>u.xQueue.pcReadFrom >= pxQueue-\/>u.xQueue.pcTail )}
\DoxyCodeLine{02488                 \{}
\DoxyCodeLine{02489                     pxQueue-\/>u.xQueue.pcReadFrom = pxQueue-\/>pcHead;}
\DoxyCodeLine{02490                 \}}
\DoxyCodeLine{02491                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02492                 \{}
\DoxyCodeLine{02493                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02494                 \}}
\DoxyCodeLine{02495                 -\/-\/( pxQueue-\/>uxMessagesWaiting );}
\DoxyCodeLine{02496                 ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pvBuffer, ( \textcolor{keywordtype}{void} * ) pxQueue-\/>u.xQueue.pcReadFrom, ( \textcolor{keywordtype}{unsigned} ) pxQueue-\/>uxItemSize );}
\DoxyCodeLine{02497 }
\DoxyCodeLine{02498                 xReturn = pdPASS;}
\DoxyCodeLine{02499 }
\DoxyCodeLine{02500                 \textcolor{comment}{/* Were any co-\/routines waiting for space to become available? */}}
\DoxyCodeLine{02501                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToSend ) ) == pdFALSE )}
\DoxyCodeLine{02502                 \{}
\DoxyCodeLine{02503                     \textcolor{comment}{/* In this instance the co-\/routine could be placed directly}}
\DoxyCodeLine{02504 \textcolor{comment}{                    into the ready list as we are within a critical section.}}
\DoxyCodeLine{02505 \textcolor{comment}{                    Instead the same pending ready list mechanism is used as if}}
\DoxyCodeLine{02506 \textcolor{comment}{                    the event were caused from within an interrupt. */}}
\DoxyCodeLine{02507                     \textcolor{keywordflow}{if}( xCoRoutineRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToSend ) ) != pdFALSE )}
\DoxyCodeLine{02508                     \{}
\DoxyCodeLine{02509                         xReturn = errQUEUE\_YIELD;}
\DoxyCodeLine{02510                     \}}
\DoxyCodeLine{02511                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02512                     \{}
\DoxyCodeLine{02513                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02514                     \}}
\DoxyCodeLine{02515                 \}}
\DoxyCodeLine{02516                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02517                 \{}
\DoxyCodeLine{02518                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02519                 \}}
\DoxyCodeLine{02520             \}}
\DoxyCodeLine{02521             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02522             \{}
\DoxyCodeLine{02523                 xReturn = pdFAIL;}
\DoxyCodeLine{02524             \}}
\DoxyCodeLine{02525         \}}
\DoxyCodeLine{02526         portENABLE\_INTERRUPTS();}
\DoxyCodeLine{02527 }
\DoxyCodeLine{02528         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02529     \}}
\DoxyCodeLine{02530 }
\DoxyCodeLine{02531 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_CO\_ROUTINES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02532 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02533 }
\DoxyCodeLine{02534 \textcolor{preprocessor}{\#if ( configUSE\_CO\_ROUTINES == 1 )}}
\DoxyCodeLine{02535 }
\DoxyCodeLine{02536     BaseType\_t xQueueCRSendFromISR( QueueHandle\_t xQueue, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *pvItemToQueue, BaseType\_t xCoRoutinePreviouslyWoken )}
\DoxyCodeLine{02537     \{}
\DoxyCodeLine{02538     Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{02539 }
\DoxyCodeLine{02540         \textcolor{comment}{/* Cannot block within an ISR so if there is no space on the queue then}}
\DoxyCodeLine{02541 \textcolor{comment}{        exit without doing anything. */}}
\DoxyCodeLine{02542         \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting < pxQueue-\/>uxLength )}
\DoxyCodeLine{02543         \{}
\DoxyCodeLine{02544             prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND\_TO\_BACK );}
\DoxyCodeLine{02545 }
\DoxyCodeLine{02546             \textcolor{comment}{/* We only want to wake one co-\/routine per ISR, so check that a}}
\DoxyCodeLine{02547 \textcolor{comment}{            co-\/routine has not already been woken. */}}
\DoxyCodeLine{02548             \textcolor{keywordflow}{if}( xCoRoutinePreviouslyWoken == pdFALSE )}
\DoxyCodeLine{02549             \{}
\DoxyCodeLine{02550                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{02551                 \{}
\DoxyCodeLine{02552                     \textcolor{keywordflow}{if}( xCoRoutineRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{02553                     \{}
\DoxyCodeLine{02554                         \textcolor{keywordflow}{return} pdTRUE;}
\DoxyCodeLine{02555                     \}}
\DoxyCodeLine{02556                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02557                     \{}
\DoxyCodeLine{02558                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02559                     \}}
\DoxyCodeLine{02560                 \}}
\DoxyCodeLine{02561                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02562                 \{}
\DoxyCodeLine{02563                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02564                 \}}
\DoxyCodeLine{02565             \}}
\DoxyCodeLine{02566             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02567             \{}
\DoxyCodeLine{02568                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02569             \}}
\DoxyCodeLine{02570         \}}
\DoxyCodeLine{02571         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02572         \{}
\DoxyCodeLine{02573             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02574         \}}
\DoxyCodeLine{02575 }
\DoxyCodeLine{02576         \textcolor{keywordflow}{return} xCoRoutinePreviouslyWoken;}
\DoxyCodeLine{02577     \}}
\DoxyCodeLine{02578 }
\DoxyCodeLine{02579 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_CO\_ROUTINES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02580 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02581 }
\DoxyCodeLine{02582 \textcolor{preprocessor}{\#if ( configUSE\_CO\_ROUTINES == 1 )}}
\DoxyCodeLine{02583 }
\DoxyCodeLine{02584     BaseType\_t xQueueCRReceiveFromISR( QueueHandle\_t xQueue, \textcolor{keywordtype}{void} *pvBuffer, BaseType\_t *pxCoRoutineWoken )}
\DoxyCodeLine{02585     \{}
\DoxyCodeLine{02586     BaseType\_t xReturn;}
\DoxyCodeLine{02587     Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{02588 }
\DoxyCodeLine{02589         \textcolor{comment}{/* We cannot block from an ISR, so check there is data available. If}}
\DoxyCodeLine{02590 \textcolor{comment}{        not then just leave without doing anything. */}}
\DoxyCodeLine{02591         \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02592         \{}
\DoxyCodeLine{02593             \textcolor{comment}{/* Copy the data from the queue. */}}
\DoxyCodeLine{02594             pxQueue-\/>u.xQueue.pcReadFrom += pxQueue-\/>uxItemSize;}
\DoxyCodeLine{02595             \textcolor{keywordflow}{if}( pxQueue-\/>u.xQueue.pcReadFrom >= pxQueue-\/>u.xQueue.pcTail )}
\DoxyCodeLine{02596             \{}
\DoxyCodeLine{02597                 pxQueue-\/>u.xQueue.pcReadFrom = pxQueue-\/>pcHead;}
\DoxyCodeLine{02598             \}}
\DoxyCodeLine{02599             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02600             \{}
\DoxyCodeLine{02601                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02602             \}}
\DoxyCodeLine{02603             -\/-\/( pxQueue-\/>uxMessagesWaiting );}
\DoxyCodeLine{02604             ( void ) memcpy( ( \textcolor{keywordtype}{void} * ) pvBuffer, ( \textcolor{keywordtype}{void} * ) pxQueue-\/>u.xQueue.pcReadFrom, ( \textcolor{keywordtype}{unsigned} ) pxQueue-\/>uxItemSize );}
\DoxyCodeLine{02605 }
\DoxyCodeLine{02606             \textcolor{keywordflow}{if}( ( *pxCoRoutineWoken ) == pdFALSE )}
\DoxyCodeLine{02607             \{}
\DoxyCodeLine{02608                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueue-\/>xTasksWaitingToSend ) ) == pdFALSE )}
\DoxyCodeLine{02609                 \{}
\DoxyCodeLine{02610                     \textcolor{keywordflow}{if}( xCoRoutineRemoveFromEventList( \&( pxQueue-\/>xTasksWaitingToSend ) ) != pdFALSE )}
\DoxyCodeLine{02611                     \{}
\DoxyCodeLine{02612                         *pxCoRoutineWoken = pdTRUE;}
\DoxyCodeLine{02613                     \}}
\DoxyCodeLine{02614                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02615                     \{}
\DoxyCodeLine{02616                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02617                     \}}
\DoxyCodeLine{02618                 \}}
\DoxyCodeLine{02619                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02620                 \{}
\DoxyCodeLine{02621                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02622                 \}}
\DoxyCodeLine{02623             \}}
\DoxyCodeLine{02624             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02625             \{}
\DoxyCodeLine{02626                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02627             \}}
\DoxyCodeLine{02628 }
\DoxyCodeLine{02629             xReturn = pdPASS;}
\DoxyCodeLine{02630         \}}
\DoxyCodeLine{02631         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02632         \{}
\DoxyCodeLine{02633             xReturn = pdFAIL;}
\DoxyCodeLine{02634         \}}
\DoxyCodeLine{02635 }
\DoxyCodeLine{02636         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02637     \}}
\DoxyCodeLine{02638 }
\DoxyCodeLine{02639 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_CO\_ROUTINES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02640 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02641 }
\DoxyCodeLine{02642 \textcolor{preprocessor}{\#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{02643 }
\DoxyCodeLine{02644     \textcolor{keywordtype}{void} vQueueAddToRegistry( QueueHandle\_t xQueue, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pcQueueName ) \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{02645     \{}
\DoxyCodeLine{02646     UBaseType\_t ux;}
\DoxyCodeLine{02647 }
\DoxyCodeLine{02648         \textcolor{comment}{/* See if there is an empty space in the registry.  A NULL name denotes}}
\DoxyCodeLine{02649 \textcolor{comment}{        a free slot. */}}
\DoxyCodeLine{02650         \textcolor{keywordflow}{for}( ux = ( UBaseType\_t ) 0U; ux < ( UBaseType\_t ) configQUEUE\_REGISTRY\_SIZE; ux++ )}
\DoxyCodeLine{02651         \{}
\DoxyCodeLine{02652             \textcolor{keywordflow}{if}( xQueueRegistry[ ux ].pcQueueName == NULL )}
\DoxyCodeLine{02653             \{}
\DoxyCodeLine{02654                 \textcolor{comment}{/* Store the information on this queue. */}}
\DoxyCodeLine{02655                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;}
\DoxyCodeLine{02656                 xQueueRegistry[ ux ].xHandle = xQueue;}
\DoxyCodeLine{02657 }
\DoxyCodeLine{02658                 traceQUEUE\_REGISTRY\_ADD( xQueue, pcQueueName );}
\DoxyCodeLine{02659                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{02660             \}}
\DoxyCodeLine{02661             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02662             \{}
\DoxyCodeLine{02663                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02664             \}}
\DoxyCodeLine{02665         \}}
\DoxyCodeLine{02666     \}}
\DoxyCodeLine{02667 }
\DoxyCodeLine{02668 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configQUEUE\_REGISTRY\_SIZE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02669 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02670 }
\DoxyCodeLine{02671 \textcolor{preprocessor}{\#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{02672 }
\DoxyCodeLine{02673     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pcQueueGetName( QueueHandle\_t xQueue ) \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{02674     \{}
\DoxyCodeLine{02675     UBaseType\_t ux;}
\DoxyCodeLine{02676     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pcReturn = NULL; \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{02677 }
\DoxyCodeLine{02678         \textcolor{comment}{/* Note there is nothing here to protect against another task adding or}}
\DoxyCodeLine{02679 \textcolor{comment}{        removing entries from the registry while it is being searched. */}}
\DoxyCodeLine{02680         \textcolor{keywordflow}{for}( ux = ( UBaseType\_t ) 0U; ux < ( UBaseType\_t ) configQUEUE\_REGISTRY\_SIZE; ux++ )}
\DoxyCodeLine{02681         \{}
\DoxyCodeLine{02682             \textcolor{keywordflow}{if}( xQueueRegistry[ ux ].xHandle == xQueue )}
\DoxyCodeLine{02683             \{}
\DoxyCodeLine{02684                 pcReturn = xQueueRegistry[ ux ].pcQueueName;}
\DoxyCodeLine{02685                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{02686             \}}
\DoxyCodeLine{02687             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02688             \{}
\DoxyCodeLine{02689                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02690             \}}
\DoxyCodeLine{02691         \}}
\DoxyCodeLine{02692 }
\DoxyCodeLine{02693         \textcolor{keywordflow}{return} pcReturn;}
\DoxyCodeLine{02694     \} \textcolor{comment}{/*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */}}
\DoxyCodeLine{02695 }
\DoxyCodeLine{02696 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configQUEUE\_REGISTRY\_SIZE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02697 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02698 }
\DoxyCodeLine{02699 \textcolor{preprocessor}{\#if ( configQUEUE\_REGISTRY\_SIZE > 0 )}}
\DoxyCodeLine{02700 }
\DoxyCodeLine{02701     \textcolor{keywordtype}{void} vQueueUnregisterQueue( QueueHandle\_t xQueue )}
\DoxyCodeLine{02702     \{}
\DoxyCodeLine{02703     UBaseType\_t ux;}
\DoxyCodeLine{02704 }
\DoxyCodeLine{02705         \textcolor{comment}{/* See if the handle of the queue being unregistered in actually in the}}
\DoxyCodeLine{02706 \textcolor{comment}{        registry. */}}
\DoxyCodeLine{02707         \textcolor{keywordflow}{for}( ux = ( UBaseType\_t ) 0U; ux < ( UBaseType\_t ) configQUEUE\_REGISTRY\_SIZE; ux++ )}
\DoxyCodeLine{02708         \{}
\DoxyCodeLine{02709             \textcolor{keywordflow}{if}( xQueueRegistry[ ux ].xHandle == xQueue )}
\DoxyCodeLine{02710             \{}
\DoxyCodeLine{02711                 \textcolor{comment}{/* Set the name to NULL to show that this slot if free again. */}}
\DoxyCodeLine{02712                 xQueueRegistry[ ux ].pcQueueName = NULL;}
\DoxyCodeLine{02713 }
\DoxyCodeLine{02714                 \textcolor{comment}{/* Set the handle to NULL to ensure the same queue handle cannot}}
\DoxyCodeLine{02715 \textcolor{comment}{                appear in the registry twice if it is added, removed, then}}
\DoxyCodeLine{02716 \textcolor{comment}{                added again. */}}
\DoxyCodeLine{02717                 xQueueRegistry[ ux ].xHandle = ( QueueHandle\_t ) 0;}
\DoxyCodeLine{02718                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{02719             \}}
\DoxyCodeLine{02720             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02721             \{}
\DoxyCodeLine{02722                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02723             \}}
\DoxyCodeLine{02724         \}}
\DoxyCodeLine{02725 }
\DoxyCodeLine{02726     \} \textcolor{comment}{/*lint !e818 xQueue could not be pointer to const because it is a typedef. */}}
\DoxyCodeLine{02727 }
\DoxyCodeLine{02728 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configQUEUE\_REGISTRY\_SIZE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02729 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02730 }
\DoxyCodeLine{02731 \textcolor{preprocessor}{\#if ( configUSE\_TIMERS == 1 )}}
\DoxyCodeLine{02732 }
\DoxyCodeLine{02733     \textcolor{keywordtype}{void} vQueueWaitForMessageRestricted( QueueHandle\_t xQueue, TickType\_t xTicksToWait, \textcolor{keyword}{const} BaseType\_t xWaitIndefinitely )}
\DoxyCodeLine{02734     \{}
\DoxyCodeLine{02735     Queue\_t * \textcolor{keyword}{const} pxQueue = xQueue;}
\DoxyCodeLine{02736 }
\DoxyCodeLine{02737         \textcolor{comment}{/* This function should not be called by application code hence the}}
\DoxyCodeLine{02738 \textcolor{comment}{        'Restricted' in its name.  It is not part of the public API.  It is}}
\DoxyCodeLine{02739 \textcolor{comment}{        designed for use by kernel code, and has special calling requirements.}}
\DoxyCodeLine{02740 \textcolor{comment}{        It can result in vListInsert() being called on a list that can only}}
\DoxyCodeLine{02741 \textcolor{comment}{        possibly ever have one item in it, so the list will be fast, but even}}
\DoxyCodeLine{02742 \textcolor{comment}{        so it should be called with the scheduler locked and not from a critical}}
\DoxyCodeLine{02743 \textcolor{comment}{        section. */}}
\DoxyCodeLine{02744 }
\DoxyCodeLine{02745         \textcolor{comment}{/* Only do anything if there are no messages in the queue.  This function}}
\DoxyCodeLine{02746 \textcolor{comment}{        will not actually cause the task to block, just place it on a blocked}}
\DoxyCodeLine{02747 \textcolor{comment}{        list.  It will not block until the scheduler is unlocked -\/ at which}}
\DoxyCodeLine{02748 \textcolor{comment}{        time a yield will be performed.  If an item is added to the queue while}}
\DoxyCodeLine{02749 \textcolor{comment}{        the queue is locked, and the calling task blocks on the queue, then the}}
\DoxyCodeLine{02750 \textcolor{comment}{        calling task will be immediately unblocked when the queue is unlocked. */}}
\DoxyCodeLine{02751         prvLockQueue( pxQueue );}
\DoxyCodeLine{02752         \textcolor{keywordflow}{if}( pxQueue-\/>uxMessagesWaiting == ( UBaseType\_t ) 0U )}
\DoxyCodeLine{02753         \{}
\DoxyCodeLine{02754             \textcolor{comment}{/* There is nothing in the queue, block for the specified period. */}}
\DoxyCodeLine{02755             vTaskPlaceOnEventListRestricted( \&( pxQueue-\/>xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );}
\DoxyCodeLine{02756         \}}
\DoxyCodeLine{02757         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02758         \{}
\DoxyCodeLine{02759             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02760         \}}
\DoxyCodeLine{02761         prvUnlockQueue( pxQueue );}
\DoxyCodeLine{02762     \}}
\DoxyCodeLine{02763 }
\DoxyCodeLine{02764 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TIMERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02765 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02766 }
\DoxyCodeLine{02767 \textcolor{preprocessor}{\#if( ( configUSE\_QUEUE\_SETS == 1 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{02768 }
\DoxyCodeLine{02769     QueueSetHandle\_t xQueueCreateSet( \textcolor{keyword}{const} UBaseType\_t uxEventQueueLength )}
\DoxyCodeLine{02770     \{}
\DoxyCodeLine{02771     QueueSetHandle\_t pxQueue;}
\DoxyCodeLine{02772 }
\DoxyCodeLine{02773         pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType\_t ) \textcolor{keyword}{sizeof}( Queue\_t * ), queueQUEUE\_TYPE\_SET );}
\DoxyCodeLine{02774 }
\DoxyCodeLine{02775         \textcolor{keywordflow}{return} pxQueue;}
\DoxyCodeLine{02776     \}}
\DoxyCodeLine{02777 }
\DoxyCodeLine{02778 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02779 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02780 }
\DoxyCodeLine{02781 \textcolor{preprocessor}{\#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{02782 }
\DoxyCodeLine{02783     BaseType\_t xQueueAddToSet( QueueSetMemberHandle\_t xQueueOrSemaphore, QueueSetHandle\_t xQueueSet )}
\DoxyCodeLine{02784     \{}
\DoxyCodeLine{02785     BaseType\_t xReturn;}
\DoxyCodeLine{02786 }
\DoxyCodeLine{02787         taskENTER\_CRITICAL();}
\DoxyCodeLine{02788         \{}
\DoxyCodeLine{02789             \textcolor{keywordflow}{if}( ( ( Queue\_t * ) xQueueOrSemaphore )-\/>pxQueueSetContainer != NULL )}
\DoxyCodeLine{02790             \{}
\DoxyCodeLine{02791                 \textcolor{comment}{/* Cannot add a queue/semaphore to more than one queue set. */}}
\DoxyCodeLine{02792                 xReturn = pdFAIL;}
\DoxyCodeLine{02793             \}}
\DoxyCodeLine{02794             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ( ( Queue\_t * ) xQueueOrSemaphore )-\/>uxMessagesWaiting != ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02795             \{}
\DoxyCodeLine{02796                 \textcolor{comment}{/* Cannot add a queue/semaphore to a queue set if there are already}}
\DoxyCodeLine{02797 \textcolor{comment}{                items in the queue/semaphore. */}}
\DoxyCodeLine{02798                 xReturn = pdFAIL;}
\DoxyCodeLine{02799             \}}
\DoxyCodeLine{02800             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02801             \{}
\DoxyCodeLine{02802                 ( ( Queue\_t * ) xQueueOrSemaphore )-\/>pxQueueSetContainer = xQueueSet;}
\DoxyCodeLine{02803                 xReturn = pdPASS;}
\DoxyCodeLine{02804             \}}
\DoxyCodeLine{02805         \}}
\DoxyCodeLine{02806         taskEXIT\_CRITICAL();}
\DoxyCodeLine{02807 }
\DoxyCodeLine{02808         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02809     \}}
\DoxyCodeLine{02810 }
\DoxyCodeLine{02811 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02812 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02813 }
\DoxyCodeLine{02814 \textcolor{preprocessor}{\#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{02815 }
\DoxyCodeLine{02816     BaseType\_t xQueueRemoveFromSet( QueueSetMemberHandle\_t xQueueOrSemaphore, QueueSetHandle\_t xQueueSet )}
\DoxyCodeLine{02817     \{}
\DoxyCodeLine{02818     BaseType\_t xReturn;}
\DoxyCodeLine{02819     Queue\_t * \textcolor{keyword}{const} pxQueueOrSemaphore = ( Queue\_t * ) xQueueOrSemaphore;}
\DoxyCodeLine{02820 }
\DoxyCodeLine{02821         \textcolor{keywordflow}{if}( pxQueueOrSemaphore-\/>pxQueueSetContainer != xQueueSet )}
\DoxyCodeLine{02822         \{}
\DoxyCodeLine{02823             \textcolor{comment}{/* The queue was not a member of the set. */}}
\DoxyCodeLine{02824             xReturn = pdFAIL;}
\DoxyCodeLine{02825         \}}
\DoxyCodeLine{02826         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( pxQueueOrSemaphore-\/>uxMessagesWaiting != ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02827         \{}
\DoxyCodeLine{02828             \textcolor{comment}{/* It is dangerous to remove a queue from a set when the queue is}}
\DoxyCodeLine{02829 \textcolor{comment}{            not empty because the queue set will still hold pending events for}}
\DoxyCodeLine{02830 \textcolor{comment}{            the queue. */}}
\DoxyCodeLine{02831             xReturn = pdFAIL;}
\DoxyCodeLine{02832         \}}
\DoxyCodeLine{02833         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02834         \{}
\DoxyCodeLine{02835             taskENTER\_CRITICAL();}
\DoxyCodeLine{02836             \{}
\DoxyCodeLine{02837                 \textcolor{comment}{/* The queue is no longer contained in the set. */}}
\DoxyCodeLine{02838                 pxQueueOrSemaphore-\/>pxQueueSetContainer = NULL;}
\DoxyCodeLine{02839             \}}
\DoxyCodeLine{02840             taskEXIT\_CRITICAL();}
\DoxyCodeLine{02841             xReturn = pdPASS;}
\DoxyCodeLine{02842         \}}
\DoxyCodeLine{02843 }
\DoxyCodeLine{02844         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02845     \} \textcolor{comment}{/*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */}}
\DoxyCodeLine{02846 }
\DoxyCodeLine{02847 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02848 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02849 }
\DoxyCodeLine{02850 \textcolor{preprocessor}{\#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{02851 }
\DoxyCodeLine{02852     QueueSetMemberHandle\_t xQueueSelectFromSet( QueueSetHandle\_t xQueueSet, TickType\_t \textcolor{keyword}{const} xTicksToWait )}
\DoxyCodeLine{02853     \{}
\DoxyCodeLine{02854     QueueSetMemberHandle\_t xReturn = NULL;}
\DoxyCodeLine{02855 }
\DoxyCodeLine{02856         ( void ) xQueueReceive( ( QueueHandle\_t ) xQueueSet, \&xReturn, xTicksToWait ); \textcolor{comment}{/*lint !e961 Casting from one typedef to another is not redundant. */}}
\DoxyCodeLine{02857         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02858     \}}
\DoxyCodeLine{02859 }
\DoxyCodeLine{02860 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02861 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02862 }
\DoxyCodeLine{02863 \textcolor{preprocessor}{\#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{02864 }
\DoxyCodeLine{02865     QueueSetMemberHandle\_t xQueueSelectFromSetFromISR( QueueSetHandle\_t xQueueSet )}
\DoxyCodeLine{02866     \{}
\DoxyCodeLine{02867     QueueSetMemberHandle\_t xReturn = NULL;}
\DoxyCodeLine{02868 }
\DoxyCodeLine{02869         ( void ) xQueueReceiveFromISR( ( QueueHandle\_t ) xQueueSet, \&xReturn, NULL ); \textcolor{comment}{/*lint !e961 Casting from one typedef to another is not redundant. */}}
\DoxyCodeLine{02870         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02871     \}}
\DoxyCodeLine{02872 }
\DoxyCodeLine{02873 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02874 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02875 }
\DoxyCodeLine{02876 \textcolor{preprocessor}{\#if ( configUSE\_QUEUE\_SETS == 1 )}}
\DoxyCodeLine{02877 }
\DoxyCodeLine{02878     \textcolor{keyword}{static} BaseType\_t prvNotifyQueueSetContainer( \textcolor{keyword}{const} Queue\_t * \textcolor{keyword}{const} pxQueue, \textcolor{keyword}{const} BaseType\_t xCopyPosition )}
\DoxyCodeLine{02879     \{}
\DoxyCodeLine{02880     Queue\_t *pxQueueSetContainer = pxQueue-\/>pxQueueSetContainer;}
\DoxyCodeLine{02881     BaseType\_t xReturn = pdFALSE;}
\DoxyCodeLine{02882 }
\DoxyCodeLine{02883         \textcolor{comment}{/* This function must be called form a critical section. */}}
\DoxyCodeLine{02884 }
\DoxyCodeLine{02885         configASSERT( pxQueueSetContainer );}
\DoxyCodeLine{02886         configASSERT( pxQueueSetContainer-\/>uxMessagesWaiting < pxQueueSetContainer-\/>uxLength );}
\DoxyCodeLine{02887 }
\DoxyCodeLine{02888         \textcolor{keywordflow}{if}( pxQueueSetContainer-\/>uxMessagesWaiting < pxQueueSetContainer-\/>uxLength )}
\DoxyCodeLine{02889         \{}
\DoxyCodeLine{02890             \textcolor{keyword}{const} int8\_t cTxLock = pxQueueSetContainer-\/>cTxLock;}
\DoxyCodeLine{02891 }
\DoxyCodeLine{02892             traceQUEUE\_SEND( pxQueueSetContainer );}
\DoxyCodeLine{02893 }
\DoxyCodeLine{02894             \textcolor{comment}{/* The data copied is the handle of the queue that contains data. */}}
\DoxyCodeLine{02895             xReturn = prvCopyDataToQueue( pxQueueSetContainer, \&pxQueue, xCopyPosition );}
\DoxyCodeLine{02896 }
\DoxyCodeLine{02897             \textcolor{keywordflow}{if}( cTxLock == queueUNLOCKED )}
\DoxyCodeLine{02898             \{}
\DoxyCodeLine{02899                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( \&( pxQueueSetContainer-\/>xTasksWaitingToReceive ) ) == pdFALSE )}
\DoxyCodeLine{02900                 \{}
\DoxyCodeLine{02901                     \textcolor{keywordflow}{if}( xTaskRemoveFromEventList( \&( pxQueueSetContainer-\/>xTasksWaitingToReceive ) ) != pdFALSE )}
\DoxyCodeLine{02902                     \{}
\DoxyCodeLine{02903                         \textcolor{comment}{/* The task waiting has a higher priority. */}}
\DoxyCodeLine{02904                         xReturn = pdTRUE;}
\DoxyCodeLine{02905                     \}}
\DoxyCodeLine{02906                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02907                     \{}
\DoxyCodeLine{02908                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02909                     \}}
\DoxyCodeLine{02910                 \}}
\DoxyCodeLine{02911                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02912                 \{}
\DoxyCodeLine{02913                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02914                 \}}
\DoxyCodeLine{02915             \}}
\DoxyCodeLine{02916             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02917             \{}
\DoxyCodeLine{02918                 pxQueueSetContainer-\/>cTxLock = ( int8\_t ) ( cTxLock + 1 );}
\DoxyCodeLine{02919             \}}
\DoxyCodeLine{02920         \}}
\DoxyCodeLine{02921         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02922         \{}
\DoxyCodeLine{02923             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02924         \}}
\DoxyCodeLine{02925 }
\DoxyCodeLine{02926         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02927     \}}
\DoxyCodeLine{02928 }
\DoxyCodeLine{02929 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_QUEUE\_SETS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02930 }
\DoxyCodeLine{02931 }
\DoxyCodeLine{02932 }
\DoxyCodeLine{02933 }
\DoxyCodeLine{02934 }
\DoxyCodeLine{02935 }
\DoxyCodeLine{02936 }
\DoxyCodeLine{02937 }
\DoxyCodeLine{02938 }
\DoxyCodeLine{02939 }
\DoxyCodeLine{02940 }
\DoxyCodeLine{02941 }

\end{DoxyCode}
