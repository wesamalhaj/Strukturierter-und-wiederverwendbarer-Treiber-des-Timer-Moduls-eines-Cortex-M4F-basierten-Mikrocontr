\doxysection{tasks.\+c}
\label{tasks_8c_source}\index{rtos/FreeRTOS/source/tasks.c@{rtos/FreeRTOS/source/tasks.c}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{/*}}
\DoxyCodeLine{00002 \textcolor{comment}{ * FreeRTOS Kernel V10.2.1}}
\DoxyCodeLine{00003 \textcolor{comment}{ * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.}}
\DoxyCodeLine{00004 \textcolor{comment}{ *}}
\DoxyCodeLine{00005 \textcolor{comment}{ * Permission is hereby granted, free of charge, to any person obtaining a copy of}}
\DoxyCodeLine{00006 \textcolor{comment}{ * this software and associated documentation files (the "{}Software"{}), to deal in}}
\DoxyCodeLine{00007 \textcolor{comment}{ * the Software without restriction, including without limitation the rights to}}
\DoxyCodeLine{00008 \textcolor{comment}{ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of}}
\DoxyCodeLine{00009 \textcolor{comment}{ * the Software, and to permit persons to whom the Software is furnished to do so,}}
\DoxyCodeLine{00010 \textcolor{comment}{ * subject to the following conditions:}}
\DoxyCodeLine{00011 \textcolor{comment}{ *}}
\DoxyCodeLine{00012 \textcolor{comment}{ * The above copyright notice and this permission notice shall be included in all}}
\DoxyCodeLine{00013 \textcolor{comment}{ * copies or substantial portions of the Software.}}
\DoxyCodeLine{00014 \textcolor{comment}{ *}}
\DoxyCodeLine{00015 \textcolor{comment}{ * THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}}
\DoxyCodeLine{00016 \textcolor{comment}{ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS}}
\DoxyCodeLine{00017 \textcolor{comment}{ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR}}
\DoxyCodeLine{00018 \textcolor{comment}{ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER}}
\DoxyCodeLine{00019 \textcolor{comment}{ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN}}
\DoxyCodeLine{00020 \textcolor{comment}{ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{00021 \textcolor{comment}{ *}}
\DoxyCodeLine{00022 \textcolor{comment}{ * http://www.FreeRTOS.org}}
\DoxyCodeLine{00023 \textcolor{comment}{ * http://aws.amazon.com/freertos}}
\DoxyCodeLine{00024 \textcolor{comment}{ *}}
\DoxyCodeLine{00025 \textcolor{comment}{ * 1 tab == 4 spaces!}}
\DoxyCodeLine{00026 \textcolor{comment}{ */}}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 \textcolor{comment}{/* Standard includes. */}}
\DoxyCodeLine{00029 \textcolor{preprocessor}{\#include <stdlib.h>}}
\DoxyCodeLine{00030 \textcolor{preprocessor}{\#include <string.h>}}
\DoxyCodeLine{00031 }
\DoxyCodeLine{00032 \textcolor{comment}{/* Defining MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE prevents task.h from redefining}}
\DoxyCodeLine{00033 \textcolor{comment}{all the API functions to use the MPU wrappers.  That should only be done when}}
\DoxyCodeLine{00034 \textcolor{comment}{task.h is included from an application file. */}}
\DoxyCodeLine{00035 \textcolor{preprocessor}{\#define MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE}}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037 \textcolor{comment}{/* FreeRTOS includes. */}}
\DoxyCodeLine{00038 \textcolor{preprocessor}{\#include "{}FreeRTOS.h"{}}}
\DoxyCodeLine{00039 \textcolor{preprocessor}{\#include "{}task.h"{}}}
\DoxyCodeLine{00040 \textcolor{preprocessor}{\#include "{}timers.h"{}}}
\DoxyCodeLine{00041 \textcolor{preprocessor}{\#include "{}stack\_macros.h"{}}}
\DoxyCodeLine{00042 }
\DoxyCodeLine{00043 \textcolor{comment}{/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified}}
\DoxyCodeLine{00044 \textcolor{comment}{because the MPU ports require MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE to be defined}}
\DoxyCodeLine{00045 \textcolor{comment}{for the header files above, but not in this file, in order to generate the}}
\DoxyCodeLine{00046 \textcolor{comment}{correct privileged Vs unprivileged linkage and placement. */}}
\DoxyCodeLine{00047 \textcolor{preprocessor}{\#undef MPU\_WRAPPERS\_INCLUDED\_FROM\_API\_FILE }\textcolor{comment}{/*lint !e961 !e750 !e9021. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049 \textcolor{comment}{/* Set configUSE\_STATS\_FORMATTING\_FUNCTIONS to 2 to include the stats formatting}}
\DoxyCodeLine{00050 \textcolor{comment}{functions but without including stdio.h here. */}}
\DoxyCodeLine{00051 \textcolor{preprocessor}{\#if ( configUSE\_STATS\_FORMATTING\_FUNCTIONS == 1 )}}
\DoxyCodeLine{00052     \textcolor{comment}{/* At the bottom of this file are two optional functions that can be used}}
\DoxyCodeLine{00053 \textcolor{comment}{    to generate human readable text from the raw data generated by the}}
\DoxyCodeLine{00054 \textcolor{comment}{    uxTaskGetSystemState() function.  Note the formatting functions are provided}}
\DoxyCodeLine{00055 \textcolor{comment}{    for convenience only, and are NOT considered part of the kernel. */}}
\DoxyCodeLine{00056 \textcolor{preprocessor}{    \#include <stdio.h>}}
\DoxyCodeLine{00057 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_STATS\_FORMATTING\_FUNCTIONS == 1 ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00058 }
\DoxyCodeLine{00059 \textcolor{preprocessor}{\#if( configUSE\_PREEMPTION == 0 )}}
\DoxyCodeLine{00060     \textcolor{comment}{/* If the cooperative scheduler is being used then a yield should not be}}
\DoxyCodeLine{00061 \textcolor{comment}{    performed just because a higher priority task has been woken. */}}
\DoxyCodeLine{00062 \textcolor{preprocessor}{    \#define taskYIELD\_IF\_USING\_PREEMPTION()}}
\DoxyCodeLine{00063 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00064 \textcolor{preprocessor}{    \#define taskYIELD\_IF\_USING\_PREEMPTION() portYIELD\_WITHIN\_API()}}
\DoxyCodeLine{00065 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00066 }
\DoxyCodeLine{00067 \textcolor{comment}{/* Values that can be assigned to the ucNotifyState member of the TCB. */}}
\DoxyCodeLine{00068 \textcolor{preprocessor}{\#define taskNOT\_WAITING\_NOTIFICATION    ( ( uint8\_t ) 0 )}}
\DoxyCodeLine{00069 \textcolor{preprocessor}{\#define taskWAITING\_NOTIFICATION        ( ( uint8\_t ) 1 )}}
\DoxyCodeLine{00070 \textcolor{preprocessor}{\#define taskNOTIFICATION\_RECEIVED       ( ( uint8\_t ) 2 )}}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072 \textcolor{comment}{/*}}
\DoxyCodeLine{00073 \textcolor{comment}{ * The value used to fill the stack of a task when the task is created.  This}}
\DoxyCodeLine{00074 \textcolor{comment}{ * is used purely for checking the high water mark for tasks.}}
\DoxyCodeLine{00075 \textcolor{comment}{ */}}
\DoxyCodeLine{00076 \textcolor{preprocessor}{\#define tskSTACK\_FILL\_BYTE  ( 0xa5U )}}
\DoxyCodeLine{00077 }
\DoxyCodeLine{00078 \textcolor{comment}{/* Bits used to recored how a task's stack and TCB were allocated. */}}
\DoxyCodeLine{00079 \textcolor{preprocessor}{\#define tskDYNAMICALLY\_ALLOCATED\_STACK\_AND\_TCB      ( ( uint8\_t ) 0 )}}
\DoxyCodeLine{00080 \textcolor{preprocessor}{\#define tskSTATICALLY\_ALLOCATED\_STACK\_ONLY          ( ( uint8\_t ) 1 )}}
\DoxyCodeLine{00081 \textcolor{preprocessor}{\#define tskSTATICALLY\_ALLOCATED\_STACK\_AND\_TCB       ( ( uint8\_t ) 2 )}}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083 \textcolor{comment}{/* If any of the following are set then task stacks are filled with a known}}
\DoxyCodeLine{00084 \textcolor{comment}{value so the high water mark can be determined.  If none of the following are}}
\DoxyCodeLine{00085 \textcolor{comment}{set then don't fill the stack so there is no unnecessary dependency on memset. */}}
\DoxyCodeLine{00086 \textcolor{preprocessor}{\#if( ( configCHECK\_FOR\_STACK\_OVERFLOW > 1 ) || ( configUSE\_TRACE\_FACILITY == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark2 == 1 ) )}}
\DoxyCodeLine{00087 \textcolor{preprocessor}{    \#define tskSET\_NEW\_STACKS\_TO\_KNOWN\_VALUE    1}}
\DoxyCodeLine{00088 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00089 \textcolor{preprocessor}{    \#define tskSET\_NEW\_STACKS\_TO\_KNOWN\_VALUE    0}}
\DoxyCodeLine{00090 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 \textcolor{comment}{/*}}
\DoxyCodeLine{00093 \textcolor{comment}{ * Macros used by vListTask to indicate which state a task is in.}}
\DoxyCodeLine{00094 \textcolor{comment}{ */}}
\DoxyCodeLine{00095 \textcolor{preprocessor}{\#define tskRUNNING\_CHAR     ( 'X' )}}
\DoxyCodeLine{00096 \textcolor{preprocessor}{\#define tskBLOCKED\_CHAR     ( 'B' )}}
\DoxyCodeLine{00097 \textcolor{preprocessor}{\#define tskREADY\_CHAR       ( 'R' )}}
\DoxyCodeLine{00098 \textcolor{preprocessor}{\#define tskDELETED\_CHAR     ( 'D' )}}
\DoxyCodeLine{00099 \textcolor{preprocessor}{\#define tskSUSPENDED\_CHAR   ( 'S' )}}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101 \textcolor{comment}{/*}}
\DoxyCodeLine{00102 \textcolor{comment}{ * Some kernel aware debuggers require the data the debugger needs access to be}}
\DoxyCodeLine{00103 \textcolor{comment}{ * global, rather than file scope.}}
\DoxyCodeLine{00104 \textcolor{comment}{ */}}
\DoxyCodeLine{00105 \textcolor{preprocessor}{\#ifdef portREMOVE\_STATIC\_QUALIFIER}}
\DoxyCodeLine{00106 \textcolor{preprocessor}{    \#define static}}
\DoxyCodeLine{00107 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00108 }
\DoxyCodeLine{00109 \textcolor{comment}{/* The name allocated to the Idle task.  This can be overridden by defining}}
\DoxyCodeLine{00110 \textcolor{comment}{configIDLE\_TASK\_NAME in FreeRTOSConfig.h. */}}
\DoxyCodeLine{00111 \textcolor{preprocessor}{\#ifndef configIDLE\_TASK\_NAME}}
\DoxyCodeLine{00112 \textcolor{preprocessor}{    \#define configIDLE\_TASK\_NAME "{}IDLE"{}}}
\DoxyCodeLine{00113 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115 \textcolor{preprocessor}{\#if ( configUSE\_PORT\_OPTIMISED\_TASK\_SELECTION == 0 )}}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117     \textcolor{comment}{/* If configUSE\_PORT\_OPTIMISED\_TASK\_SELECTION is 0 then task selection is}}
\DoxyCodeLine{00118 \textcolor{comment}{    performed in a generic way that is not optimised to any particular}}
\DoxyCodeLine{00119 \textcolor{comment}{    microcontroller architecture. */}}
\DoxyCodeLine{00120 }
\DoxyCodeLine{00121     \textcolor{comment}{/* uxTopReadyPriority holds the priority of the highest priority ready}}
\DoxyCodeLine{00122 \textcolor{comment}{    state task. */}}
\DoxyCodeLine{00123 \textcolor{preprocessor}{    \#define taskRECORD\_READY\_PRIORITY( uxPriority )                                                     \(\backslash\)}}
\DoxyCodeLine{00124 \textcolor{preprocessor}{    \{                                                                                                   \(\backslash\)}}
\DoxyCodeLine{00125 \textcolor{preprocessor}{        if( ( uxPriority ) > uxTopReadyPriority )                                                       \(\backslash\)}}
\DoxyCodeLine{00126 \textcolor{preprocessor}{        \{                                                                                               \(\backslash\)}}
\DoxyCodeLine{00127 \textcolor{preprocessor}{            uxTopReadyPriority = ( uxPriority );                                                        \(\backslash\)}}
\DoxyCodeLine{00128 \textcolor{preprocessor}{        \}                                                                                               \(\backslash\)}}
\DoxyCodeLine{00129 \textcolor{preprocessor}{    \} }\textcolor{comment}{/* taskRECORD\_READY\_PRIORITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00130 }
\DoxyCodeLine{00131     \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133 \textcolor{preprocessor}{    \#define taskSELECT\_HIGHEST\_PRIORITY\_TASK()                                                          \(\backslash\)}}
\DoxyCodeLine{00134 \textcolor{preprocessor}{    \{                                                                                                   \(\backslash\)}}
\DoxyCodeLine{00135 \textcolor{preprocessor}{    UBaseType\_t uxTopPriority = uxTopReadyPriority;                                                     \(\backslash\)}}
\DoxyCodeLine{00136 \textcolor{preprocessor}{                                                                                                        \(\backslash\)}}
\DoxyCodeLine{00137 \textcolor{preprocessor}{        }\textcolor{comment}{/* Find the highest priority queue that contains ready tasks. */}\textcolor{preprocessor}{                                \(\backslash\)}}
\DoxyCodeLine{00138 \textcolor{preprocessor}{        while( listLIST\_IS\_EMPTY( \&( pxReadyTasksLists[ uxTopPriority ] ) ) )                           \(\backslash\)}}
\DoxyCodeLine{00139 \textcolor{preprocessor}{        \{                                                                                               \(\backslash\)}}
\DoxyCodeLine{00140 \textcolor{preprocessor}{            configASSERT( uxTopPriority );                                                              \(\backslash\)}}
\DoxyCodeLine{00141 \textcolor{preprocessor}{            -\/-\/uxTopPriority;                                                                            \(\backslash\)}}
\DoxyCodeLine{00142 \textcolor{preprocessor}{        \}                                                                                               \(\backslash\)}}
\DoxyCodeLine{00143 \textcolor{preprocessor}{                                                                                                        \(\backslash\)}}
\DoxyCodeLine{00144 \textcolor{preprocessor}{        }\textcolor{comment}{/* listGET\_OWNER\_OF\_NEXT\_ENTRY indexes through the list, so the tasks of                        \(\backslash\)}}
\DoxyCodeLine{00145 \textcolor{comment}{        the same priority get an equal share of the processor time. */}\textcolor{preprocessor}{                                  \(\backslash\)}}
\DoxyCodeLine{00146 \textcolor{preprocessor}{        listGET\_OWNER\_OF\_NEXT\_ENTRY( pxCurrentTCB, \&( pxReadyTasksLists[ uxTopPriority ] ) );           \(\backslash\)}}
\DoxyCodeLine{00147 \textcolor{preprocessor}{        uxTopReadyPriority = uxTopPriority;                                                             \(\backslash\)}}
\DoxyCodeLine{00148 \textcolor{preprocessor}{    \} }\textcolor{comment}{/* taskSELECT\_HIGHEST\_PRIORITY\_TASK */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00149 }
\DoxyCodeLine{00150     \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00151 }
\DoxyCodeLine{00152     \textcolor{comment}{/* Define away taskRESET\_READY\_PRIORITY() and portRESET\_READY\_PRIORITY() as}}
\DoxyCodeLine{00153 \textcolor{comment}{    they are only required when a port optimised method of task selection is}}
\DoxyCodeLine{00154 \textcolor{comment}{    being used. */}}
\DoxyCodeLine{00155 \textcolor{preprocessor}{    \#define taskRESET\_READY\_PRIORITY( uxPriority )}}
\DoxyCodeLine{00156 \textcolor{preprocessor}{    \#define portRESET\_READY\_PRIORITY( uxPriority, uxTopReadyPriority )}}
\DoxyCodeLine{00157 }
\DoxyCodeLine{00158 \textcolor{preprocessor}{\#else }\textcolor{comment}{/* configUSE\_PORT\_OPTIMISED\_TASK\_SELECTION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00159 }
\DoxyCodeLine{00160     \textcolor{comment}{/* If configUSE\_PORT\_OPTIMISED\_TASK\_SELECTION is 1 then task selection is}}
\DoxyCodeLine{00161 \textcolor{comment}{    performed in a way that is tailored to the particular microcontroller}}
\DoxyCodeLine{00162 \textcolor{comment}{    architecture being used. */}}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164     \textcolor{comment}{/* A port optimised version is provided.  Call the port defined macros. */}}
\DoxyCodeLine{00165 \textcolor{preprocessor}{    \#define taskRECORD\_READY\_PRIORITY( uxPriority ) portRECORD\_READY\_PRIORITY( uxPriority, uxTopReadyPriority )}}
\DoxyCodeLine{00166 }
\DoxyCodeLine{00167     \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169 \textcolor{preprocessor}{    \#define taskSELECT\_HIGHEST\_PRIORITY\_TASK()                                                      \(\backslash\)}}
\DoxyCodeLine{00170 \textcolor{preprocessor}{    \{                                                                                               \(\backslash\)}}
\DoxyCodeLine{00171 \textcolor{preprocessor}{    UBaseType\_t uxTopPriority;                                                                      \(\backslash\)}}
\DoxyCodeLine{00172 \textcolor{preprocessor}{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{00173 \textcolor{preprocessor}{        }\textcolor{comment}{/* Find the highest priority list that contains ready tasks. */}\textcolor{preprocessor}{                             \(\backslash\)}}
\DoxyCodeLine{00174 \textcolor{preprocessor}{        portGET\_HIGHEST\_PRIORITY( uxTopPriority, uxTopReadyPriority );                              \(\backslash\)}}
\DoxyCodeLine{00175 \textcolor{preprocessor}{        configASSERT( listCURRENT\_LIST\_LENGTH( \&( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );     \(\backslash\)}}
\DoxyCodeLine{00176 \textcolor{preprocessor}{        listGET\_OWNER\_OF\_NEXT\_ENTRY( pxCurrentTCB, \&( pxReadyTasksLists[ uxTopPriority ] ) );       \(\backslash\)}}
\DoxyCodeLine{00177 \textcolor{preprocessor}{    \} }\textcolor{comment}{/* taskSELECT\_HIGHEST\_PRIORITY\_TASK() */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00178 }
\DoxyCodeLine{00179     \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181     \textcolor{comment}{/* A port optimised version is provided, call it only if the TCB being reset}}
\DoxyCodeLine{00182 \textcolor{comment}{    is being referenced from a ready list.  If it is referenced from a delayed}}
\DoxyCodeLine{00183 \textcolor{comment}{    or suspended list then it won't be in a ready list. */}}
\DoxyCodeLine{00184 \textcolor{preprocessor}{    \#define taskRESET\_READY\_PRIORITY( uxPriority )                                                      \(\backslash\)}}
\DoxyCodeLine{00185 \textcolor{preprocessor}{    \{                                                                                                   \(\backslash\)}}
\DoxyCodeLine{00186 \textcolor{preprocessor}{        if( listCURRENT\_LIST\_LENGTH( \&( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType\_t ) 0 )  \(\backslash\)}}
\DoxyCodeLine{00187 \textcolor{preprocessor}{        \{                                                                                               \(\backslash\)}}
\DoxyCodeLine{00188 \textcolor{preprocessor}{            portRESET\_READY\_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                         \(\backslash\)}}
\DoxyCodeLine{00189 \textcolor{preprocessor}{        \}                                                                                               \(\backslash\)}}
\DoxyCodeLine{00190 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{00191 }
\DoxyCodeLine{00192 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_PORT\_OPTIMISED\_TASK\_SELECTION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00193 }
\DoxyCodeLine{00194 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00195 }
\DoxyCodeLine{00196 \textcolor{comment}{/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick}}
\DoxyCodeLine{00197 \textcolor{comment}{count overflows. */}}
\DoxyCodeLine{00198 \textcolor{preprocessor}{\#define taskSWITCH\_DELAYED\_LISTS()                                                                  \(\backslash\)}}
\DoxyCodeLine{00199 \textcolor{preprocessor}{\{                                                                                                   \(\backslash\)}}
\DoxyCodeLine{00200 \textcolor{preprocessor}{    List\_t *pxTemp;                                                                                 \(\backslash\)}}
\DoxyCodeLine{00201 \textcolor{preprocessor}{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{00202 \textcolor{preprocessor}{    }\textcolor{comment}{/* The delayed tasks list should be empty when the lists are switched. */}\textcolor{preprocessor}{                       \(\backslash\)}}
\DoxyCodeLine{00203 \textcolor{preprocessor}{    configASSERT( ( listLIST\_IS\_EMPTY( pxDelayedTaskList ) ) );                                     \(\backslash\)}}
\DoxyCodeLine{00204 \textcolor{preprocessor}{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{00205 \textcolor{preprocessor}{    pxTemp = pxDelayedTaskList;                                                                     \(\backslash\)}}
\DoxyCodeLine{00206 \textcolor{preprocessor}{    pxDelayedTaskList = pxOverflowDelayedTaskList;                                                  \(\backslash\)}}
\DoxyCodeLine{00207 \textcolor{preprocessor}{    pxOverflowDelayedTaskList = pxTemp;                                                             \(\backslash\)}}
\DoxyCodeLine{00208 \textcolor{preprocessor}{    xNumOfOverflows++;                                                                              \(\backslash\)}}
\DoxyCodeLine{00209 \textcolor{preprocessor}{    prvResetNextTaskUnblockTime();                                                                  \(\backslash\)}}
\DoxyCodeLine{00210 \textcolor{preprocessor}{\}}}
\DoxyCodeLine{00211 }
\DoxyCodeLine{00212 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214 \textcolor{comment}{/*}}
\DoxyCodeLine{00215 \textcolor{comment}{ * Place the task represented by pxTCB into the appropriate ready list for}}
\DoxyCodeLine{00216 \textcolor{comment}{ * the task.  It is inserted at the end of the list.}}
\DoxyCodeLine{00217 \textcolor{comment}{ */}}
\DoxyCodeLine{00218 \textcolor{preprocessor}{\#define prvAddTaskToReadyList( pxTCB )                                                              \(\backslash\)}}
\DoxyCodeLine{00219 \textcolor{preprocessor}{    traceMOVED\_TASK\_TO\_READY\_STATE( pxTCB );                                                        \(\backslash\)}}
\DoxyCodeLine{00220 \textcolor{preprocessor}{    taskRECORD\_READY\_PRIORITY( ( pxTCB )-\/>uxPriority );                                             \(\backslash\)}}
\DoxyCodeLine{00221 \textcolor{preprocessor}{    vListInsertEnd( \&( pxReadyTasksLists[ ( pxTCB )-\/>uxPriority ] ), \&( ( pxTCB )-\/>xStateListItem ) ); \(\backslash\)}}
\DoxyCodeLine{00222 \textcolor{preprocessor}{    tracePOST\_MOVED\_TASK\_TO\_READY\_STATE( pxTCB )}}
\DoxyCodeLine{00223 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00224 }
\DoxyCodeLine{00225 \textcolor{comment}{/*}}
\DoxyCodeLine{00226 \textcolor{comment}{ * Several functions take an TaskHandle\_t parameter that can optionally be NULL,}}
\DoxyCodeLine{00227 \textcolor{comment}{ * where NULL is used to indicate that the handle of the currently executing}}
\DoxyCodeLine{00228 \textcolor{comment}{ * task should be used in place of the parameter.  This macro simply checks to}}
\DoxyCodeLine{00229 \textcolor{comment}{ * see if the parameter is NULL and returns a pointer to the appropriate TCB.}}
\DoxyCodeLine{00230 \textcolor{comment}{ */}}
\DoxyCodeLine{00231 \textcolor{preprocessor}{\#define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )}}
\DoxyCodeLine{00232 }
\DoxyCodeLine{00233 \textcolor{comment}{/* The item value of the event list item is normally used to hold the priority}}
\DoxyCodeLine{00234 \textcolor{comment}{of the task to which it belongs (coded to allow it to be held in reverse}}
\DoxyCodeLine{00235 \textcolor{comment}{priority order).  However, it is occasionally borrowed for other purposes.  It}}
\DoxyCodeLine{00236 \textcolor{comment}{is important its value is not updated due to a task priority change while it is}}
\DoxyCodeLine{00237 \textcolor{comment}{being used for another purpose.  The following bit definition is used to inform}}
\DoxyCodeLine{00238 \textcolor{comment}{the scheduler that the value should not be changed -\/ in which case it is the}}
\DoxyCodeLine{00239 \textcolor{comment}{responsibility of whichever module is using the value to ensure it gets set back}}
\DoxyCodeLine{00240 \textcolor{comment}{to its original value when it is released. */}}
\DoxyCodeLine{00241 \textcolor{preprocessor}{\#if( configUSE\_16\_BIT\_TICKS == 1 )}}
\DoxyCodeLine{00242 \textcolor{preprocessor}{    \#define taskEVENT\_LIST\_ITEM\_VALUE\_IN\_USE    0x8000U}}
\DoxyCodeLine{00243 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00244 \textcolor{preprocessor}{    \#define taskEVENT\_LIST\_ITEM\_VALUE\_IN\_USE    0x80000000UL}}
\DoxyCodeLine{00245 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247 \textcolor{comment}{/*}}
\DoxyCodeLine{00248 \textcolor{comment}{ * Task control block.  A task control block (TCB) is allocated for each task,}}
\DoxyCodeLine{00249 \textcolor{comment}{ * and stores task state information, including a pointer to the task's context}}
\DoxyCodeLine{00250 \textcolor{comment}{ * (the task's run time environment, including register values)}}
\DoxyCodeLine{00251 \textcolor{comment}{ */}}
\DoxyCodeLine{00252 \textcolor{keyword}{typedef} \textcolor{keyword}{struct }tskTaskControlBlock           \textcolor{comment}{/* The old naming convention is used to prevent breaking kernel aware debuggers. */}}
\DoxyCodeLine{00253 \{}
\DoxyCodeLine{00254     \textcolor{keyword}{volatile} StackType\_t    *pxTopOfStack;  \textcolor{comment}{/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */}}
\DoxyCodeLine{00255 }
\DoxyCodeLine{00256 \textcolor{preprocessor}{    \#if ( portUSING\_MPU\_WRAPPERS == 1 )}}
\DoxyCodeLine{00257         xMPU\_SETTINGS   xMPUSettings;       \textcolor{comment}{/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */}}
\DoxyCodeLine{00258 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00259 }
\DoxyCodeLine{00260     ListItem\_t            xStateListItem; \textcolor{comment}{/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */}}
\DoxyCodeLine{00261     ListItem\_t            xEventListItem;     \textcolor{comment}{/*< Used to reference a task from an event list. */}}
\DoxyCodeLine{00262     UBaseType\_t         uxPriority;         \textcolor{comment}{/*< The priority of the task.  0 is the lowest priority. */}}
\DoxyCodeLine{00263     StackType\_t         *pxStack;           \textcolor{comment}{/*< Points to the start of the stack. */}}
\DoxyCodeLine{00264     \textcolor{keywordtype}{char}                pcTaskName[ configMAX\_TASK\_NAME\_LEN ];\textcolor{comment}{/*< Descriptive name given to the task when created.  Facilitates debugging only. */} \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{00265 }
\DoxyCodeLine{00266 \textcolor{preprocessor}{    \#if ( ( portSTACK\_GROWTH > 0 ) || ( configRECORD\_STACK\_HIGH\_ADDRESS == 1 ) )}}
\DoxyCodeLine{00267         StackType\_t     *pxEndOfStack;      \textcolor{comment}{/*< Points to the highest valid address for the stack. */}}
\DoxyCodeLine{00268 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270 \textcolor{preprocessor}{    \#if ( portCRITICAL\_NESTING\_IN\_TCB == 1 )}}
\DoxyCodeLine{00271         UBaseType\_t     uxCriticalNesting;  \textcolor{comment}{/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */}}
\DoxyCodeLine{00272 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00273 }
\DoxyCodeLine{00274 \textcolor{preprocessor}{    \#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{00275         UBaseType\_t     uxTCBNumber;        \textcolor{comment}{/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */}}
\DoxyCodeLine{00276         UBaseType\_t     uxTaskNumber;       \textcolor{comment}{/*< Stores a number specifically for use by third party trace code. */}}
\DoxyCodeLine{00277 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00278 }
\DoxyCodeLine{00279 \textcolor{preprocessor}{    \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{00280         UBaseType\_t     uxBasePriority;     \textcolor{comment}{/*< The priority last assigned to the task -\/ used by the priority inheritance mechanism. */}}
\DoxyCodeLine{00281         UBaseType\_t     uxMutexesHeld;}
\DoxyCodeLine{00282 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00283 }
\DoxyCodeLine{00284 \textcolor{preprocessor}{    \#if ( configUSE\_APPLICATION\_TASK\_TAG == 1 )}}
\DoxyCodeLine{00285         TaskHookFunction\_t pxTaskTag;}
\DoxyCodeLine{00286 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00287 }
\DoxyCodeLine{00288 \textcolor{preprocessor}{    \#if( configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS > 0 )}}
\DoxyCodeLine{00289         \textcolor{keywordtype}{void}            *pvThreadLocalStoragePointers[ configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS ];}
\DoxyCodeLine{00290 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00291 }
\DoxyCodeLine{00292 \textcolor{preprocessor}{    \#if( configGENERATE\_RUN\_TIME\_STATS == 1 )}}
\DoxyCodeLine{00293         uint32\_t        ulRunTimeCounter;   \textcolor{comment}{/*< Stores the amount of time the task has spent in the Running state. */}}
\DoxyCodeLine{00294 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00295 }
\DoxyCodeLine{00296 \textcolor{preprocessor}{    \#if ( configUSE\_NEWLIB\_REENTRANT == 1 )}}
\DoxyCodeLine{00297         \textcolor{comment}{/* Allocate a Newlib reent structure that is specific to this task.}}
\DoxyCodeLine{00298 \textcolor{comment}{        Note Newlib support has been included by popular demand, but is not}}
\DoxyCodeLine{00299 \textcolor{comment}{        used by the FreeRTOS maintainers themselves.  FreeRTOS is not}}
\DoxyCodeLine{00300 \textcolor{comment}{        responsible for resulting newlib operation.  User must be familiar with}}
\DoxyCodeLine{00301 \textcolor{comment}{        newlib and must provide system-\/wide implementations of the necessary}}
\DoxyCodeLine{00302 \textcolor{comment}{        stubs. Be warned that (at the time of writing) the current newlib design}}
\DoxyCodeLine{00303 \textcolor{comment}{        implements a system-\/wide malloc() that must be provided with locks. */}}
\DoxyCodeLine{00304         \textcolor{keyword}{struct  }\_reent xNewLib\_reent;}
\DoxyCodeLine{00305 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00306 }
\DoxyCodeLine{00307 \textcolor{preprocessor}{    \#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{00308         \textcolor{keyword}{volatile} uint32\_t ulNotifiedValue;}
\DoxyCodeLine{00309         \textcolor{keyword}{volatile} uint8\_t ucNotifyState;}
\DoxyCodeLine{00310 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00311 }
\DoxyCodeLine{00312     \textcolor{comment}{/* See the comments in FreeRTOS.h with the definition of}}
\DoxyCodeLine{00313 \textcolor{comment}{    tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE. */}}
\DoxyCodeLine{00314 \textcolor{preprocessor}{    \#if( tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE != 0 ) }\textcolor{comment}{/*lint !e731 !e9029 Macro has been consolidated for readability reasons. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00315         uint8\_t ucStaticallyAllocated;      \textcolor{comment}{/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */}}
\DoxyCodeLine{00316 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00317 }
\DoxyCodeLine{00318 \textcolor{preprocessor}{    \#if( INCLUDE\_xTaskAbortDelay == 1 )}}
\DoxyCodeLine{00319         uint8\_t ucDelayAborted;}
\DoxyCodeLine{00320 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322 \textcolor{preprocessor}{    \#if( configUSE\_POSIX\_ERRNO == 1 )}}
\DoxyCodeLine{00323         \textcolor{keywordtype}{int} iTaskErrno;}
\DoxyCodeLine{00324 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00325 }
\DoxyCodeLine{00326 \} tskTCB;}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328 \textcolor{comment}{/* The old tskTCB name is maintained above then typedefed to the new TCB\_t name}}
\DoxyCodeLine{00329 \textcolor{comment}{below to enable the use of older kernel aware debuggers. */}}
\DoxyCodeLine{00330 \textcolor{keyword}{typedef} tskTCB TCB\_t;}
\DoxyCodeLine{00331 }
\DoxyCodeLine{00332 \textcolor{comment}{/*lint -\/save -\/e956 A manual analysis and inspection has been used to determine}}
\DoxyCodeLine{00333 \textcolor{comment}{which static variables must be declared volatile. */}}
\DoxyCodeLine{00334 PRIVILEGED\_DATA TCB\_t * \textcolor{keyword}{volatile} pxCurrentTCB = NULL;}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336 \textcolor{comment}{/* Lists for ready and blocked tasks. -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{00337 \textcolor{comment}{xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but}}
\DoxyCodeLine{00338 \textcolor{comment}{doing so breaks some kernel aware debuggers and debuggers that rely on removing}}
\DoxyCodeLine{00339 \textcolor{comment}{the static qualifier. */}}
\DoxyCodeLine{00340 PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t pxReadyTasksLists[ configMAX\_PRIORITIES ];\textcolor{comment}{/*< Prioritised ready tasks. */}}
\DoxyCodeLine{00341 PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t xDelayedTaskList1;                      \textcolor{comment}{/*< Delayed tasks. */}}
\DoxyCodeLine{00342 PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t xDelayedTaskList2;                      \textcolor{comment}{/*< Delayed tasks (two lists are used -\/ one for delays that have overflowed the current tick count. */}}
\DoxyCodeLine{00343 PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t * \textcolor{keyword}{volatile} pxDelayedTaskList;               \textcolor{comment}{/*< Points to the delayed task list currently being used. */}}
\DoxyCodeLine{00344 PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t * \textcolor{keyword}{volatile} pxOverflowDelayedTaskList;       \textcolor{comment}{/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */}}
\DoxyCodeLine{00345 PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t xPendingReadyList;                      \textcolor{comment}{/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */}}
\DoxyCodeLine{00346 }
\DoxyCodeLine{00347 \textcolor{preprocessor}{\#if( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{00348 }
\DoxyCodeLine{00349     PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t xTasksWaitingTermination;               \textcolor{comment}{/*< Tasks that have been deleted -\/ but their memory not yet freed. */}}
\DoxyCodeLine{00350     PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} UBaseType\_t uxDeletedTasksWaitingCleanUp = ( UBaseType\_t ) 0U;}
\DoxyCodeLine{00351 }
\DoxyCodeLine{00352 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00353 }
\DoxyCodeLine{00354 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{00355 }
\DoxyCodeLine{00356     PRIVILEGED\_DATA \textcolor{keyword}{static} List\_t xSuspendedTaskList;                 \textcolor{comment}{/*< Tasks that are currently suspended. */}}
\DoxyCodeLine{00357 }
\DoxyCodeLine{00358 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00359 }
\DoxyCodeLine{00360 \textcolor{comment}{/* Global POSIX errno. Its value is changed upon context switching to match}}
\DoxyCodeLine{00361 \textcolor{comment}{the errno of the currently running task. */}}
\DoxyCodeLine{00362 \textcolor{preprocessor}{\#if ( configUSE\_POSIX\_ERRNO == 1 )}}
\DoxyCodeLine{00363     \textcolor{keywordtype}{int} FreeRTOS\_errno = 0;}
\DoxyCodeLine{00364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00365 }
\DoxyCodeLine{00366 \textcolor{comment}{/* Other file private variables. -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00367 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} UBaseType\_t uxCurrentNumberOfTasks  = ( UBaseType\_t ) 0U;}
\DoxyCodeLine{00368 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} TickType\_t xTickCount               = ( TickType\_t ) configINITIAL\_TICK\_COUNT;}
\DoxyCodeLine{00369 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} UBaseType\_t uxTopReadyPriority      = tskIDLE\_PRIORITY;}
\DoxyCodeLine{00370 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} BaseType\_t xSchedulerRunning        = pdFALSE;}
\DoxyCodeLine{00371 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} UBaseType\_t uxPendedTicks           = ( UBaseType\_t ) 0U;}
\DoxyCodeLine{00372 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} BaseType\_t xYieldPending            = pdFALSE;}
\DoxyCodeLine{00373 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} BaseType\_t xNumOfOverflows          = ( BaseType\_t ) 0;}
\DoxyCodeLine{00374 PRIVILEGED\_DATA \textcolor{keyword}{static} UBaseType\_t uxTaskNumber                     = ( UBaseType\_t ) 0U;}
\DoxyCodeLine{00375 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} TickType\_t xNextTaskUnblockTime     = ( TickType\_t ) 0U; \textcolor{comment}{/* Initialised to portMAX\_DELAY before the scheduler starts. */}}
\DoxyCodeLine{00376 PRIVILEGED\_DATA \textcolor{keyword}{static} TaskHandle\_t xIdleTaskHandle                 = NULL;         \textcolor{comment}{/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */}}
\DoxyCodeLine{00377 }
\DoxyCodeLine{00378 \textcolor{comment}{/* Context switches are held pending while the scheduler is suspended.  Also,}}
\DoxyCodeLine{00379 \textcolor{comment}{interrupts must not manipulate the xStateListItem of a TCB, or any of the}}
\DoxyCodeLine{00380 \textcolor{comment}{lists the xStateListItem can be referenced from, if the scheduler is suspended.}}
\DoxyCodeLine{00381 \textcolor{comment}{If an interrupt needs to unblock a task while the scheduler is suspended then it}}
\DoxyCodeLine{00382 \textcolor{comment}{moves the task's event list item into the xPendingReadyList, ready for the}}
\DoxyCodeLine{00383 \textcolor{comment}{kernel to move the task from the pending ready list into the real ready list}}
\DoxyCodeLine{00384 \textcolor{comment}{when the scheduler is unsuspended.  The pending ready list itself can only be}}
\DoxyCodeLine{00385 \textcolor{comment}{accessed from a critical section. */}}
\DoxyCodeLine{00386 PRIVILEGED\_DATA \textcolor{keyword}{static} \textcolor{keyword}{volatile} UBaseType\_t uxSchedulerSuspended    = ( UBaseType\_t ) pdFALSE;}
\DoxyCodeLine{00387 }
\DoxyCodeLine{00388 \textcolor{preprocessor}{\#if ( configGENERATE\_RUN\_TIME\_STATS == 1 )}}
\DoxyCodeLine{00389 }
\DoxyCodeLine{00390     \textcolor{comment}{/* Do not move these variables to function scope as doing so prevents the}}
\DoxyCodeLine{00391 \textcolor{comment}{    code working with debuggers that need to remove the static qualifier. */}}
\DoxyCodeLine{00392     PRIVILEGED\_DATA \textcolor{keyword}{static} uint32\_t ulTaskSwitchedInTime = 0UL; \textcolor{comment}{/*< Holds the value of a timer/counter the last time a task was switched in. */}}
\DoxyCodeLine{00393     PRIVILEGED\_DATA \textcolor{keyword}{static} uint32\_t ulTotalRunTime = 0UL;       \textcolor{comment}{/*< Holds the total amount of execution time as defined by the run time counter clock. */}}
\DoxyCodeLine{00394 }
\DoxyCodeLine{00395 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397 \textcolor{comment}{/*lint -\/restore */}}
\DoxyCodeLine{00398 }
\DoxyCodeLine{00399 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401 \textcolor{comment}{/* Callback function prototypes. -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00402 \textcolor{preprocessor}{\#if(  configCHECK\_FOR\_STACK\_OVERFLOW > 0 )}}
\DoxyCodeLine{00403 }
\DoxyCodeLine{00404     \textcolor{keyword}{extern} \textcolor{keywordtype}{void} vApplicationStackOverflowHook( TaskHandle\_t xTask, \textcolor{keywordtype}{char} *pcTaskName );}
\DoxyCodeLine{00405 }
\DoxyCodeLine{00406 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00407 }
\DoxyCodeLine{00408 \textcolor{preprocessor}{\#if( configUSE\_TICK\_HOOK > 0 )}}
\DoxyCodeLine{00409 }
\DoxyCodeLine{00410     \textcolor{keyword}{extern} \textcolor{keywordtype}{void} vApplicationTickHook( \textcolor{keywordtype}{void} ); \textcolor{comment}{/*lint !e526 Symbol not defined as it is an application callback. */}}
\DoxyCodeLine{00411 }
\DoxyCodeLine{00412 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00413 }
\DoxyCodeLine{00414 \textcolor{preprocessor}{\#if( configSUPPORT\_STATIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{00415 }
\DoxyCodeLine{00416     \textcolor{keyword}{extern} \textcolor{keywordtype}{void} vApplicationGetIdleTaskMemory( StaticTask\_t **ppxIdleTaskTCBBuffer, StackType\_t **ppxIdleTaskStackBuffer, uint32\_t *pulIdleTaskStackSize ); \textcolor{comment}{/*lint !e526 Symbol not defined as it is an application callback. */}}
\DoxyCodeLine{00417 }
\DoxyCodeLine{00418 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00419 }
\DoxyCodeLine{00420 \textcolor{comment}{/* File private functions. -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00421 }
\DoxyCodeLine{00427 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{00428 }
\DoxyCodeLine{00429     \textcolor{keyword}{static} BaseType\_t prvTaskIsTaskSuspended( \textcolor{keyword}{const} TaskHandle\_t xTask ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00430 }
\DoxyCodeLine{00431 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00432 }
\DoxyCodeLine{00433 \textcolor{comment}{/*}}
\DoxyCodeLine{00434 \textcolor{comment}{ * Utility to ready all the lists used by the scheduler.  This is called}}
\DoxyCodeLine{00435 \textcolor{comment}{ * automatically upon the creation of the first task.}}
\DoxyCodeLine{00436 \textcolor{comment}{ */}}
\DoxyCodeLine{00437 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseTaskLists( \textcolor{keywordtype}{void} ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00438 }
\DoxyCodeLine{00439 \textcolor{comment}{/*}}
\DoxyCodeLine{00440 \textcolor{comment}{ * The idle task, which as all tasks is implemented as a never ending loop.}}
\DoxyCodeLine{00441 \textcolor{comment}{ * The idle task is automatically created and added to the ready lists upon}}
\DoxyCodeLine{00442 \textcolor{comment}{ * creation of the first user task.}}
\DoxyCodeLine{00443 \textcolor{comment}{ *}}
\DoxyCodeLine{00444 \textcolor{comment}{ * The portTASK\_FUNCTION\_PROTO() macro is used to allow port/compiler specific}}
\DoxyCodeLine{00445 \textcolor{comment}{ * language extensions.  The equivalent prototype for this function is:}}
\DoxyCodeLine{00446 \textcolor{comment}{ *}}
\DoxyCodeLine{00447 \textcolor{comment}{ * void prvIdleTask( void *pvParameters );}}
\DoxyCodeLine{00448 \textcolor{comment}{ *}}
\DoxyCodeLine{00449 \textcolor{comment}{ */}}
\DoxyCodeLine{00450 \textcolor{keyword}{static} portTASK\_FUNCTION\_PROTO( prvIdleTask, pvParameters );}
\DoxyCodeLine{00451 }
\DoxyCodeLine{00452 \textcolor{comment}{/*}}
\DoxyCodeLine{00453 \textcolor{comment}{ * Utility to free all memory allocated by the scheduler to hold a TCB,}}
\DoxyCodeLine{00454 \textcolor{comment}{ * including the stack pointed to by the TCB.}}
\DoxyCodeLine{00455 \textcolor{comment}{ *}}
\DoxyCodeLine{00456 \textcolor{comment}{ * This does not free memory allocated by the task itself (i.e. memory}}
\DoxyCodeLine{00457 \textcolor{comment}{ * allocated by calls to pvPortMalloc from within the tasks application code).}}
\DoxyCodeLine{00458 \textcolor{comment}{ */}}
\DoxyCodeLine{00459 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{00460 }
\DoxyCodeLine{00461     \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvDeleteTCB( TCB\_t *pxTCB ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00462 }
\DoxyCodeLine{00463 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00464 }
\DoxyCodeLine{00465 \textcolor{comment}{/*}}
\DoxyCodeLine{00466 \textcolor{comment}{ * Used only by the idle task.  This checks to see if anything has been placed}}
\DoxyCodeLine{00467 \textcolor{comment}{ * in the list of tasks waiting to be deleted.  If so the task is cleaned up}}
\DoxyCodeLine{00468 \textcolor{comment}{ * and its TCB deleted.}}
\DoxyCodeLine{00469 \textcolor{comment}{ */}}
\DoxyCodeLine{00470 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvCheckTasksWaitingTermination( \textcolor{keywordtype}{void} ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00471 }
\DoxyCodeLine{00472 \textcolor{comment}{/*}}
\DoxyCodeLine{00473 \textcolor{comment}{ * The currently executing task is entering the Blocked state.  Add the task to}}
\DoxyCodeLine{00474 \textcolor{comment}{ * either the current or the overflow delayed task list.}}
\DoxyCodeLine{00475 \textcolor{comment}{ */}}
\DoxyCodeLine{00476 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvAddCurrentTaskToDelayedList( TickType\_t xTicksToWait, \textcolor{keyword}{const} BaseType\_t xCanBlockIndefinitely ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00477 }
\DoxyCodeLine{00478 \textcolor{comment}{/*}}
\DoxyCodeLine{00479 \textcolor{comment}{ * Fills an TaskStatus\_t structure with information on each task that is}}
\DoxyCodeLine{00480 \textcolor{comment}{ * referenced from the pxList list (which may be a ready list, a delayed list,}}
\DoxyCodeLine{00481 \textcolor{comment}{ * a suspended list, etc.).}}
\DoxyCodeLine{00482 \textcolor{comment}{ *}}
\DoxyCodeLine{00483 \textcolor{comment}{ * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM}}
\DoxyCodeLine{00484 \textcolor{comment}{ * NORMAL APPLICATION CODE.}}
\DoxyCodeLine{00485 \textcolor{comment}{ */}}
\DoxyCodeLine{00486 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{00487 }
\DoxyCodeLine{00488     \textcolor{keyword}{static} UBaseType\_t prvListTasksWithinSingleList( TaskStatus\_t *pxTaskStatusArray, List\_t *pxList, eTaskState eState ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00489 }
\DoxyCodeLine{00490 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00491 }
\DoxyCodeLine{00492 \textcolor{comment}{/*}}
\DoxyCodeLine{00493 \textcolor{comment}{ * Searches pxList for a task with name pcNameToQuery -\/ returning a handle to}}
\DoxyCodeLine{00494 \textcolor{comment}{ * the task if it is found, or NULL if the task is not found.}}
\DoxyCodeLine{00495 \textcolor{comment}{ */}}
\DoxyCodeLine{00496 \textcolor{preprocessor}{\#if ( INCLUDE\_xTaskGetHandle == 1 )}}
\DoxyCodeLine{00497 }
\DoxyCodeLine{00498     \textcolor{keyword}{static} TCB\_t *prvSearchForNameWithinSingleList( List\_t *pxList, \textcolor{keyword}{const} \textcolor{keywordtype}{char} pcNameToQuery[] ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00499 }
\DoxyCodeLine{00500 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00501 }
\DoxyCodeLine{00502 \textcolor{comment}{/*}}
\DoxyCodeLine{00503 \textcolor{comment}{ * When a task is created, the stack of the task is filled with a known value.}}
\DoxyCodeLine{00504 \textcolor{comment}{ * This function determines the 'high water mark' of the task stack by}}
\DoxyCodeLine{00505 \textcolor{comment}{ * determining how much of the stack remains at the original preset value.}}
\DoxyCodeLine{00506 \textcolor{comment}{ */}}
\DoxyCodeLine{00507 \textcolor{preprocessor}{\#if ( ( configUSE\_TRACE\_FACILITY == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark2 == 1 ) )}}
\DoxyCodeLine{00508 }
\DoxyCodeLine{00509     \textcolor{keyword}{static} configSTACK\_DEPTH\_TYPE prvTaskCheckFreeStackSpace( \textcolor{keyword}{const} uint8\_t * pucStackByte ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00510 }
\DoxyCodeLine{00511 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00512 }
\DoxyCodeLine{00513 \textcolor{comment}{/*}}
\DoxyCodeLine{00514 \textcolor{comment}{ * Return the amount of time, in ticks, that will pass before the kernel will}}
\DoxyCodeLine{00515 \textcolor{comment}{ * next move a task from the Blocked state to the Running state.}}
\DoxyCodeLine{00516 \textcolor{comment}{ *}}
\DoxyCodeLine{00517 \textcolor{comment}{ * This conditional compilation should use inequality to 0, not equality to 1.}}
\DoxyCodeLine{00518 \textcolor{comment}{ * This is to ensure portSUPPRESS\_TICKS\_AND\_SLEEP() can be called when user}}
\DoxyCodeLine{00519 \textcolor{comment}{ * defined low power mode implementations require configUSE\_TICKLESS\_IDLE to be}}
\DoxyCodeLine{00520 \textcolor{comment}{ * set to a value other than 1.}}
\DoxyCodeLine{00521 \textcolor{comment}{ */}}
\DoxyCodeLine{00522 \textcolor{preprocessor}{\#if ( configUSE\_TICKLESS\_IDLE != 0 )}}
\DoxyCodeLine{00523 }
\DoxyCodeLine{00524     \textcolor{keyword}{static} TickType\_t prvGetExpectedIdleTime( \textcolor{keywordtype}{void} ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00525 }
\DoxyCodeLine{00526 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00527 }
\DoxyCodeLine{00528 \textcolor{comment}{/*}}
\DoxyCodeLine{00529 \textcolor{comment}{ * Set xNextTaskUnblockTime to the time at which the next Blocked state task}}
\DoxyCodeLine{00530 \textcolor{comment}{ * will exit the Blocked state.}}
\DoxyCodeLine{00531 \textcolor{comment}{ */}}
\DoxyCodeLine{00532 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvResetNextTaskUnblockTime( \textcolor{keywordtype}{void} );}
\DoxyCodeLine{00533 }
\DoxyCodeLine{00534 \textcolor{preprocessor}{\#if ( ( configUSE\_TRACE\_FACILITY == 1 ) \&\& ( configUSE\_STATS\_FORMATTING\_FUNCTIONS > 0 ) )}}
\DoxyCodeLine{00535 }
\DoxyCodeLine{00536     \textcolor{comment}{/*}}
\DoxyCodeLine{00537 \textcolor{comment}{     * Helper function used to pad task names with spaces when printing out}}
\DoxyCodeLine{00538 \textcolor{comment}{     * human readable tables of task information.}}
\DoxyCodeLine{00539 \textcolor{comment}{     */}}
\DoxyCodeLine{00540     \textcolor{keyword}{static} \textcolor{keywordtype}{char} *prvWriteNameToBuffer( \textcolor{keywordtype}{char} *pcBuffer, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pcTaskName ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00541 }
\DoxyCodeLine{00542 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00543 }
\DoxyCodeLine{00544 \textcolor{comment}{/*}}
\DoxyCodeLine{00545 \textcolor{comment}{ * Called after a Task\_t structure has been allocated either statically or}}
\DoxyCodeLine{00546 \textcolor{comment}{ * dynamically to fill in the structure's members.}}
\DoxyCodeLine{00547 \textcolor{comment}{ */}}
\DoxyCodeLine{00548 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseNewTask(   TaskFunction\_t pxTaskCode,}
\DoxyCodeLine{00549                                     \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} pcName,      \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{00550                                     \textcolor{keyword}{const} uint32\_t ulStackDepth,}
\DoxyCodeLine{00551                                     \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvParameters,}
\DoxyCodeLine{00552                                     UBaseType\_t uxPriority,}
\DoxyCodeLine{00553                                     TaskHandle\_t * \textcolor{keyword}{const} pxCreatedTask,}
\DoxyCodeLine{00554                                     TCB\_t *pxNewTCB,}
\DoxyCodeLine{00555                                     \textcolor{keyword}{const} MemoryRegion\_t * \textcolor{keyword}{const} xRegions ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00556 }
\DoxyCodeLine{00557 \textcolor{comment}{/*}}
\DoxyCodeLine{00558 \textcolor{comment}{ * Called after a new task has been created and initialised to place the task}}
\DoxyCodeLine{00559 \textcolor{comment}{ * under the control of the scheduler.}}
\DoxyCodeLine{00560 \textcolor{comment}{ */}}
\DoxyCodeLine{00561 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvAddNewTaskToReadyList( TCB\_t *pxNewTCB ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00562 }
\DoxyCodeLine{00563 \textcolor{comment}{/*}}
\DoxyCodeLine{00564 \textcolor{comment}{ * freertos\_tasks\_c\_additions\_init() should only be called if the user definable}}
\DoxyCodeLine{00565 \textcolor{comment}{ * macro FREERTOS\_TASKS\_C\_ADDITIONS\_INIT() is defined, as that is the only macro}}
\DoxyCodeLine{00566 \textcolor{comment}{ * called by the function.}}
\DoxyCodeLine{00567 \textcolor{comment}{ */}}
\DoxyCodeLine{00568 \textcolor{preprocessor}{\#ifdef FREERTOS\_TASKS\_C\_ADDITIONS\_INIT}}
\DoxyCodeLine{00569 }
\DoxyCodeLine{00570     \textcolor{keyword}{static} \textcolor{keywordtype}{void} freertos\_tasks\_c\_additions\_init( \textcolor{keywordtype}{void} ) PRIVILEGED\_FUNCTION;}
\DoxyCodeLine{00571 }
\DoxyCodeLine{00572 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00573 }
\DoxyCodeLine{00574 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00575 }
\DoxyCodeLine{00576 \textcolor{preprocessor}{\#if( configSUPPORT\_STATIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{00577 }
\DoxyCodeLine{00578     TaskHandle\_t xTaskCreateStatic( TaskFunction\_t pxTaskCode,}
\DoxyCodeLine{00579                                     \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} pcName,      \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{00580                                     \textcolor{keyword}{const} uint32\_t ulStackDepth,}
\DoxyCodeLine{00581                                     \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvParameters,}
\DoxyCodeLine{00582                                     UBaseType\_t uxPriority,}
\DoxyCodeLine{00583                                     StackType\_t * \textcolor{keyword}{const} puxStackBuffer,}
\DoxyCodeLine{00584                                     StaticTask\_t * \textcolor{keyword}{const} pxTaskBuffer )}
\DoxyCodeLine{00585     \{}
\DoxyCodeLine{00586     TCB\_t *pxNewTCB;}
\DoxyCodeLine{00587     TaskHandle\_t xReturn;}
\DoxyCodeLine{00588 }
\DoxyCodeLine{00589         configASSERT( puxStackBuffer != NULL );}
\DoxyCodeLine{00590         configASSERT( pxTaskBuffer != NULL );}
\DoxyCodeLine{00591 }
\DoxyCodeLine{00592 \textcolor{preprocessor}{        \#if( configASSERT\_DEFINED == 1 )}}
\DoxyCodeLine{00593         \{}
\DoxyCodeLine{00594             \textcolor{comment}{/* Sanity check that the size of the structure used to declare a}}
\DoxyCodeLine{00595 \textcolor{comment}{            variable of type StaticTask\_t equals the size of the real task}}
\DoxyCodeLine{00596 \textcolor{comment}{            structure. */}}
\DoxyCodeLine{00597             \textcolor{keyword}{volatile} \textcolor{keywordtype}{size\_t} xSize = \textcolor{keyword}{sizeof}( StaticTask\_t );}
\DoxyCodeLine{00598             configASSERT( xSize == \textcolor{keyword}{sizeof}( TCB\_t ) );}
\DoxyCodeLine{00599             ( void ) xSize; \textcolor{comment}{/* Prevent lint warning when configASSERT() is not used. */}}
\DoxyCodeLine{00600         \}}
\DoxyCodeLine{00601 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configASSERT\_DEFINED */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00602 }
\DoxyCodeLine{00603 }
\DoxyCodeLine{00604         \textcolor{keywordflow}{if}( ( pxTaskBuffer != NULL ) \&\& ( puxStackBuffer != NULL ) )}
\DoxyCodeLine{00605         \{}
\DoxyCodeLine{00606             \textcolor{comment}{/* The memory used for the task's TCB and stack are passed into this}}
\DoxyCodeLine{00607 \textcolor{comment}{            function -\/ use them. */}}
\DoxyCodeLine{00608             pxNewTCB = ( TCB\_t * ) pxTaskBuffer; \textcolor{comment}{/*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */}}
\DoxyCodeLine{00609             pxNewTCB-\/>pxStack = ( StackType\_t * ) puxStackBuffer;}
\DoxyCodeLine{00610 }
\DoxyCodeLine{00611 \textcolor{preprocessor}{            \#if( tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE != 0 ) }\textcolor{comment}{/*lint !e731 !e9029 Macro has been consolidated for readability reasons. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00612             \{}
\DoxyCodeLine{00613                 \textcolor{comment}{/* Tasks can be created statically or dynamically, so note this}}
\DoxyCodeLine{00614 \textcolor{comment}{                task was created statically in case the task is later deleted. */}}
\DoxyCodeLine{00615                 pxNewTCB-\/>ucStaticallyAllocated = tskSTATICALLY\_ALLOCATED\_STACK\_AND\_TCB;}
\DoxyCodeLine{00616             \}}
\DoxyCodeLine{00617 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00618 }
\DoxyCodeLine{00619             prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, \&xReturn, pxNewTCB, NULL );}
\DoxyCodeLine{00620             prvAddNewTaskToReadyList( pxNewTCB );}
\DoxyCodeLine{00621         \}}
\DoxyCodeLine{00622         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00623         \{}
\DoxyCodeLine{00624             xReturn = NULL;}
\DoxyCodeLine{00625         \}}
\DoxyCodeLine{00626 }
\DoxyCodeLine{00627         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{00628     \}}
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* SUPPORT\_STATIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00631 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00632 }
\DoxyCodeLine{00633 \textcolor{preprocessor}{\#if( ( portUSING\_MPU\_WRAPPERS == 1 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{00634 }
\DoxyCodeLine{00635     BaseType\_t xTaskCreateRestrictedStatic( \textcolor{keyword}{const} TaskParameters\_t * \textcolor{keyword}{const} pxTaskDefinition, TaskHandle\_t *pxCreatedTask )}
\DoxyCodeLine{00636     \{}
\DoxyCodeLine{00637     TCB\_t *pxNewTCB;}
\DoxyCodeLine{00638     BaseType\_t xReturn = errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY;}
\DoxyCodeLine{00639 }
\DoxyCodeLine{00640         configASSERT( pxTaskDefinition-\/>puxStackBuffer != NULL );}
\DoxyCodeLine{00641         configASSERT( pxTaskDefinition-\/>pxTaskBuffer != NULL );}
\DoxyCodeLine{00642 }
\DoxyCodeLine{00643         \textcolor{keywordflow}{if}( ( pxTaskDefinition-\/>puxStackBuffer != NULL ) \&\& ( pxTaskDefinition-\/>pxTaskBuffer != NULL ) )}
\DoxyCodeLine{00644         \{}
\DoxyCodeLine{00645             \textcolor{comment}{/* Allocate space for the TCB.  Where the memory comes from depends}}
\DoxyCodeLine{00646 \textcolor{comment}{            on the implementation of the port malloc function and whether or}}
\DoxyCodeLine{00647 \textcolor{comment}{            not static allocation is being used. */}}
\DoxyCodeLine{00648             pxNewTCB = ( TCB\_t * ) pxTaskDefinition-\/>pxTaskBuffer;}
\DoxyCodeLine{00649 }
\DoxyCodeLine{00650             \textcolor{comment}{/* Store the stack location in the TCB. */}}
\DoxyCodeLine{00651             pxNewTCB-\/>pxStack = pxTaskDefinition-\/>puxStackBuffer;}
\DoxyCodeLine{00652 }
\DoxyCodeLine{00653             \#\textcolor{keywordflow}{if}( tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE != 0 )}
\DoxyCodeLine{00654             \{}
\DoxyCodeLine{00655                 \textcolor{comment}{/* Tasks can be created statically or dynamically, so note this}}
\DoxyCodeLine{00656 \textcolor{comment}{                task was created statically in case the task is later deleted. */}}
\DoxyCodeLine{00657                 pxNewTCB-\/>ucStaticallyAllocated = tskSTATICALLY\_ALLOCATED\_STACK\_AND\_TCB;}
\DoxyCodeLine{00658             \}}
\DoxyCodeLine{00659 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00660 }
\DoxyCodeLine{00661             prvInitialiseNewTask(   pxTaskDefinition-\/>pvTaskCode,}
\DoxyCodeLine{00662                                     pxTaskDefinition-\/>pcName,}
\DoxyCodeLine{00663                                     ( uint32\_t ) pxTaskDefinition-\/>usStackDepth,}
\DoxyCodeLine{00664                                     pxTaskDefinition-\/>pvParameters,}
\DoxyCodeLine{00665                                     pxTaskDefinition-\/>uxPriority,}
\DoxyCodeLine{00666                                     pxCreatedTask, pxNewTCB,}
\DoxyCodeLine{00667                                     pxTaskDefinition-\/>xRegions );}
\DoxyCodeLine{00668 }
\DoxyCodeLine{00669             prvAddNewTaskToReadyList( pxNewTCB );}
\DoxyCodeLine{00670             xReturn = pdPASS;}
\DoxyCodeLine{00671         \}}
\DoxyCodeLine{00672 }
\DoxyCodeLine{00673         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{00674     \}}
\DoxyCodeLine{00675 }
\DoxyCodeLine{00676 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( portUSING\_MPU\_WRAPPERS == 1 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00677 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00678 }
\DoxyCodeLine{00679 \textcolor{preprocessor}{\#if( ( portUSING\_MPU\_WRAPPERS == 1 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{00680 }
\DoxyCodeLine{00681     BaseType\_t xTaskCreateRestricted( \textcolor{keyword}{const} TaskParameters\_t * \textcolor{keyword}{const} pxTaskDefinition, TaskHandle\_t *pxCreatedTask )}
\DoxyCodeLine{00682     \{}
\DoxyCodeLine{00683     TCB\_t *pxNewTCB;}
\DoxyCodeLine{00684     BaseType\_t xReturn = errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY;}
\DoxyCodeLine{00685 }
\DoxyCodeLine{00686         configASSERT( pxTaskDefinition-\/>puxStackBuffer );}
\DoxyCodeLine{00687 }
\DoxyCodeLine{00688         \textcolor{keywordflow}{if}( pxTaskDefinition-\/>puxStackBuffer != NULL )}
\DoxyCodeLine{00689         \{}
\DoxyCodeLine{00690             \textcolor{comment}{/* Allocate space for the TCB.  Where the memory comes from depends}}
\DoxyCodeLine{00691 \textcolor{comment}{            on the implementation of the port malloc function and whether or}}
\DoxyCodeLine{00692 \textcolor{comment}{            not static allocation is being used. */}}
\DoxyCodeLine{00693             pxNewTCB = ( TCB\_t * ) pvPortMalloc( \textcolor{keyword}{sizeof}( TCB\_t ) );}
\DoxyCodeLine{00694 }
\DoxyCodeLine{00695             \textcolor{keywordflow}{if}( pxNewTCB != NULL )}
\DoxyCodeLine{00696             \{}
\DoxyCodeLine{00697                 \textcolor{comment}{/* Store the stack location in the TCB. */}}
\DoxyCodeLine{00698                 pxNewTCB-\/>pxStack = pxTaskDefinition-\/>puxStackBuffer;}
\DoxyCodeLine{00699 }
\DoxyCodeLine{00700 \textcolor{preprocessor}{                \#if( tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE != 0 )}}
\DoxyCodeLine{00701                 \{}
\DoxyCodeLine{00702                     \textcolor{comment}{/* Tasks can be created statically or dynamically, so note}}
\DoxyCodeLine{00703 \textcolor{comment}{                    this task had a statically allocated stack in case it is}}
\DoxyCodeLine{00704 \textcolor{comment}{                    later deleted.  The TCB was allocated dynamically. */}}
\DoxyCodeLine{00705                     pxNewTCB-\/>ucStaticallyAllocated = tskSTATICALLY\_ALLOCATED\_STACK\_ONLY;}
\DoxyCodeLine{00706                 \}}
\DoxyCodeLine{00707 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00708 }
\DoxyCodeLine{00709                 prvInitialiseNewTask(   pxTaskDefinition-\/>pvTaskCode,}
\DoxyCodeLine{00710                                         pxTaskDefinition-\/>pcName,}
\DoxyCodeLine{00711                                         ( uint32\_t ) pxTaskDefinition-\/>usStackDepth,}
\DoxyCodeLine{00712                                         pxTaskDefinition-\/>pvParameters,}
\DoxyCodeLine{00713                                         pxTaskDefinition-\/>uxPriority,}
\DoxyCodeLine{00714                                         pxCreatedTask, pxNewTCB,}
\DoxyCodeLine{00715                                         pxTaskDefinition-\/>xRegions );}
\DoxyCodeLine{00716 }
\DoxyCodeLine{00717                 prvAddNewTaskToReadyList( pxNewTCB );}
\DoxyCodeLine{00718                 xReturn = pdPASS;}
\DoxyCodeLine{00719             \}}
\DoxyCodeLine{00720         \}}
\DoxyCodeLine{00721 }
\DoxyCodeLine{00722         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{00723     \}}
\DoxyCodeLine{00724 }
\DoxyCodeLine{00725 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* portUSING\_MPU\_WRAPPERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00726 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00727 }
\DoxyCodeLine{00728 \textcolor{preprocessor}{\#if( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{00729 }
\DoxyCodeLine{00730     BaseType\_t xTaskCreate( TaskFunction\_t pxTaskCode,}
\DoxyCodeLine{00731                             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} pcName,      \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{00732                             \textcolor{keyword}{const} configSTACK\_DEPTH\_TYPE usStackDepth,}
\DoxyCodeLine{00733                             \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvParameters,}
\DoxyCodeLine{00734                             UBaseType\_t uxPriority,}
\DoxyCodeLine{00735                             TaskHandle\_t * \textcolor{keyword}{const} pxCreatedTask )}
\DoxyCodeLine{00736     \{}
\DoxyCodeLine{00737     TCB\_t *pxNewTCB;}
\DoxyCodeLine{00738     BaseType\_t xReturn;}
\DoxyCodeLine{00739 }
\DoxyCodeLine{00740         \textcolor{comment}{/* If the stack grows down then allocate the stack then the TCB so the stack}}
\DoxyCodeLine{00741 \textcolor{comment}{        does not grow into the TCB.  Likewise if the stack grows up then allocate}}
\DoxyCodeLine{00742 \textcolor{comment}{        the TCB then the stack. */}}
\DoxyCodeLine{00743 \textcolor{preprocessor}{        \#if( portSTACK\_GROWTH > 0 )}}
\DoxyCodeLine{00744         \{}
\DoxyCodeLine{00745             \textcolor{comment}{/* Allocate space for the TCB.  Where the memory comes from depends on}}
\DoxyCodeLine{00746 \textcolor{comment}{            the implementation of the port malloc function and whether or not static}}
\DoxyCodeLine{00747 \textcolor{comment}{            allocation is being used. */}}
\DoxyCodeLine{00748             pxNewTCB = ( TCB\_t * ) pvPortMalloc( \textcolor{keyword}{sizeof}( TCB\_t ) );}
\DoxyCodeLine{00749 }
\DoxyCodeLine{00750             \textcolor{keywordflow}{if}( pxNewTCB != NULL )}
\DoxyCodeLine{00751             \{}
\DoxyCodeLine{00752                 \textcolor{comment}{/* Allocate space for the stack used by the task being created.}}
\DoxyCodeLine{00753 \textcolor{comment}{                The base of the stack memory stored in the TCB so the task can}}
\DoxyCodeLine{00754 \textcolor{comment}{                be deleted later if required. */}}
\DoxyCodeLine{00755                 pxNewTCB-\/>pxStack = ( StackType\_t * ) pvPortMalloc( ( ( ( \textcolor{keywordtype}{size\_t} ) usStackDepth ) * \textcolor{keyword}{sizeof}( StackType\_t ) ) ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{00756 }
\DoxyCodeLine{00757                 \textcolor{keywordflow}{if}( pxNewTCB-\/>pxStack == NULL )}
\DoxyCodeLine{00758                 \{}
\DoxyCodeLine{00759                     \textcolor{comment}{/* Could not allocate the stack.  Delete the allocated TCB. */}}
\DoxyCodeLine{00760                     vPortFree( pxNewTCB );}
\DoxyCodeLine{00761                     pxNewTCB = NULL;}
\DoxyCodeLine{00762                 \}}
\DoxyCodeLine{00763             \}}
\DoxyCodeLine{00764         \}}
\DoxyCodeLine{00765 \textcolor{preprocessor}{        \#else }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00766         \{}
\DoxyCodeLine{00767         StackType\_t *pxStack;}
\DoxyCodeLine{00768 }
\DoxyCodeLine{00769             \textcolor{comment}{/* Allocate space for the stack used by the task being created. */}}
\DoxyCodeLine{00770             pxStack = pvPortMalloc( ( ( ( \textcolor{keywordtype}{size\_t} ) usStackDepth ) * \textcolor{keyword}{sizeof}( StackType\_t ) ) ); \textcolor{comment}{/*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */}}
\DoxyCodeLine{00771 }
\DoxyCodeLine{00772             \textcolor{keywordflow}{if}( pxStack != NULL )}
\DoxyCodeLine{00773             \{}
\DoxyCodeLine{00774                 \textcolor{comment}{/* Allocate space for the TCB. */}}
\DoxyCodeLine{00775                 pxNewTCB = ( TCB\_t * ) pvPortMalloc( \textcolor{keyword}{sizeof}( TCB\_t ) ); \textcolor{comment}{/*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB\_t is always a pointer to the task's stack. */}}
\DoxyCodeLine{00776 }
\DoxyCodeLine{00777                 \textcolor{keywordflow}{if}( pxNewTCB != NULL )}
\DoxyCodeLine{00778                 \{}
\DoxyCodeLine{00779                     \textcolor{comment}{/* Store the stack location in the TCB. */}}
\DoxyCodeLine{00780                     pxNewTCB-\/>pxStack = pxStack;}
\DoxyCodeLine{00781                 \}}
\DoxyCodeLine{00782                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{00783                 \{}
\DoxyCodeLine{00784                     \textcolor{comment}{/* The stack cannot be used as the TCB was not created.  Free}}
\DoxyCodeLine{00785 \textcolor{comment}{                    it again. */}}
\DoxyCodeLine{00786                     vPortFree( pxStack );}
\DoxyCodeLine{00787                 \}}
\DoxyCodeLine{00788             \}}
\DoxyCodeLine{00789             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00790             \{}
\DoxyCodeLine{00791                 pxNewTCB = NULL;}
\DoxyCodeLine{00792             \}}
\DoxyCodeLine{00793         \}}
\DoxyCodeLine{00794 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00795 }
\DoxyCodeLine{00796         \textcolor{keywordflow}{if}( pxNewTCB != NULL )}
\DoxyCodeLine{00797         \{}
\DoxyCodeLine{00798 \textcolor{preprocessor}{            \#if( tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE != 0 ) }\textcolor{comment}{/*lint !e9029 !e731 Macro has been consolidated for readability reasons. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00799             \{}
\DoxyCodeLine{00800                 \textcolor{comment}{/* Tasks can be created statically or dynamically, so note this}}
\DoxyCodeLine{00801 \textcolor{comment}{                task was created dynamically in case it is later deleted. */}}
\DoxyCodeLine{00802                 pxNewTCB-\/>ucStaticallyAllocated = tskDYNAMICALLY\_ALLOCATED\_STACK\_AND\_TCB;}
\DoxyCodeLine{00803             \}}
\DoxyCodeLine{00804 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00805 }
\DoxyCodeLine{00806             prvInitialiseNewTask( pxTaskCode, pcName, ( uint32\_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );}
\DoxyCodeLine{00807             prvAddNewTaskToReadyList( pxNewTCB );}
\DoxyCodeLine{00808             xReturn = pdPASS;}
\DoxyCodeLine{00809         \}}
\DoxyCodeLine{00810         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00811         \{}
\DoxyCodeLine{00812             xReturn = errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY;}
\DoxyCodeLine{00813         \}}
\DoxyCodeLine{00814 }
\DoxyCodeLine{00815         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{00816     \}}
\DoxyCodeLine{00817 }
\DoxyCodeLine{00818 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configSUPPORT\_DYNAMIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00819 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00820 }
\DoxyCodeLine{00821 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseNewTask(   TaskFunction\_t pxTaskCode,}
\DoxyCodeLine{00822                                     \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} pcName,      \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{00823                                     \textcolor{keyword}{const} uint32\_t ulStackDepth,}
\DoxyCodeLine{00824                                     \textcolor{keywordtype}{void} * \textcolor{keyword}{const} pvParameters,}
\DoxyCodeLine{00825                                     UBaseType\_t uxPriority,}
\DoxyCodeLine{00826                                     TaskHandle\_t * \textcolor{keyword}{const} pxCreatedTask,}
\DoxyCodeLine{00827                                     TCB\_t *pxNewTCB,}
\DoxyCodeLine{00828                                     \textcolor{keyword}{const} MemoryRegion\_t * \textcolor{keyword}{const} xRegions )}
\DoxyCodeLine{00829 \{}
\DoxyCodeLine{00830 StackType\_t *pxTopOfStack;}
\DoxyCodeLine{00831 UBaseType\_t x;}
\DoxyCodeLine{00832 }
\DoxyCodeLine{00833 \textcolor{preprocessor}{    \#if( portUSING\_MPU\_WRAPPERS == 1 )}}
\DoxyCodeLine{00834         \textcolor{comment}{/* Should the task be created in privileged mode? */}}
\DoxyCodeLine{00835         BaseType\_t xRunPrivileged;}
\DoxyCodeLine{00836         \textcolor{keywordflow}{if}( ( uxPriority \& portPRIVILEGE\_BIT ) != 0U )}
\DoxyCodeLine{00837         \{}
\DoxyCodeLine{00838             xRunPrivileged = pdTRUE;}
\DoxyCodeLine{00839         \}}
\DoxyCodeLine{00840         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00841         \{}
\DoxyCodeLine{00842             xRunPrivileged = pdFALSE;}
\DoxyCodeLine{00843         \}}
\DoxyCodeLine{00844         uxPriority \&= \string~portPRIVILEGE\_BIT;}
\DoxyCodeLine{00845 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* portUSING\_MPU\_WRAPPERS == 1 */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00846 }
\DoxyCodeLine{00847     \textcolor{comment}{/* Avoid dependency on memset() if it is not required. */}}
\DoxyCodeLine{00848 \textcolor{preprocessor}{    \#if( tskSET\_NEW\_STACKS\_TO\_KNOWN\_VALUE == 1 )}}
\DoxyCodeLine{00849     \{}
\DoxyCodeLine{00850         \textcolor{comment}{/* Fill the stack with a known value to assist debugging. */}}
\DoxyCodeLine{00851         ( void ) memset( pxNewTCB-\/>pxStack, ( \textcolor{keywordtype}{int} ) tskSTACK\_FILL\_BYTE, ( size\_t ) ulStackDepth * \textcolor{keyword}{sizeof}( StackType\_t ) );}
\DoxyCodeLine{00852     \}}
\DoxyCodeLine{00853 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* tskSET\_NEW\_STACKS\_TO\_KNOWN\_VALUE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00854 }
\DoxyCodeLine{00855     \textcolor{comment}{/* Calculate the top of stack address.  This depends on whether the stack}}
\DoxyCodeLine{00856 \textcolor{comment}{    grows from high memory to low (as per the 80x86) or vice versa.}}
\DoxyCodeLine{00857 \textcolor{comment}{    portSTACK\_GROWTH is used to make the result positive or negative as required}}
\DoxyCodeLine{00858 \textcolor{comment}{    by the port. */}}
\DoxyCodeLine{00859 \textcolor{preprocessor}{    \#if( portSTACK\_GROWTH < 0 )}}
\DoxyCodeLine{00860     \{}
\DoxyCodeLine{00861         pxTopOfStack = \&( pxNewTCB-\/>pxStack[ ulStackDepth -\/ ( uint32\_t ) 1 ] );}
\DoxyCodeLine{00862         pxTopOfStack = ( StackType\_t * ) ( ( ( portPOINTER\_SIZE\_TYPE ) pxTopOfStack ) \& ( \string~( ( portPOINTER\_SIZE\_TYPE ) portBYTE\_ALIGNMENT\_MASK ) ) ); \textcolor{comment}{/*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER\_SIZE\_TYPE type.  Checked by assert(). */}}
\DoxyCodeLine{00863 }
\DoxyCodeLine{00864         \textcolor{comment}{/* Check the alignment of the calculated top of stack is correct. */}}
\DoxyCodeLine{00865         configASSERT( ( ( ( portPOINTER\_SIZE\_TYPE ) pxTopOfStack \& ( portPOINTER\_SIZE\_TYPE ) portBYTE\_ALIGNMENT\_MASK ) == 0UL ) );}
\DoxyCodeLine{00866 }
\DoxyCodeLine{00867 \textcolor{preprocessor}{        \#if( configRECORD\_STACK\_HIGH\_ADDRESS == 1 )}}
\DoxyCodeLine{00868         \{}
\DoxyCodeLine{00869             \textcolor{comment}{/* Also record the stack's high address, which may assist}}
\DoxyCodeLine{00870 \textcolor{comment}{            debugging. */}}
\DoxyCodeLine{00871             pxNewTCB-\/>pxEndOfStack = pxTopOfStack;}
\DoxyCodeLine{00872         \}}
\DoxyCodeLine{00873 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configRECORD\_STACK\_HIGH\_ADDRESS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00874     \}}
\DoxyCodeLine{00875 \textcolor{preprocessor}{    \#else }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00876     \{}
\DoxyCodeLine{00877         pxTopOfStack = pxNewTCB-\/>pxStack;}
\DoxyCodeLine{00878 }
\DoxyCodeLine{00879         \textcolor{comment}{/* Check the alignment of the stack buffer is correct. */}}
\DoxyCodeLine{00880         configASSERT( ( ( ( portPOINTER\_SIZE\_TYPE ) pxNewTCB-\/>pxStack \& ( portPOINTER\_SIZE\_TYPE ) portBYTE\_ALIGNMENT\_MASK ) == 0UL ) );}
\DoxyCodeLine{00881 }
\DoxyCodeLine{00882         \textcolor{comment}{/* The other extreme of the stack space is required if stack checking is}}
\DoxyCodeLine{00883 \textcolor{comment}{        performed. */}}
\DoxyCodeLine{00884         pxNewTCB-\/>pxEndOfStack = pxNewTCB-\/>pxStack + ( ulStackDepth -\/ ( uint32\_t ) 1 );}
\DoxyCodeLine{00885     \}}
\DoxyCodeLine{00886 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00887 }
\DoxyCodeLine{00888     \textcolor{comment}{/* Store the task name in the TCB. */}}
\DoxyCodeLine{00889     \textcolor{keywordflow}{if}( pcName != NULL )}
\DoxyCodeLine{00890     \{}
\DoxyCodeLine{00891         \textcolor{keywordflow}{for}( x = ( UBaseType\_t ) 0; x < ( UBaseType\_t ) configMAX\_TASK\_NAME\_LEN; x++ )}
\DoxyCodeLine{00892         \{}
\DoxyCodeLine{00893             pxNewTCB-\/>pcTaskName[ x ] = pcName[ x ];}
\DoxyCodeLine{00894 }
\DoxyCodeLine{00895             \textcolor{comment}{/* Don't copy all configMAX\_TASK\_NAME\_LEN if the string is shorter than}}
\DoxyCodeLine{00896 \textcolor{comment}{            configMAX\_TASK\_NAME\_LEN characters just in case the memory after the}}
\DoxyCodeLine{00897 \textcolor{comment}{            string is not accessible (extremely unlikely). */}}
\DoxyCodeLine{00898             \textcolor{keywordflow}{if}( pcName[ x ] == ( \textcolor{keywordtype}{char} ) 0x00 )}
\DoxyCodeLine{00899             \{}
\DoxyCodeLine{00900                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{00901             \}}
\DoxyCodeLine{00902             \textcolor{keywordflow}{else}}
\DoxyCodeLine{00903             \{}
\DoxyCodeLine{00904                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00905             \}}
\DoxyCodeLine{00906         \}}
\DoxyCodeLine{00907 }
\DoxyCodeLine{00908         \textcolor{comment}{/* Ensure the name string is terminated in the case that the string length}}
\DoxyCodeLine{00909 \textcolor{comment}{        was greater or equal to configMAX\_TASK\_NAME\_LEN. */}}
\DoxyCodeLine{00910         pxNewTCB-\/>pcTaskName[ configMAX\_TASK\_NAME\_LEN -\/ 1 ] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00911     \}}
\DoxyCodeLine{00912     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00913     \{}
\DoxyCodeLine{00914         \textcolor{comment}{/* The task has not been given a name, so just ensure there is a NULL}}
\DoxyCodeLine{00915 \textcolor{comment}{        terminator when it is read out. */}}
\DoxyCodeLine{00916         pxNewTCB-\/>pcTaskName[ 0 ] = 0x00;}
\DoxyCodeLine{00917     \}}
\DoxyCodeLine{00918 }
\DoxyCodeLine{00919     \textcolor{comment}{/* This is used as an array index so must ensure it's not too large.  First}}
\DoxyCodeLine{00920 \textcolor{comment}{    remove the privilege bit if one is present. */}}
\DoxyCodeLine{00921     \textcolor{keywordflow}{if}( uxPriority >= ( UBaseType\_t ) configMAX\_PRIORITIES )}
\DoxyCodeLine{00922     \{}
\DoxyCodeLine{00923         uxPriority = ( UBaseType\_t ) configMAX\_PRIORITIES -\/ ( UBaseType\_t ) 1U;}
\DoxyCodeLine{00924     \}}
\DoxyCodeLine{00925     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00926     \{}
\DoxyCodeLine{00927         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{00928     \}}
\DoxyCodeLine{00929 }
\DoxyCodeLine{00930     pxNewTCB-\/>uxPriority = uxPriority;}
\DoxyCodeLine{00931 \textcolor{preprocessor}{    \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{00932     \{}
\DoxyCodeLine{00933         pxNewTCB-\/>uxBasePriority = uxPriority;}
\DoxyCodeLine{00934         pxNewTCB-\/>uxMutexesHeld = 0;}
\DoxyCodeLine{00935     \}}
\DoxyCodeLine{00936 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00937 }
\DoxyCodeLine{00938     vListInitialiseItem( \&( pxNewTCB-\/>xStateListItem ) );}
\DoxyCodeLine{00939     vListInitialiseItem( \&( pxNewTCB-\/>xEventListItem ) );}
\DoxyCodeLine{00940 }
\DoxyCodeLine{00941     \textcolor{comment}{/* Set the pxNewTCB as a link back from the ListItem\_t.  This is so we can get}}
\DoxyCodeLine{00942 \textcolor{comment}{    back to the containing TCB from a generic item in a list. */}}
\DoxyCodeLine{00943     listSET\_LIST\_ITEM\_OWNER( \&( pxNewTCB-\/>xStateListItem ), pxNewTCB );}
\DoxyCodeLine{00944 }
\DoxyCodeLine{00945     \textcolor{comment}{/* Event lists are always in priority order. */}}
\DoxyCodeLine{00946     listSET\_LIST\_ITEM\_VALUE( \&( pxNewTCB-\/>xEventListItem ), ( TickType\_t ) configMAX\_PRIORITIES -\/ ( TickType\_t ) uxPriority ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{00947     listSET\_LIST\_ITEM\_OWNER( \&( pxNewTCB-\/>xEventListItem ), pxNewTCB );}
\DoxyCodeLine{00948 }
\DoxyCodeLine{00949 \textcolor{preprocessor}{    \#if ( portCRITICAL\_NESTING\_IN\_TCB == 1 )}}
\DoxyCodeLine{00950     \{}
\DoxyCodeLine{00951         pxNewTCB-\/>uxCriticalNesting = ( UBaseType\_t ) 0U;}
\DoxyCodeLine{00952     \}}
\DoxyCodeLine{00953 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* portCRITICAL\_NESTING\_IN\_TCB */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00954 }
\DoxyCodeLine{00955 \textcolor{preprocessor}{    \#if ( configUSE\_APPLICATION\_TASK\_TAG == 1 )}}
\DoxyCodeLine{00956     \{}
\DoxyCodeLine{00957         pxNewTCB-\/>pxTaskTag = NULL;}
\DoxyCodeLine{00958     \}}
\DoxyCodeLine{00959 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configUSE\_APPLICATION\_TASK\_TAG */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00960 }
\DoxyCodeLine{00961 \textcolor{preprocessor}{    \#if ( configGENERATE\_RUN\_TIME\_STATS == 1 )}}
\DoxyCodeLine{00962     \{}
\DoxyCodeLine{00963         pxNewTCB-\/>ulRunTimeCounter = 0UL;}
\DoxyCodeLine{00964     \}}
\DoxyCodeLine{00965 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configGENERATE\_RUN\_TIME\_STATS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00966 }
\DoxyCodeLine{00967 \textcolor{preprocessor}{    \#if ( portUSING\_MPU\_WRAPPERS == 1 )}}
\DoxyCodeLine{00968     \{}
\DoxyCodeLine{00969         vPortStoreTaskMPUSettings( \&( pxNewTCB-\/>xMPUSettings ), xRegions, pxNewTCB-\/>pxStack, ulStackDepth );}
\DoxyCodeLine{00970     \}}
\DoxyCodeLine{00971 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{00972     \{}
\DoxyCodeLine{00973         \textcolor{comment}{/* Avoid compiler warning about unreferenced parameter. */}}
\DoxyCodeLine{00974         ( void ) xRegions;}
\DoxyCodeLine{00975     \}}
\DoxyCodeLine{00976 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00977 }
\DoxyCodeLine{00978 \textcolor{preprocessor}{    \#if( configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS != 0 )}}
\DoxyCodeLine{00979     \{}
\DoxyCodeLine{00980         \textcolor{keywordflow}{for}( x = 0; x < ( UBaseType\_t ) configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS; x++ )}
\DoxyCodeLine{00981         \{}
\DoxyCodeLine{00982             pxNewTCB-\/>pvThreadLocalStoragePointers[ x ] = NULL;}
\DoxyCodeLine{00983         \}}
\DoxyCodeLine{00984     \}}
\DoxyCodeLine{00985 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00986 }
\DoxyCodeLine{00987 \textcolor{preprocessor}{    \#if ( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{00988     \{}
\DoxyCodeLine{00989         pxNewTCB-\/>ulNotifiedValue = 0;}
\DoxyCodeLine{00990         pxNewTCB-\/>ucNotifyState = taskNOT\_WAITING\_NOTIFICATION;}
\DoxyCodeLine{00991     \}}
\DoxyCodeLine{00992 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{00993 }
\DoxyCodeLine{00994 \textcolor{preprocessor}{    \#if ( configUSE\_NEWLIB\_REENTRANT == 1 )}}
\DoxyCodeLine{00995     \{}
\DoxyCodeLine{00996         \textcolor{comment}{/* Initialise this task's Newlib reent structure. */}}
\DoxyCodeLine{00997         \_REENT\_INIT\_PTR( ( \&( pxNewTCB-\/>xNewLib\_reent ) ) );}
\DoxyCodeLine{00998     \}}
\DoxyCodeLine{00999 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{01000 }
\DoxyCodeLine{01001 \textcolor{preprocessor}{    \#if( INCLUDE\_xTaskAbortDelay == 1 )}}
\DoxyCodeLine{01002     \{}
\DoxyCodeLine{01003         pxNewTCB-\/>ucDelayAborted = pdFALSE;}
\DoxyCodeLine{01004     \}}
\DoxyCodeLine{01005 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{01006 }
\DoxyCodeLine{01007     \textcolor{comment}{/* Initialize the TCB stack to look as if the task was already running,}}
\DoxyCodeLine{01008 \textcolor{comment}{    but had been interrupted by the scheduler.  The return address is set}}
\DoxyCodeLine{01009 \textcolor{comment}{    to the start of the task function. Once the stack has been initialised}}
\DoxyCodeLine{01010 \textcolor{comment}{    the top of stack variable is updated. */}}
\DoxyCodeLine{01011 \textcolor{preprocessor}{    \#if( portUSING\_MPU\_WRAPPERS == 1 )}}
\DoxyCodeLine{01012     \{}
\DoxyCodeLine{01013         \textcolor{comment}{/* If the port has capability to detect stack overflow,}}
\DoxyCodeLine{01014 \textcolor{comment}{        pass the stack end address to the stack initialization}}
\DoxyCodeLine{01015 \textcolor{comment}{        function as well. */}}
\DoxyCodeLine{01016 \textcolor{preprocessor}{        \#if( portHAS\_STACK\_OVERFLOW\_CHECKING == 1 )}}
\DoxyCodeLine{01017         \{}
\DoxyCodeLine{01018 \textcolor{preprocessor}{            \#if( portSTACK\_GROWTH < 0 )}}
\DoxyCodeLine{01019             \{}
\DoxyCodeLine{01020                 pxNewTCB-\/>pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-\/>pxStack, pxTaskCode, pvParameters, xRunPrivileged );}
\DoxyCodeLine{01021             \}}
\DoxyCodeLine{01022 \textcolor{preprocessor}{            \#else }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01023             \{}
\DoxyCodeLine{01024                 pxNewTCB-\/>pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-\/>pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );}
\DoxyCodeLine{01025             \}}
\DoxyCodeLine{01026 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01027         \}}
\DoxyCodeLine{01028 \textcolor{preprocessor}{        \#else }\textcolor{comment}{/* portHAS\_STACK\_OVERFLOW\_CHECKING */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01029         \{}
\DoxyCodeLine{01030             pxNewTCB-\/>pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );}
\DoxyCodeLine{01031         \}}
\DoxyCodeLine{01032 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* portHAS\_STACK\_OVERFLOW\_CHECKING */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01033     \}}
\DoxyCodeLine{01034 \textcolor{preprocessor}{    \#else }\textcolor{comment}{/* portUSING\_MPU\_WRAPPERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01035     \{}
\DoxyCodeLine{01036         \textcolor{comment}{/* If the port has capability to detect stack overflow,}}
\DoxyCodeLine{01037 \textcolor{comment}{        pass the stack end address to the stack initialization}}
\DoxyCodeLine{01038 \textcolor{comment}{        function as well. */}}
\DoxyCodeLine{01039 \textcolor{preprocessor}{        \#if( portHAS\_STACK\_OVERFLOW\_CHECKING == 1 )}}
\DoxyCodeLine{01040         \{}
\DoxyCodeLine{01041 \textcolor{preprocessor}{            \#if( portSTACK\_GROWTH < 0 )}}
\DoxyCodeLine{01042             \{}
\DoxyCodeLine{01043                 pxNewTCB-\/>pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-\/>pxStack, pxTaskCode, pvParameters );}
\DoxyCodeLine{01044             \}}
\DoxyCodeLine{01045 \textcolor{preprocessor}{            \#else }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01046             \{}
\DoxyCodeLine{01047                 pxNewTCB-\/>pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-\/>pxEndOfStack, pxTaskCode, pvParameters );}
\DoxyCodeLine{01048             \}}
\DoxyCodeLine{01049 \textcolor{preprocessor}{            \#endif }\textcolor{comment}{/* portSTACK\_GROWTH */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01050         \}}
\DoxyCodeLine{01051 \textcolor{preprocessor}{        \#else }\textcolor{comment}{/* portHAS\_STACK\_OVERFLOW\_CHECKING */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01052         \{}
\DoxyCodeLine{01053             pxNewTCB-\/>pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );}
\DoxyCodeLine{01054         \}}
\DoxyCodeLine{01055 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* portHAS\_STACK\_OVERFLOW\_CHECKING */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01056     \}}
\DoxyCodeLine{01057 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* portUSING\_MPU\_WRAPPERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01058 }
\DoxyCodeLine{01059     \textcolor{keywordflow}{if}( pxCreatedTask != NULL )}
\DoxyCodeLine{01060     \{}
\DoxyCodeLine{01061         \textcolor{comment}{/* Pass the handle out in an anonymous way.  The handle can be used to}}
\DoxyCodeLine{01062 \textcolor{comment}{        change the created task's priority, delete the created task, etc.*/}}
\DoxyCodeLine{01063         *pxCreatedTask = ( TaskHandle\_t ) pxNewTCB;}
\DoxyCodeLine{01064     \}}
\DoxyCodeLine{01065     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01066     \{}
\DoxyCodeLine{01067         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01068     \}}
\DoxyCodeLine{01069 \}}
\DoxyCodeLine{01070 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01071 }
\DoxyCodeLine{01072 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvAddNewTaskToReadyList( TCB\_t *pxNewTCB )}
\DoxyCodeLine{01073 \{}
\DoxyCodeLine{01074     \textcolor{comment}{/* Ensure interrupts don't access the task lists while the lists are being}}
\DoxyCodeLine{01075 \textcolor{comment}{    updated. */}}
\DoxyCodeLine{01076     taskENTER\_CRITICAL();}
\DoxyCodeLine{01077     \{}
\DoxyCodeLine{01078         uxCurrentNumberOfTasks++;}
\DoxyCodeLine{01079         \textcolor{keywordflow}{if}( pxCurrentTCB == NULL )}
\DoxyCodeLine{01080         \{}
\DoxyCodeLine{01081             \textcolor{comment}{/* There are no other tasks, or all the other tasks are in}}
\DoxyCodeLine{01082 \textcolor{comment}{            the suspended state -\/ make this the current task. */}}
\DoxyCodeLine{01083             pxCurrentTCB = pxNewTCB;}
\DoxyCodeLine{01084 }
\DoxyCodeLine{01085             \textcolor{keywordflow}{if}( uxCurrentNumberOfTasks == ( UBaseType\_t ) 1 )}
\DoxyCodeLine{01086             \{}
\DoxyCodeLine{01087                 \textcolor{comment}{/* This is the first task to be created so do the preliminary}}
\DoxyCodeLine{01088 \textcolor{comment}{                initialisation required.  We will not recover if this call}}
\DoxyCodeLine{01089 \textcolor{comment}{                fails, but we will report the failure. */}}
\DoxyCodeLine{01090                 prvInitialiseTaskLists();}
\DoxyCodeLine{01091             \}}
\DoxyCodeLine{01092             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01093             \{}
\DoxyCodeLine{01094                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01095             \}}
\DoxyCodeLine{01096         \}}
\DoxyCodeLine{01097         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01098         \{}
\DoxyCodeLine{01099             \textcolor{comment}{/* If the scheduler is not already running, make this task the}}
\DoxyCodeLine{01100 \textcolor{comment}{            current task if it is the highest priority task to be created}}
\DoxyCodeLine{01101 \textcolor{comment}{            so far. */}}
\DoxyCodeLine{01102             \textcolor{keywordflow}{if}( xSchedulerRunning == pdFALSE )}
\DoxyCodeLine{01103             \{}
\DoxyCodeLine{01104                 \textcolor{keywordflow}{if}( pxCurrentTCB-\/>uxPriority <= pxNewTCB-\/>uxPriority )}
\DoxyCodeLine{01105                 \{}
\DoxyCodeLine{01106                     pxCurrentTCB = pxNewTCB;}
\DoxyCodeLine{01107                 \}}
\DoxyCodeLine{01108                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01109                 \{}
\DoxyCodeLine{01110                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01111                 \}}
\DoxyCodeLine{01112             \}}
\DoxyCodeLine{01113             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01114             \{}
\DoxyCodeLine{01115                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01116             \}}
\DoxyCodeLine{01117         \}}
\DoxyCodeLine{01118 }
\DoxyCodeLine{01119         uxTaskNumber++;}
\DoxyCodeLine{01120 }
\DoxyCodeLine{01121 \textcolor{preprocessor}{        \#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{01122         \{}
\DoxyCodeLine{01123             \textcolor{comment}{/* Add a counter into the TCB for tracing only. */}}
\DoxyCodeLine{01124             pxNewTCB-\/>uxTCBNumber = uxTaskNumber;}
\DoxyCodeLine{01125         \}}
\DoxyCodeLine{01126 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01127         traceTASK\_CREATE( pxNewTCB );}
\DoxyCodeLine{01128 }
\DoxyCodeLine{01129         prvAddTaskToReadyList( pxNewTCB );}
\DoxyCodeLine{01130 }
\DoxyCodeLine{01131         portSETUP\_TCB( pxNewTCB );}
\DoxyCodeLine{01132     \}}
\DoxyCodeLine{01133     taskEXIT\_CRITICAL();}
\DoxyCodeLine{01134 }
\DoxyCodeLine{01135     \textcolor{keywordflow}{if}( xSchedulerRunning != pdFALSE )}
\DoxyCodeLine{01136     \{}
\DoxyCodeLine{01137         \textcolor{comment}{/* If the created task is of a higher priority than the current task}}
\DoxyCodeLine{01138 \textcolor{comment}{        then it should run now. */}}
\DoxyCodeLine{01139         \textcolor{keywordflow}{if}( pxCurrentTCB-\/>uxPriority < pxNewTCB-\/>uxPriority )}
\DoxyCodeLine{01140         \{}
\DoxyCodeLine{01141             taskYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{01142         \}}
\DoxyCodeLine{01143         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01144         \{}
\DoxyCodeLine{01145             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01146         \}}
\DoxyCodeLine{01147     \}}
\DoxyCodeLine{01148     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01149     \{}
\DoxyCodeLine{01150         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01151     \}}
\DoxyCodeLine{01152 \}}
\DoxyCodeLine{01153 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01154 }
\DoxyCodeLine{01155 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{01156 }
\DoxyCodeLine{01157     \textcolor{keywordtype}{void} vTaskDelete( TaskHandle\_t xTaskToDelete )}
\DoxyCodeLine{01158     \{}
\DoxyCodeLine{01159     TCB\_t *pxTCB;}
\DoxyCodeLine{01160 }
\DoxyCodeLine{01161         taskENTER\_CRITICAL();}
\DoxyCodeLine{01162         \{}
\DoxyCodeLine{01163             \textcolor{comment}{/* If null is passed in here then it is the calling task that is}}
\DoxyCodeLine{01164 \textcolor{comment}{            being deleted. */}}
\DoxyCodeLine{01165             pxTCB = prvGetTCBFromHandle( xTaskToDelete );}
\DoxyCodeLine{01166 }
\DoxyCodeLine{01167             \textcolor{comment}{/* Remove task from the ready list. */}}
\DoxyCodeLine{01168             \textcolor{keywordflow}{if}( uxListRemove( \&( pxTCB-\/>xStateListItem ) ) == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01169             \{}
\DoxyCodeLine{01170                 taskRESET\_READY\_PRIORITY( pxTCB-\/>uxPriority );}
\DoxyCodeLine{01171             \}}
\DoxyCodeLine{01172             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01173             \{}
\DoxyCodeLine{01174                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01175             \}}
\DoxyCodeLine{01176 }
\DoxyCodeLine{01177             \textcolor{comment}{/* Is the task waiting on an event also? */}}
\DoxyCodeLine{01178             \textcolor{keywordflow}{if}( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) != NULL )}
\DoxyCodeLine{01179             \{}
\DoxyCodeLine{01180                 ( void ) uxListRemove( \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{01181             \}}
\DoxyCodeLine{01182             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01183             \{}
\DoxyCodeLine{01184                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01185             \}}
\DoxyCodeLine{01186 }
\DoxyCodeLine{01187             \textcolor{comment}{/* Increment the uxTaskNumber also so kernel aware debuggers can}}
\DoxyCodeLine{01188 \textcolor{comment}{            detect that the task lists need re-\/generating.  This is done before}}
\DoxyCodeLine{01189 \textcolor{comment}{            portPRE\_TASK\_DELETE\_HOOK() as in the Windows port that macro will}}
\DoxyCodeLine{01190 \textcolor{comment}{            not return. */}}
\DoxyCodeLine{01191             uxTaskNumber++;}
\DoxyCodeLine{01192 }
\DoxyCodeLine{01193             \textcolor{keywordflow}{if}( pxTCB == pxCurrentTCB )}
\DoxyCodeLine{01194             \{}
\DoxyCodeLine{01195                 \textcolor{comment}{/* A task is deleting itself.  This cannot complete within the}}
\DoxyCodeLine{01196 \textcolor{comment}{                task itself, as a context switch to another task is required.}}
\DoxyCodeLine{01197 \textcolor{comment}{                Place the task in the termination list.  The idle task will}}
\DoxyCodeLine{01198 \textcolor{comment}{                check the termination list and free up any memory allocated by}}
\DoxyCodeLine{01199 \textcolor{comment}{                the scheduler for the TCB and stack of the deleted task. */}}
\DoxyCodeLine{01200                 vListInsertEnd( \&xTasksWaitingTermination, \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{01201 }
\DoxyCodeLine{01202                 \textcolor{comment}{/* Increment the ucTasksDeleted variable so the idle task knows}}
\DoxyCodeLine{01203 \textcolor{comment}{                there is a task that has been deleted and that it should therefore}}
\DoxyCodeLine{01204 \textcolor{comment}{                check the xTasksWaitingTermination list. */}}
\DoxyCodeLine{01205                 ++uxDeletedTasksWaitingCleanUp;}
\DoxyCodeLine{01206 }
\DoxyCodeLine{01207                 \textcolor{comment}{/* The pre-\/delete hook is primarily for the Windows simulator,}}
\DoxyCodeLine{01208 \textcolor{comment}{                in which Windows specific clean up operations are performed,}}
\DoxyCodeLine{01209 \textcolor{comment}{                after which it is not possible to yield away from this task -\/}}
\DoxyCodeLine{01210 \textcolor{comment}{                hence xYieldPending is used to latch that a context switch is}}
\DoxyCodeLine{01211 \textcolor{comment}{                required. */}}
\DoxyCodeLine{01212                 portPRE\_TASK\_DELETE\_HOOK( pxTCB, \&xYieldPending );}
\DoxyCodeLine{01213             \}}
\DoxyCodeLine{01214             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01215             \{}
\DoxyCodeLine{01216                 -\/-\/uxCurrentNumberOfTasks;}
\DoxyCodeLine{01217                 prvDeleteTCB( pxTCB );}
\DoxyCodeLine{01218 }
\DoxyCodeLine{01219                 \textcolor{comment}{/* Reset the next expected unblock time in case it referred to}}
\DoxyCodeLine{01220 \textcolor{comment}{                the task that has just been deleted. */}}
\DoxyCodeLine{01221                 prvResetNextTaskUnblockTime();}
\DoxyCodeLine{01222             \}}
\DoxyCodeLine{01223 }
\DoxyCodeLine{01224             traceTASK\_DELETE( pxTCB );}
\DoxyCodeLine{01225         \}}
\DoxyCodeLine{01226         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01227 }
\DoxyCodeLine{01228         \textcolor{comment}{/* Force a reschedule if it is the currently running task that has just}}
\DoxyCodeLine{01229 \textcolor{comment}{        been deleted. */}}
\DoxyCodeLine{01230         \textcolor{keywordflow}{if}( xSchedulerRunning != pdFALSE )}
\DoxyCodeLine{01231         \{}
\DoxyCodeLine{01232             \textcolor{keywordflow}{if}( pxTCB == pxCurrentTCB )}
\DoxyCodeLine{01233             \{}
\DoxyCodeLine{01234                 configASSERT( uxSchedulerSuspended == 0 );}
\DoxyCodeLine{01235                 portYIELD\_WITHIN\_API();}
\DoxyCodeLine{01236             \}}
\DoxyCodeLine{01237             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01238             \{}
\DoxyCodeLine{01239                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01240             \}}
\DoxyCodeLine{01241         \}}
\DoxyCodeLine{01242     \}}
\DoxyCodeLine{01243 }
\DoxyCodeLine{01244 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskDelete */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01245 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01246 }
\DoxyCodeLine{01247 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskDelayUntil == 1 )}}
\DoxyCodeLine{01248 }
\DoxyCodeLine{01249     \textcolor{keywordtype}{void} vTaskDelayUntil( TickType\_t * \textcolor{keyword}{const} pxPreviousWakeTime, \textcolor{keyword}{const} TickType\_t xTimeIncrement )}
\DoxyCodeLine{01250     \{}
\DoxyCodeLine{01251     TickType\_t xTimeToWake;}
\DoxyCodeLine{01252     BaseType\_t xAlreadyYielded, xShouldDelay = pdFALSE;}
\DoxyCodeLine{01253 }
\DoxyCodeLine{01254         configASSERT( pxPreviousWakeTime );}
\DoxyCodeLine{01255         configASSERT( ( xTimeIncrement > 0U ) );}
\DoxyCodeLine{01256         configASSERT( uxSchedulerSuspended == 0 );}
\DoxyCodeLine{01257 }
\DoxyCodeLine{01258         vTaskSuspendAll();}
\DoxyCodeLine{01259         \{}
\DoxyCodeLine{01260             \textcolor{comment}{/* Minor optimisation.  The tick count cannot change in this}}
\DoxyCodeLine{01261 \textcolor{comment}{            block. */}}
\DoxyCodeLine{01262             \textcolor{keyword}{const} TickType\_t xConstTickCount = xTickCount;}
\DoxyCodeLine{01263 }
\DoxyCodeLine{01264             \textcolor{comment}{/* Generate the tick time at which the task wants to wake. */}}
\DoxyCodeLine{01265             xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;}
\DoxyCodeLine{01266 }
\DoxyCodeLine{01267             \textcolor{keywordflow}{if}( xConstTickCount < *pxPreviousWakeTime )}
\DoxyCodeLine{01268             \{}
\DoxyCodeLine{01269                 \textcolor{comment}{/* The tick count has overflowed since this function was}}
\DoxyCodeLine{01270 \textcolor{comment}{                lasted called.  In this case the only time we should ever}}
\DoxyCodeLine{01271 \textcolor{comment}{                actually delay is if the wake time has also overflowed,}}
\DoxyCodeLine{01272 \textcolor{comment}{                and the wake time is greater than the tick time.  When this}}
\DoxyCodeLine{01273 \textcolor{comment}{                is the case it is as if neither time had overflowed. */}}
\DoxyCodeLine{01274                 \textcolor{keywordflow}{if}( ( xTimeToWake < *pxPreviousWakeTime ) \&\& ( xTimeToWake > xConstTickCount ) )}
\DoxyCodeLine{01275                 \{}
\DoxyCodeLine{01276                     xShouldDelay = pdTRUE;}
\DoxyCodeLine{01277                 \}}
\DoxyCodeLine{01278                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01279                 \{}
\DoxyCodeLine{01280                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01281                 \}}
\DoxyCodeLine{01282             \}}
\DoxyCodeLine{01283             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01284             \{}
\DoxyCodeLine{01285                 \textcolor{comment}{/* The tick time has not overflowed.  In this case we will}}
\DoxyCodeLine{01286 \textcolor{comment}{                delay if either the wake time has overflowed, and/or the}}
\DoxyCodeLine{01287 \textcolor{comment}{                tick time is less than the wake time. */}}
\DoxyCodeLine{01288                 \textcolor{keywordflow}{if}( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )}
\DoxyCodeLine{01289                 \{}
\DoxyCodeLine{01290                     xShouldDelay = pdTRUE;}
\DoxyCodeLine{01291                 \}}
\DoxyCodeLine{01292                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01293                 \{}
\DoxyCodeLine{01294                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01295                 \}}
\DoxyCodeLine{01296             \}}
\DoxyCodeLine{01297 }
\DoxyCodeLine{01298             \textcolor{comment}{/* Update the wake time ready for the next call. */}}
\DoxyCodeLine{01299             *pxPreviousWakeTime = xTimeToWake;}
\DoxyCodeLine{01300 }
\DoxyCodeLine{01301             \textcolor{keywordflow}{if}( xShouldDelay != pdFALSE )}
\DoxyCodeLine{01302             \{}
\DoxyCodeLine{01303                 traceTASK\_DELAY\_UNTIL( xTimeToWake );}
\DoxyCodeLine{01304 }
\DoxyCodeLine{01305                 \textcolor{comment}{/* prvAddCurrentTaskToDelayedList() needs the block time, not}}
\DoxyCodeLine{01306 \textcolor{comment}{                the time to wake, so subtract the current tick count. */}}
\DoxyCodeLine{01307                 prvAddCurrentTaskToDelayedList( xTimeToWake -\/ xConstTickCount, pdFALSE );}
\DoxyCodeLine{01308             \}}
\DoxyCodeLine{01309             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01310             \{}
\DoxyCodeLine{01311                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01312             \}}
\DoxyCodeLine{01313         \}}
\DoxyCodeLine{01314         xAlreadyYielded = xTaskResumeAll();}
\DoxyCodeLine{01315 }
\DoxyCodeLine{01316         \textcolor{comment}{/* Force a reschedule if xTaskResumeAll has not already done so, we may}}
\DoxyCodeLine{01317 \textcolor{comment}{        have put ourselves to sleep. */}}
\DoxyCodeLine{01318         \textcolor{keywordflow}{if}( xAlreadyYielded == pdFALSE )}
\DoxyCodeLine{01319         \{}
\DoxyCodeLine{01320             portYIELD\_WITHIN\_API();}
\DoxyCodeLine{01321         \}}
\DoxyCodeLine{01322         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01323         \{}
\DoxyCodeLine{01324             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01325         \}}
\DoxyCodeLine{01326     \}}
\DoxyCodeLine{01327 }
\DoxyCodeLine{01328 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskDelayUntil */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01329 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01330 }
\DoxyCodeLine{01331 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskDelay == 1 )}}
\DoxyCodeLine{01332 }
\DoxyCodeLine{01333     \textcolor{keywordtype}{void} vTaskDelay( \textcolor{keyword}{const} TickType\_t xTicksToDelay )}
\DoxyCodeLine{01334     \{}
\DoxyCodeLine{01335     BaseType\_t xAlreadyYielded = pdFALSE;}
\DoxyCodeLine{01336 }
\DoxyCodeLine{01337         \textcolor{comment}{/* A delay time of zero just forces a reschedule. */}}
\DoxyCodeLine{01338         \textcolor{keywordflow}{if}( xTicksToDelay > ( TickType\_t ) 0U )}
\DoxyCodeLine{01339         \{}
\DoxyCodeLine{01340             configASSERT( uxSchedulerSuspended == 0 );}
\DoxyCodeLine{01341             vTaskSuspendAll();}
\DoxyCodeLine{01342             \{}
\DoxyCodeLine{01343                 traceTASK\_DELAY();}
\DoxyCodeLine{01344 }
\DoxyCodeLine{01345                 \textcolor{comment}{/* A task that is removed from the event list while the}}
\DoxyCodeLine{01346 \textcolor{comment}{                scheduler is suspended will not get placed in the ready}}
\DoxyCodeLine{01347 \textcolor{comment}{                list or removed from the blocked list until the scheduler}}
\DoxyCodeLine{01348 \textcolor{comment}{                is resumed.}}
\DoxyCodeLine{01349 \textcolor{comment}{}}
\DoxyCodeLine{01350 \textcolor{comment}{                This task cannot be in an event list as it is the currently}}
\DoxyCodeLine{01351 \textcolor{comment}{                executing task. */}}
\DoxyCodeLine{01352                 prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );}
\DoxyCodeLine{01353             \}}
\DoxyCodeLine{01354             xAlreadyYielded = xTaskResumeAll();}
\DoxyCodeLine{01355         \}}
\DoxyCodeLine{01356         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01357         \{}
\DoxyCodeLine{01358             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01359         \}}
\DoxyCodeLine{01360 }
\DoxyCodeLine{01361         \textcolor{comment}{/* Force a reschedule if xTaskResumeAll has not already done so, we may}}
\DoxyCodeLine{01362 \textcolor{comment}{        have put ourselves to sleep. */}}
\DoxyCodeLine{01363         \textcolor{keywordflow}{if}( xAlreadyYielded == pdFALSE )}
\DoxyCodeLine{01364         \{}
\DoxyCodeLine{01365             portYIELD\_WITHIN\_API();}
\DoxyCodeLine{01366         \}}
\DoxyCodeLine{01367         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01368         \{}
\DoxyCodeLine{01369             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01370         \}}
\DoxyCodeLine{01371     \}}
\DoxyCodeLine{01372 }
\DoxyCodeLine{01373 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskDelay */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01374 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01375 }
\DoxyCodeLine{01376 \textcolor{preprocessor}{\#if( ( INCLUDE\_eTaskGetState == 1 ) || ( configUSE\_TRACE\_FACILITY == 1 ) || ( INCLUDE\_xTaskAbortDelay == 1 ) )}}
\DoxyCodeLine{01377 }
\DoxyCodeLine{01378     eTaskState eTaskGetState( TaskHandle\_t xTask )}
\DoxyCodeLine{01379     \{}
\DoxyCodeLine{01380     eTaskState eReturn;}
\DoxyCodeLine{01381     List\_t \textcolor{keyword}{const} * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;}
\DoxyCodeLine{01382     \textcolor{keyword}{const} TCB\_t * \textcolor{keyword}{const} pxTCB = xTask;}
\DoxyCodeLine{01383 }
\DoxyCodeLine{01384         configASSERT( pxTCB );}
\DoxyCodeLine{01385 }
\DoxyCodeLine{01386         \textcolor{keywordflow}{if}( pxTCB == pxCurrentTCB )}
\DoxyCodeLine{01387         \{}
\DoxyCodeLine{01388             \textcolor{comment}{/* The task calling this function is querying its own state. */}}
\DoxyCodeLine{01389             eReturn = eRunning;}
\DoxyCodeLine{01390         \}}
\DoxyCodeLine{01391         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01392         \{}
\DoxyCodeLine{01393             taskENTER\_CRITICAL();}
\DoxyCodeLine{01394             \{}
\DoxyCodeLine{01395                 pxStateList = listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{01396                 pxDelayedList = pxDelayedTaskList;}
\DoxyCodeLine{01397                 pxOverflowedDelayedList = pxOverflowDelayedTaskList;}
\DoxyCodeLine{01398             \}}
\DoxyCodeLine{01399             taskEXIT\_CRITICAL();}
\DoxyCodeLine{01400 }
\DoxyCodeLine{01401             \textcolor{keywordflow}{if}( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )}
\DoxyCodeLine{01402             \{}
\DoxyCodeLine{01403                 \textcolor{comment}{/* The task being queried is referenced from one of the Blocked}}
\DoxyCodeLine{01404 \textcolor{comment}{                lists. */}}
\DoxyCodeLine{01405                 eReturn = eBlocked;}
\DoxyCodeLine{01406             \}}
\DoxyCodeLine{01407 }
\DoxyCodeLine{01408 \textcolor{preprocessor}{            \#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{01409                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( pxStateList == \&xSuspendedTaskList )}
\DoxyCodeLine{01410                 \{}
\DoxyCodeLine{01411                     \textcolor{comment}{/* The task being queried is referenced from the suspended}}
\DoxyCodeLine{01412 \textcolor{comment}{                    list.  Is it genuinely suspended or is it blocked}}
\DoxyCodeLine{01413 \textcolor{comment}{                    indefinitely? */}}
\DoxyCodeLine{01414                     \textcolor{keywordflow}{if}( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) == NULL )}
\DoxyCodeLine{01415                     \{}
\DoxyCodeLine{01416 \textcolor{preprocessor}{                        \#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{01417                         \{}
\DoxyCodeLine{01418                             \textcolor{comment}{/* The task does not appear on the event list item of}}
\DoxyCodeLine{01419 \textcolor{comment}{                            and of the RTOS objects, but could still be in the}}
\DoxyCodeLine{01420 \textcolor{comment}{                            blocked state if it is waiting on its notification}}
\DoxyCodeLine{01421 \textcolor{comment}{                            rather than waiting on an object. */}}
\DoxyCodeLine{01422                             \textcolor{keywordflow}{if}( pxTCB-\/>ucNotifyState == taskWAITING\_NOTIFICATION )}
\DoxyCodeLine{01423                             \{}
\DoxyCodeLine{01424                                 eReturn = eBlocked;}
\DoxyCodeLine{01425                             \}}
\DoxyCodeLine{01426                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01427                             \{}
\DoxyCodeLine{01428                                 eReturn = eSuspended;}
\DoxyCodeLine{01429                             \}}
\DoxyCodeLine{01430                         \}}
\DoxyCodeLine{01431 \textcolor{preprocessor}{                        \#else}}
\DoxyCodeLine{01432                         \{}
\DoxyCodeLine{01433                             eReturn = eSuspended;}
\DoxyCodeLine{01434                         \}}
\DoxyCodeLine{01435 \textcolor{preprocessor}{                        \#endif}}
\DoxyCodeLine{01436                     \}}
\DoxyCodeLine{01437                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01438                     \{}
\DoxyCodeLine{01439                         eReturn = eBlocked;}
\DoxyCodeLine{01440                     \}}
\DoxyCodeLine{01441                 \}}
\DoxyCodeLine{01442 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{01443 }
\DoxyCodeLine{01444 \textcolor{preprocessor}{            \#if ( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{01445                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ( pxStateList == \&xTasksWaitingTermination ) || ( pxStateList == NULL ) )}
\DoxyCodeLine{01446                 \{}
\DoxyCodeLine{01447                     \textcolor{comment}{/* The task being queried is referenced from the deleted}}
\DoxyCodeLine{01448 \textcolor{comment}{                    tasks list, or it is not referenced from any lists at}}
\DoxyCodeLine{01449 \textcolor{comment}{                    all. */}}
\DoxyCodeLine{01450                     eReturn = eDeleted;}
\DoxyCodeLine{01451                 \}}
\DoxyCodeLine{01452 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{01453 }
\DoxyCodeLine{01454             \textcolor{keywordflow}{else} \textcolor{comment}{/*lint !e525 Negative indentation is intended to make use of pre-\/processor clearer. */}}
\DoxyCodeLine{01455             \{}
\DoxyCodeLine{01456                 \textcolor{comment}{/* If the task is not in any other state, it must be in the}}
\DoxyCodeLine{01457 \textcolor{comment}{                Ready (including pending ready) state. */}}
\DoxyCodeLine{01458                 eReturn = eReady;}
\DoxyCodeLine{01459             \}}
\DoxyCodeLine{01460         \}}
\DoxyCodeLine{01461 }
\DoxyCodeLine{01462         \textcolor{keywordflow}{return} eReturn;}
\DoxyCodeLine{01463     \} \textcolor{comment}{/*lint !e818 xTask cannot be a pointer to const because it is a typedef. */}}
\DoxyCodeLine{01464 }
\DoxyCodeLine{01465 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_eTaskGetState */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01466 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01467 }
\DoxyCodeLine{01468 \textcolor{preprocessor}{\#if ( INCLUDE\_uxTaskPriorityGet == 1 )}}
\DoxyCodeLine{01469 }
\DoxyCodeLine{01470     UBaseType\_t uxTaskPriorityGet( \textcolor{keyword}{const} TaskHandle\_t xTask )}
\DoxyCodeLine{01471     \{}
\DoxyCodeLine{01472     TCB\_t \textcolor{keyword}{const} *pxTCB;}
\DoxyCodeLine{01473     UBaseType\_t uxReturn;}
\DoxyCodeLine{01474 }
\DoxyCodeLine{01475         taskENTER\_CRITICAL();}
\DoxyCodeLine{01476         \{}
\DoxyCodeLine{01477             \textcolor{comment}{/* If null is passed in here then it is the priority of the task}}
\DoxyCodeLine{01478 \textcolor{comment}{            that called uxTaskPriorityGet() that is being queried. */}}
\DoxyCodeLine{01479             pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{01480             uxReturn = pxTCB-\/>uxPriority;}
\DoxyCodeLine{01481         \}}
\DoxyCodeLine{01482         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01483 }
\DoxyCodeLine{01484         \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{01485     \}}
\DoxyCodeLine{01486 }
\DoxyCodeLine{01487 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_uxTaskPriorityGet */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01488 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01489 }
\DoxyCodeLine{01490 \textcolor{preprocessor}{\#if ( INCLUDE\_uxTaskPriorityGet == 1 )}}
\DoxyCodeLine{01491 }
\DoxyCodeLine{01492     UBaseType\_t uxTaskPriorityGetFromISR( \textcolor{keyword}{const} TaskHandle\_t xTask )}
\DoxyCodeLine{01493     \{}
\DoxyCodeLine{01494     TCB\_t \textcolor{keyword}{const} *pxTCB;}
\DoxyCodeLine{01495     UBaseType\_t uxReturn, uxSavedInterruptState;}
\DoxyCodeLine{01496 }
\DoxyCodeLine{01497         \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a}}
\DoxyCodeLine{01498 \textcolor{comment}{        maximum system call (or maximum API call) interrupt priority.}}
\DoxyCodeLine{01499 \textcolor{comment}{        Interrupts that are above the maximum system call priority are keep}}
\DoxyCodeLine{01500 \textcolor{comment}{        permanently enabled, even when the RTOS kernel is in a critical section,}}
\DoxyCodeLine{01501 \textcolor{comment}{        but cannot make any calls to FreeRTOS API functions.  If configASSERT()}}
\DoxyCodeLine{01502 \textcolor{comment}{        is defined in FreeRTOSConfig.h then}}
\DoxyCodeLine{01503 \textcolor{comment}{        portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{01504 \textcolor{comment}{        failure if a FreeRTOS API function is called from an interrupt that has}}
\DoxyCodeLine{01505 \textcolor{comment}{        been assigned a priority above the configured maximum system call}}
\DoxyCodeLine{01506 \textcolor{comment}{        priority.  Only FreeRTOS functions that end in FromISR can be called}}
\DoxyCodeLine{01507 \textcolor{comment}{        from interrupts that have been assigned a priority at or (logically)}}
\DoxyCodeLine{01508 \textcolor{comment}{        below the maximum system call interrupt priority.  FreeRTOS maintains a}}
\DoxyCodeLine{01509 \textcolor{comment}{        separate interrupt safe API to ensure interrupt entry is as fast and as}}
\DoxyCodeLine{01510 \textcolor{comment}{        simple as possible.  More information (albeit Cortex-\/M specific) is}}
\DoxyCodeLine{01511 \textcolor{comment}{        provided on the following link:}}
\DoxyCodeLine{01512 \textcolor{comment}{        https://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{01513         portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{01514 }
\DoxyCodeLine{01515         uxSavedInterruptState = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{01516         \{}
\DoxyCodeLine{01517             \textcolor{comment}{/* If null is passed in here then it is the priority of the calling}}
\DoxyCodeLine{01518 \textcolor{comment}{            task that is being queried. */}}
\DoxyCodeLine{01519             pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{01520             uxReturn = pxTCB-\/>uxPriority;}
\DoxyCodeLine{01521         \}}
\DoxyCodeLine{01522         portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptState );}
\DoxyCodeLine{01523 }
\DoxyCodeLine{01524         \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{01525     \}}
\DoxyCodeLine{01526 }
\DoxyCodeLine{01527 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_uxTaskPriorityGet */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01528 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01529 }
\DoxyCodeLine{01530 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskPrioritySet == 1 )}}
\DoxyCodeLine{01531 }
\DoxyCodeLine{01532     \textcolor{keywordtype}{void} vTaskPrioritySet( TaskHandle\_t xTask, UBaseType\_t uxNewPriority )}
\DoxyCodeLine{01533     \{}
\DoxyCodeLine{01534     TCB\_t *pxTCB;}
\DoxyCodeLine{01535     UBaseType\_t uxCurrentBasePriority, uxPriorityUsedOnEntry;}
\DoxyCodeLine{01536     BaseType\_t xYieldRequired = pdFALSE;}
\DoxyCodeLine{01537 }
\DoxyCodeLine{01538         configASSERT( ( uxNewPriority < configMAX\_PRIORITIES ) );}
\DoxyCodeLine{01539 }
\DoxyCodeLine{01540         \textcolor{comment}{/* Ensure the new priority is valid. */}}
\DoxyCodeLine{01541         \textcolor{keywordflow}{if}( uxNewPriority >= ( UBaseType\_t ) configMAX\_PRIORITIES )}
\DoxyCodeLine{01542         \{}
\DoxyCodeLine{01543             uxNewPriority = ( UBaseType\_t ) configMAX\_PRIORITIES -\/ ( UBaseType\_t ) 1U;}
\DoxyCodeLine{01544         \}}
\DoxyCodeLine{01545         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01546         \{}
\DoxyCodeLine{01547             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01548         \}}
\DoxyCodeLine{01549 }
\DoxyCodeLine{01550         taskENTER\_CRITICAL();}
\DoxyCodeLine{01551         \{}
\DoxyCodeLine{01552             \textcolor{comment}{/* If null is passed in here then it is the priority of the calling}}
\DoxyCodeLine{01553 \textcolor{comment}{            task that is being changed. */}}
\DoxyCodeLine{01554             pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{01555 }
\DoxyCodeLine{01556             traceTASK\_PRIORITY\_SET( pxTCB, uxNewPriority );}
\DoxyCodeLine{01557 }
\DoxyCodeLine{01558 \textcolor{preprocessor}{            \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{01559             \{}
\DoxyCodeLine{01560                 uxCurrentBasePriority = pxTCB-\/>uxBasePriority;}
\DoxyCodeLine{01561             \}}
\DoxyCodeLine{01562 \textcolor{preprocessor}{            \#else}}
\DoxyCodeLine{01563             \{}
\DoxyCodeLine{01564                 uxCurrentBasePriority = pxTCB-\/>uxPriority;}
\DoxyCodeLine{01565             \}}
\DoxyCodeLine{01566 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{01567 }
\DoxyCodeLine{01568             \textcolor{keywordflow}{if}( uxCurrentBasePriority != uxNewPriority )}
\DoxyCodeLine{01569             \{}
\DoxyCodeLine{01570                 \textcolor{comment}{/* The priority change may have readied a task of higher}}
\DoxyCodeLine{01571 \textcolor{comment}{                priority than the calling task. */}}
\DoxyCodeLine{01572                 \textcolor{keywordflow}{if}( uxNewPriority > uxCurrentBasePriority )}
\DoxyCodeLine{01573                 \{}
\DoxyCodeLine{01574                     \textcolor{keywordflow}{if}( pxTCB != pxCurrentTCB )}
\DoxyCodeLine{01575                     \{}
\DoxyCodeLine{01576                         \textcolor{comment}{/* The priority of a task other than the currently}}
\DoxyCodeLine{01577 \textcolor{comment}{                        running task is being raised.  Is the priority being}}
\DoxyCodeLine{01578 \textcolor{comment}{                        raised above that of the running task? */}}
\DoxyCodeLine{01579                         \textcolor{keywordflow}{if}( uxNewPriority >= pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{01580                         \{}
\DoxyCodeLine{01581                             xYieldRequired = pdTRUE;}
\DoxyCodeLine{01582                         \}}
\DoxyCodeLine{01583                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01584                         \{}
\DoxyCodeLine{01585                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01586                         \}}
\DoxyCodeLine{01587                     \}}
\DoxyCodeLine{01588                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01589                     \{}
\DoxyCodeLine{01590                         \textcolor{comment}{/* The priority of the running task is being raised,}}
\DoxyCodeLine{01591 \textcolor{comment}{                        but the running task must already be the highest}}
\DoxyCodeLine{01592 \textcolor{comment}{                        priority task able to run so no yield is required. */}}
\DoxyCodeLine{01593                     \}}
\DoxyCodeLine{01594                 \}}
\DoxyCodeLine{01595                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( pxTCB == pxCurrentTCB )}
\DoxyCodeLine{01596                 \{}
\DoxyCodeLine{01597                     \textcolor{comment}{/* Setting the priority of the running task down means}}
\DoxyCodeLine{01598 \textcolor{comment}{                    there may now be another task of higher priority that}}
\DoxyCodeLine{01599 \textcolor{comment}{                    is ready to execute. */}}
\DoxyCodeLine{01600                     xYieldRequired = pdTRUE;}
\DoxyCodeLine{01601                 \}}
\DoxyCodeLine{01602                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01603                 \{}
\DoxyCodeLine{01604                     \textcolor{comment}{/* Setting the priority of any other task down does not}}
\DoxyCodeLine{01605 \textcolor{comment}{                    require a yield as the running task must be above the}}
\DoxyCodeLine{01606 \textcolor{comment}{                    new priority of the task being modified. */}}
\DoxyCodeLine{01607                 \}}
\DoxyCodeLine{01608 }
\DoxyCodeLine{01609                 \textcolor{comment}{/* Remember the ready list the task might be referenced from}}
\DoxyCodeLine{01610 \textcolor{comment}{                before its uxPriority member is changed so the}}
\DoxyCodeLine{01611 \textcolor{comment}{                taskRESET\_READY\_PRIORITY() macro can function correctly. */}}
\DoxyCodeLine{01612                 uxPriorityUsedOnEntry = pxTCB-\/>uxPriority;}
\DoxyCodeLine{01613 }
\DoxyCodeLine{01614 \textcolor{preprocessor}{                \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{01615                 \{}
\DoxyCodeLine{01616                     \textcolor{comment}{/* Only change the priority being used if the task is not}}
\DoxyCodeLine{01617 \textcolor{comment}{                    currently using an inherited priority. */}}
\DoxyCodeLine{01618                     \textcolor{keywordflow}{if}( pxTCB-\/>uxBasePriority == pxTCB-\/>uxPriority )}
\DoxyCodeLine{01619                     \{}
\DoxyCodeLine{01620                         pxTCB-\/>uxPriority = uxNewPriority;}
\DoxyCodeLine{01621                     \}}
\DoxyCodeLine{01622                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01623                     \{}
\DoxyCodeLine{01624                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01625                     \}}
\DoxyCodeLine{01626 }
\DoxyCodeLine{01627                     \textcolor{comment}{/* The base priority gets set whatever. */}}
\DoxyCodeLine{01628                     pxTCB-\/>uxBasePriority = uxNewPriority;}
\DoxyCodeLine{01629                 \}}
\DoxyCodeLine{01630 \textcolor{preprocessor}{                \#else}}
\DoxyCodeLine{01631                 \{}
\DoxyCodeLine{01632                     pxTCB-\/>uxPriority = uxNewPriority;}
\DoxyCodeLine{01633                 \}}
\DoxyCodeLine{01634 \textcolor{preprocessor}{                \#endif}}
\DoxyCodeLine{01635 }
\DoxyCodeLine{01636                 \textcolor{comment}{/* Only reset the event list item value if the value is not}}
\DoxyCodeLine{01637 \textcolor{comment}{                being used for anything else. */}}
\DoxyCodeLine{01638                 \textcolor{keywordflow}{if}( ( listGET\_LIST\_ITEM\_VALUE( \&( pxTCB-\/>xEventListItem ) ) \& taskEVENT\_LIST\_ITEM\_VALUE\_IN\_USE ) == 0UL )}
\DoxyCodeLine{01639                 \{}
\DoxyCodeLine{01640                     listSET\_LIST\_ITEM\_VALUE( \&( pxTCB-\/>xEventListItem ), ( ( TickType\_t ) configMAX\_PRIORITIES -\/ ( TickType\_t ) uxNewPriority ) ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{01641                 \}}
\DoxyCodeLine{01642                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01643                 \{}
\DoxyCodeLine{01644                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01645                 \}}
\DoxyCodeLine{01646 }
\DoxyCodeLine{01647                 \textcolor{comment}{/* If the task is in the blocked or suspended list we need do}}
\DoxyCodeLine{01648 \textcolor{comment}{                nothing more than change its priority variable. However, if}}
\DoxyCodeLine{01649 \textcolor{comment}{                the task is in a ready list it needs to be removed and placed}}
\DoxyCodeLine{01650 \textcolor{comment}{                in the list appropriate to its new priority. */}}
\DoxyCodeLine{01651                 \textcolor{keywordflow}{if}( listIS\_CONTAINED\_WITHIN( \&( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), \&( pxTCB-\/>xStateListItem ) ) != pdFALSE )}
\DoxyCodeLine{01652                 \{}
\DoxyCodeLine{01653                     \textcolor{comment}{/* The task is currently in its ready list -\/ remove before}}
\DoxyCodeLine{01654 \textcolor{comment}{                    adding it to it's new ready list.  As we are in a critical}}
\DoxyCodeLine{01655 \textcolor{comment}{                    section we can do this even if the scheduler is suspended. */}}
\DoxyCodeLine{01656                     \textcolor{keywordflow}{if}( uxListRemove( \&( pxTCB-\/>xStateListItem ) ) == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01657                     \{}
\DoxyCodeLine{01658                         \textcolor{comment}{/* It is known that the task is in its ready list so}}
\DoxyCodeLine{01659 \textcolor{comment}{                        there is no need to check again and the port level}}
\DoxyCodeLine{01660 \textcolor{comment}{                        reset macro can be called directly. */}}
\DoxyCodeLine{01661                         portRESET\_READY\_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );}
\DoxyCodeLine{01662                     \}}
\DoxyCodeLine{01663                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01664                     \{}
\DoxyCodeLine{01665                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01666                     \}}
\DoxyCodeLine{01667                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{01668                 \}}
\DoxyCodeLine{01669                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01670                 \{}
\DoxyCodeLine{01671                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01672                 \}}
\DoxyCodeLine{01673 }
\DoxyCodeLine{01674                 \textcolor{keywordflow}{if}( xYieldRequired != pdFALSE )}
\DoxyCodeLine{01675                 \{}
\DoxyCodeLine{01676                     taskYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{01677                 \}}
\DoxyCodeLine{01678                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01679                 \{}
\DoxyCodeLine{01680                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01681                 \}}
\DoxyCodeLine{01682 }
\DoxyCodeLine{01683                 \textcolor{comment}{/* Remove compiler warning about unused variables when the port}}
\DoxyCodeLine{01684 \textcolor{comment}{                optimised task selection is not being used. */}}
\DoxyCodeLine{01685                 ( void ) uxPriorityUsedOnEntry;}
\DoxyCodeLine{01686             \}}
\DoxyCodeLine{01687         \}}
\DoxyCodeLine{01688         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01689     \}}
\DoxyCodeLine{01690 }
\DoxyCodeLine{01691 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskPrioritySet */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01692 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01693 }
\DoxyCodeLine{01694 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{01695 }
\DoxyCodeLine{01696     \textcolor{keywordtype}{void} vTaskSuspend( TaskHandle\_t xTaskToSuspend )}
\DoxyCodeLine{01697     \{}
\DoxyCodeLine{01698     TCB\_t *pxTCB;}
\DoxyCodeLine{01699 }
\DoxyCodeLine{01700         taskENTER\_CRITICAL();}
\DoxyCodeLine{01701         \{}
\DoxyCodeLine{01702             \textcolor{comment}{/* If null is passed in here then it is the running task that is}}
\DoxyCodeLine{01703 \textcolor{comment}{            being suspended. */}}
\DoxyCodeLine{01704             pxTCB = prvGetTCBFromHandle( xTaskToSuspend );}
\DoxyCodeLine{01705 }
\DoxyCodeLine{01706             traceTASK\_SUSPEND( pxTCB );}
\DoxyCodeLine{01707 }
\DoxyCodeLine{01708             \textcolor{comment}{/* Remove task from the ready/delayed list and place in the}}
\DoxyCodeLine{01709 \textcolor{comment}{            suspended list. */}}
\DoxyCodeLine{01710             \textcolor{keywordflow}{if}( uxListRemove( \&( pxTCB-\/>xStateListItem ) ) == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{01711             \{}
\DoxyCodeLine{01712                 taskRESET\_READY\_PRIORITY( pxTCB-\/>uxPriority );}
\DoxyCodeLine{01713             \}}
\DoxyCodeLine{01714             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01715             \{}
\DoxyCodeLine{01716                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01717             \}}
\DoxyCodeLine{01718 }
\DoxyCodeLine{01719             \textcolor{comment}{/* Is the task waiting on an event also? */}}
\DoxyCodeLine{01720             \textcolor{keywordflow}{if}( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) != NULL )}
\DoxyCodeLine{01721             \{}
\DoxyCodeLine{01722                 ( void ) uxListRemove( \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{01723             \}}
\DoxyCodeLine{01724             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01725             \{}
\DoxyCodeLine{01726                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01727             \}}
\DoxyCodeLine{01728 }
\DoxyCodeLine{01729             vListInsertEnd( \&xSuspendedTaskList, \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{01730 }
\DoxyCodeLine{01731 \textcolor{preprocessor}{            \#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{01732             \{}
\DoxyCodeLine{01733                 \textcolor{keywordflow}{if}( pxTCB-\/>ucNotifyState == taskWAITING\_NOTIFICATION )}
\DoxyCodeLine{01734                 \{}
\DoxyCodeLine{01735                     \textcolor{comment}{/* The task was blocked to wait for a notification, but is}}
\DoxyCodeLine{01736 \textcolor{comment}{                    now suspended, so no notification was received. */}}
\DoxyCodeLine{01737                     pxTCB-\/>ucNotifyState = taskNOT\_WAITING\_NOTIFICATION;}
\DoxyCodeLine{01738                 \}}
\DoxyCodeLine{01739             \}}
\DoxyCodeLine{01740 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{01741         \}}
\DoxyCodeLine{01742         taskEXIT\_CRITICAL();}
\DoxyCodeLine{01743 }
\DoxyCodeLine{01744         \textcolor{keywordflow}{if}( xSchedulerRunning != pdFALSE )}
\DoxyCodeLine{01745         \{}
\DoxyCodeLine{01746             \textcolor{comment}{/* Reset the next expected unblock time in case it referred to the}}
\DoxyCodeLine{01747 \textcolor{comment}{            task that is now in the Suspended state. */}}
\DoxyCodeLine{01748             taskENTER\_CRITICAL();}
\DoxyCodeLine{01749             \{}
\DoxyCodeLine{01750                 prvResetNextTaskUnblockTime();}
\DoxyCodeLine{01751             \}}
\DoxyCodeLine{01752             taskEXIT\_CRITICAL();}
\DoxyCodeLine{01753         \}}
\DoxyCodeLine{01754         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01755         \{}
\DoxyCodeLine{01756             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01757         \}}
\DoxyCodeLine{01758 }
\DoxyCodeLine{01759         \textcolor{keywordflow}{if}( pxTCB == pxCurrentTCB )}
\DoxyCodeLine{01760         \{}
\DoxyCodeLine{01761             \textcolor{keywordflow}{if}( xSchedulerRunning != pdFALSE )}
\DoxyCodeLine{01762             \{}
\DoxyCodeLine{01763                 \textcolor{comment}{/* The current task has just been suspended. */}}
\DoxyCodeLine{01764                 configASSERT( uxSchedulerSuspended == 0 );}
\DoxyCodeLine{01765                 portYIELD\_WITHIN\_API();}
\DoxyCodeLine{01766             \}}
\DoxyCodeLine{01767             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01768             \{}
\DoxyCodeLine{01769                 \textcolor{comment}{/* The scheduler is not running, but the task that was pointed}}
\DoxyCodeLine{01770 \textcolor{comment}{                to by pxCurrentTCB has just been suspended and pxCurrentTCB}}
\DoxyCodeLine{01771 \textcolor{comment}{                must be adjusted to point to a different task. */}}
\DoxyCodeLine{01772                 \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( \&xSuspendedTaskList ) == uxCurrentNumberOfTasks ) \textcolor{comment}{/*lint !e931 Right has no side effect, just volatile. */}}
\DoxyCodeLine{01773                 \{}
\DoxyCodeLine{01774                     \textcolor{comment}{/* No other tasks are ready, so set pxCurrentTCB back to}}
\DoxyCodeLine{01775 \textcolor{comment}{                    NULL so when the next task is created pxCurrentTCB will}}
\DoxyCodeLine{01776 \textcolor{comment}{                    be set to point to it no matter what its relative priority}}
\DoxyCodeLine{01777 \textcolor{comment}{                    is. */}}
\DoxyCodeLine{01778                     pxCurrentTCB = NULL;}
\DoxyCodeLine{01779                 \}}
\DoxyCodeLine{01780                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01781                 \{}
\DoxyCodeLine{01782                     vTaskSwitchContext();}
\DoxyCodeLine{01783                 \}}
\DoxyCodeLine{01784             \}}
\DoxyCodeLine{01785         \}}
\DoxyCodeLine{01786         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01787         \{}
\DoxyCodeLine{01788             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01789         \}}
\DoxyCodeLine{01790     \}}
\DoxyCodeLine{01791 }
\DoxyCodeLine{01792 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01793 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01794 }
\DoxyCodeLine{01795 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{01796 }
\DoxyCodeLine{01797     \textcolor{keyword}{static} BaseType\_t prvTaskIsTaskSuspended( \textcolor{keyword}{const} TaskHandle\_t xTask )}
\DoxyCodeLine{01798     \{}
\DoxyCodeLine{01799     BaseType\_t xReturn = pdFALSE;}
\DoxyCodeLine{01800     \textcolor{keyword}{const} TCB\_t * \textcolor{keyword}{const} pxTCB = xTask;}
\DoxyCodeLine{01801 }
\DoxyCodeLine{01802         \textcolor{comment}{/* Accesses xPendingReadyList so must be called from a critical}}
\DoxyCodeLine{01803 \textcolor{comment}{        section. */}}
\DoxyCodeLine{01804 }
\DoxyCodeLine{01805         \textcolor{comment}{/* It does not make sense to check if the calling task is suspended. */}}
\DoxyCodeLine{01806         configASSERT( xTask );}
\DoxyCodeLine{01807 }
\DoxyCodeLine{01808         \textcolor{comment}{/* Is the task being resumed actually in the suspended list? */}}
\DoxyCodeLine{01809         \textcolor{keywordflow}{if}( listIS\_CONTAINED\_WITHIN( \&xSuspendedTaskList, \&( pxTCB-\/>xStateListItem ) ) != pdFALSE )}
\DoxyCodeLine{01810         \{}
\DoxyCodeLine{01811             \textcolor{comment}{/* Has the task already been resumed from within an ISR? */}}
\DoxyCodeLine{01812             \textcolor{keywordflow}{if}( listIS\_CONTAINED\_WITHIN( \&xPendingReadyList, \&( pxTCB-\/>xEventListItem ) ) == pdFALSE )}
\DoxyCodeLine{01813             \{}
\DoxyCodeLine{01814                 \textcolor{comment}{/* Is it in the suspended list because it is in the Suspended}}
\DoxyCodeLine{01815 \textcolor{comment}{                state, or because is is blocked with no timeout? */}}
\DoxyCodeLine{01816                 \textcolor{keywordflow}{if}( listIS\_CONTAINED\_WITHIN( NULL, \&( pxTCB-\/>xEventListItem ) ) != pdFALSE ) \textcolor{comment}{/*lint !e961.  The cast is only redundant when NULL is used. */}}
\DoxyCodeLine{01817                 \{}
\DoxyCodeLine{01818                     xReturn = pdTRUE;}
\DoxyCodeLine{01819                 \}}
\DoxyCodeLine{01820                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01821                 \{}
\DoxyCodeLine{01822                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01823                 \}}
\DoxyCodeLine{01824             \}}
\DoxyCodeLine{01825             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01826             \{}
\DoxyCodeLine{01827                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01828             \}}
\DoxyCodeLine{01829         \}}
\DoxyCodeLine{01830         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01831         \{}
\DoxyCodeLine{01832             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01833         \}}
\DoxyCodeLine{01834 }
\DoxyCodeLine{01835         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{01836     \} \textcolor{comment}{/*lint !e818 xTask cannot be a pointer to const because it is a typedef. */}}
\DoxyCodeLine{01837 }
\DoxyCodeLine{01838 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01839 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01840 }
\DoxyCodeLine{01841 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{01842 }
\DoxyCodeLine{01843     \textcolor{keywordtype}{void} vTaskResume( TaskHandle\_t xTaskToResume )}
\DoxyCodeLine{01844     \{}
\DoxyCodeLine{01845     TCB\_t * \textcolor{keyword}{const} pxTCB = xTaskToResume;}
\DoxyCodeLine{01846 }
\DoxyCodeLine{01847         \textcolor{comment}{/* It does not make sense to resume the calling task. */}}
\DoxyCodeLine{01848         configASSERT( xTaskToResume );}
\DoxyCodeLine{01849 }
\DoxyCodeLine{01850         \textcolor{comment}{/* The parameter cannot be NULL as it is impossible to resume the}}
\DoxyCodeLine{01851 \textcolor{comment}{        currently executing task. */}}
\DoxyCodeLine{01852         \textcolor{keywordflow}{if}( ( pxTCB != pxCurrentTCB ) \&\& ( pxTCB != NULL ) )}
\DoxyCodeLine{01853         \{}
\DoxyCodeLine{01854             taskENTER\_CRITICAL();}
\DoxyCodeLine{01855             \{}
\DoxyCodeLine{01856                 \textcolor{keywordflow}{if}( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )}
\DoxyCodeLine{01857                 \{}
\DoxyCodeLine{01858                     traceTASK\_RESUME( pxTCB );}
\DoxyCodeLine{01859 }
\DoxyCodeLine{01860                     \textcolor{comment}{/* The ready list can be accessed even if the scheduler is}}
\DoxyCodeLine{01861 \textcolor{comment}{                    suspended because this is inside a critical section. */}}
\DoxyCodeLine{01862                     ( void ) uxListRemove(  \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{01863                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{01864 }
\DoxyCodeLine{01865                     \textcolor{comment}{/* A higher priority task may have just been resumed. */}}
\DoxyCodeLine{01866                     \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority >= pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{01867                     \{}
\DoxyCodeLine{01868                         \textcolor{comment}{/* This yield may not cause the task just resumed to run,}}
\DoxyCodeLine{01869 \textcolor{comment}{                        but will leave the lists in the correct state for the}}
\DoxyCodeLine{01870 \textcolor{comment}{                        next yield. */}}
\DoxyCodeLine{01871                         taskYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{01872                     \}}
\DoxyCodeLine{01873                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01874                     \{}
\DoxyCodeLine{01875                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01876                     \}}
\DoxyCodeLine{01877                 \}}
\DoxyCodeLine{01878                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01879                 \{}
\DoxyCodeLine{01880                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01881                 \}}
\DoxyCodeLine{01882             \}}
\DoxyCodeLine{01883             taskEXIT\_CRITICAL();}
\DoxyCodeLine{01884         \}}
\DoxyCodeLine{01885         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01886         \{}
\DoxyCodeLine{01887             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01888         \}}
\DoxyCodeLine{01889     \}}
\DoxyCodeLine{01890 }
\DoxyCodeLine{01891 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01892 }
\DoxyCodeLine{01893 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01894 }
\DoxyCodeLine{01895 \textcolor{preprocessor}{\#if ( ( INCLUDE\_xTaskResumeFromISR == 1 ) \&\& ( INCLUDE\_vTaskSuspend == 1 ) )}}
\DoxyCodeLine{01896 }
\DoxyCodeLine{01897     BaseType\_t xTaskResumeFromISR( TaskHandle\_t xTaskToResume )}
\DoxyCodeLine{01898     \{}
\DoxyCodeLine{01899     BaseType\_t xYieldRequired = pdFALSE;}
\DoxyCodeLine{01900     TCB\_t * \textcolor{keyword}{const} pxTCB = xTaskToResume;}
\DoxyCodeLine{01901     UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{01902 }
\DoxyCodeLine{01903         configASSERT( xTaskToResume );}
\DoxyCodeLine{01904 }
\DoxyCodeLine{01905         \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a}}
\DoxyCodeLine{01906 \textcolor{comment}{        maximum system call (or maximum API call) interrupt priority.}}
\DoxyCodeLine{01907 \textcolor{comment}{        Interrupts that are above the maximum system call priority are keep}}
\DoxyCodeLine{01908 \textcolor{comment}{        permanently enabled, even when the RTOS kernel is in a critical section,}}
\DoxyCodeLine{01909 \textcolor{comment}{        but cannot make any calls to FreeRTOS API functions.  If configASSERT()}}
\DoxyCodeLine{01910 \textcolor{comment}{        is defined in FreeRTOSConfig.h then}}
\DoxyCodeLine{01911 \textcolor{comment}{        portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{01912 \textcolor{comment}{        failure if a FreeRTOS API function is called from an interrupt that has}}
\DoxyCodeLine{01913 \textcolor{comment}{        been assigned a priority above the configured maximum system call}}
\DoxyCodeLine{01914 \textcolor{comment}{        priority.  Only FreeRTOS functions that end in FromISR can be called}}
\DoxyCodeLine{01915 \textcolor{comment}{        from interrupts that have been assigned a priority at or (logically)}}
\DoxyCodeLine{01916 \textcolor{comment}{        below the maximum system call interrupt priority.  FreeRTOS maintains a}}
\DoxyCodeLine{01917 \textcolor{comment}{        separate interrupt safe API to ensure interrupt entry is as fast and as}}
\DoxyCodeLine{01918 \textcolor{comment}{        simple as possible.  More information (albeit Cortex-\/M specific) is}}
\DoxyCodeLine{01919 \textcolor{comment}{        provided on the following link:}}
\DoxyCodeLine{01920 \textcolor{comment}{        https://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{01921         portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{01922 }
\DoxyCodeLine{01923         uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{01924         \{}
\DoxyCodeLine{01925             \textcolor{keywordflow}{if}( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )}
\DoxyCodeLine{01926             \{}
\DoxyCodeLine{01927                 traceTASK\_RESUME\_FROM\_ISR( pxTCB );}
\DoxyCodeLine{01928 }
\DoxyCodeLine{01929                 \textcolor{comment}{/* Check the ready lists can be accessed. */}}
\DoxyCodeLine{01930                 \textcolor{keywordflow}{if}( uxSchedulerSuspended == ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{01931                 \{}
\DoxyCodeLine{01932                     \textcolor{comment}{/* Ready lists can be accessed so move the task from the}}
\DoxyCodeLine{01933 \textcolor{comment}{                    suspended list to the ready list directly. */}}
\DoxyCodeLine{01934                     \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority >= pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{01935                     \{}
\DoxyCodeLine{01936                         xYieldRequired = pdTRUE;}
\DoxyCodeLine{01937                     \}}
\DoxyCodeLine{01938                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01939                     \{}
\DoxyCodeLine{01940                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01941                     \}}
\DoxyCodeLine{01942 }
\DoxyCodeLine{01943                     ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{01944                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{01945                 \}}
\DoxyCodeLine{01946                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{01947                 \{}
\DoxyCodeLine{01948                     \textcolor{comment}{/* The delayed or ready lists cannot be accessed so the task}}
\DoxyCodeLine{01949 \textcolor{comment}{                    is held in the pending ready list until the scheduler is}}
\DoxyCodeLine{01950 \textcolor{comment}{                    unsuspended. */}}
\DoxyCodeLine{01951                     vListInsertEnd( \&( xPendingReadyList ), \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{01952                 \}}
\DoxyCodeLine{01953             \}}
\DoxyCodeLine{01954             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01955             \{}
\DoxyCodeLine{01956                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{01957             \}}
\DoxyCodeLine{01958         \}}
\DoxyCodeLine{01959         portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{01960 }
\DoxyCodeLine{01961         \textcolor{keywordflow}{return} xYieldRequired;}
\DoxyCodeLine{01962     \}}
\DoxyCodeLine{01963 }
\DoxyCodeLine{01964 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( INCLUDE\_xTaskResumeFromISR == 1 ) \&\& ( INCLUDE\_vTaskSuspend == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01965 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{01966 }
\DoxyCodeLine{01967 \textcolor{keywordtype}{void} vTaskStartScheduler( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{01968 \{}
\DoxyCodeLine{01969 BaseType\_t xReturn;}
\DoxyCodeLine{01970 }
\DoxyCodeLine{01971     \textcolor{comment}{/* Add the idle task at the lowest priority. */}}
\DoxyCodeLine{01972 \textcolor{preprocessor}{    \#if( configSUPPORT\_STATIC\_ALLOCATION == 1 )}}
\DoxyCodeLine{01973     \{}
\DoxyCodeLine{01974         StaticTask\_t *pxIdleTaskTCBBuffer = NULL;}
\DoxyCodeLine{01975         StackType\_t *pxIdleTaskStackBuffer = NULL;}
\DoxyCodeLine{01976         uint32\_t ulIdleTaskStackSize;}
\DoxyCodeLine{01977 }
\DoxyCodeLine{01978         \textcolor{comment}{/* The Idle task is created using user provided RAM -\/ obtain the}}
\DoxyCodeLine{01979 \textcolor{comment}{        address of the RAM then create the idle task. */}}
\DoxyCodeLine{01980         vApplicationGetIdleTaskMemory( \&pxIdleTaskTCBBuffer, \&pxIdleTaskStackBuffer, \&ulIdleTaskStackSize );}
\DoxyCodeLine{01981         xIdleTaskHandle = xTaskCreateStatic(    prvIdleTask,}
\DoxyCodeLine{01982                                                 configIDLE\_TASK\_NAME,}
\DoxyCodeLine{01983                                                 ulIdleTaskStackSize,}
\DoxyCodeLine{01984                                                 ( \textcolor{keywordtype}{void} * ) NULL, \textcolor{comment}{/*lint !e961.  The cast is not redundant for all compilers. */}}
\DoxyCodeLine{01985                                                 portPRIVILEGE\_BIT, \textcolor{comment}{/* In effect ( tskIDLE\_PRIORITY | portPRIVILEGE\_BIT ), but tskIDLE\_PRIORITY is zero. */}}
\DoxyCodeLine{01986                                                 pxIdleTaskStackBuffer,}
\DoxyCodeLine{01987                                                 pxIdleTaskTCBBuffer ); \textcolor{comment}{/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */}}
\DoxyCodeLine{01988 }
\DoxyCodeLine{01989         \textcolor{keywordflow}{if}( xIdleTaskHandle != NULL )}
\DoxyCodeLine{01990         \{}
\DoxyCodeLine{01991             xReturn = pdPASS;}
\DoxyCodeLine{01992         \}}
\DoxyCodeLine{01993         \textcolor{keywordflow}{else}}
\DoxyCodeLine{01994         \{}
\DoxyCodeLine{01995             xReturn = pdFAIL;}
\DoxyCodeLine{01996         \}}
\DoxyCodeLine{01997     \}}
\DoxyCodeLine{01998 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{01999     \{}
\DoxyCodeLine{02000         \textcolor{comment}{/* The Idle task is being created using dynamically allocated RAM. */}}
\DoxyCodeLine{02001         xReturn = xTaskCreate(  prvIdleTask,}
\DoxyCodeLine{02002                                 configIDLE\_TASK\_NAME,}
\DoxyCodeLine{02003                                 configMINIMAL\_STACK\_SIZE,}
\DoxyCodeLine{02004                                 ( \textcolor{keywordtype}{void} * ) NULL,}
\DoxyCodeLine{02005                                 portPRIVILEGE\_BIT, \textcolor{comment}{/* In effect ( tskIDLE\_PRIORITY | portPRIVILEGE\_BIT ), but tskIDLE\_PRIORITY is zero. */}}
\DoxyCodeLine{02006                                 \&xIdleTaskHandle ); \textcolor{comment}{/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */}}
\DoxyCodeLine{02007     \}}
\DoxyCodeLine{02008 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configSUPPORT\_STATIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02009 }
\DoxyCodeLine{02010 \textcolor{preprocessor}{    \#if ( configUSE\_TIMERS == 1 )}}
\DoxyCodeLine{02011     \{}
\DoxyCodeLine{02012         \textcolor{keywordflow}{if}( xReturn == pdPASS )}
\DoxyCodeLine{02013         \{}
\DoxyCodeLine{02014             xReturn = xTimerCreateTimerTask();}
\DoxyCodeLine{02015         \}}
\DoxyCodeLine{02016         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02017         \{}
\DoxyCodeLine{02018             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02019         \}}
\DoxyCodeLine{02020     \}}
\DoxyCodeLine{02021 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configUSE\_TIMERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02022 }
\DoxyCodeLine{02023     \textcolor{keywordflow}{if}( xReturn == pdPASS )}
\DoxyCodeLine{02024     \{}
\DoxyCodeLine{02025         \textcolor{comment}{/* freertos\_tasks\_c\_additions\_init() should only be called if the user}}
\DoxyCodeLine{02026 \textcolor{comment}{        definable macro FREERTOS\_TASKS\_C\_ADDITIONS\_INIT() is defined, as that is}}
\DoxyCodeLine{02027 \textcolor{comment}{        the only macro called by the function. */}}
\DoxyCodeLine{02028 \textcolor{preprocessor}{        \#ifdef FREERTOS\_TASKS\_C\_ADDITIONS\_INIT}}
\DoxyCodeLine{02029         \{}
\DoxyCodeLine{02030             freertos\_tasks\_c\_additions\_init();}
\DoxyCodeLine{02031         \}}
\DoxyCodeLine{02032 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{02033 }
\DoxyCodeLine{02034         \textcolor{comment}{/* Interrupts are turned off here, to ensure a tick does not occur}}
\DoxyCodeLine{02035 \textcolor{comment}{        before or during the call to xPortStartScheduler().  The stacks of}}
\DoxyCodeLine{02036 \textcolor{comment}{        the created tasks contain a status word with interrupts switched on}}
\DoxyCodeLine{02037 \textcolor{comment}{        so interrupts will automatically get re-\/enabled when the first task}}
\DoxyCodeLine{02038 \textcolor{comment}{        starts to run. */}}
\DoxyCodeLine{02039         portDISABLE\_INTERRUPTS();}
\DoxyCodeLine{02040 }
\DoxyCodeLine{02041 \textcolor{preprocessor}{        \#if ( configUSE\_NEWLIB\_REENTRANT == 1 )}}
\DoxyCodeLine{02042         \{}
\DoxyCodeLine{02043             \textcolor{comment}{/* Switch Newlib's \_impure\_ptr variable to point to the \_reent}}
\DoxyCodeLine{02044 \textcolor{comment}{            structure specific to the task that will run first. */}}
\DoxyCodeLine{02045             \_impure\_ptr = \&( pxCurrentTCB-\/>xNewLib\_reent );}
\DoxyCodeLine{02046         \}}
\DoxyCodeLine{02047 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_NEWLIB\_REENTRANT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02048 }
\DoxyCodeLine{02049         xNextTaskUnblockTime = portMAX\_DELAY;}
\DoxyCodeLine{02050         xSchedulerRunning = pdTRUE;}
\DoxyCodeLine{02051         xTickCount = ( TickType\_t ) configINITIAL\_TICK\_COUNT;}
\DoxyCodeLine{02052 }
\DoxyCodeLine{02053         \textcolor{comment}{/* If configGENERATE\_RUN\_TIME\_STATS is defined then the following}}
\DoxyCodeLine{02054 \textcolor{comment}{        macro must be defined to configure the timer/counter used to generate}}
\DoxyCodeLine{02055 \textcolor{comment}{        the run time counter time base.   NOTE:  If configGENERATE\_RUN\_TIME\_STATS}}
\DoxyCodeLine{02056 \textcolor{comment}{        is set to 0 and the following line fails to build then ensure you do not}}
\DoxyCodeLine{02057 \textcolor{comment}{        have portCONFIGURE\_TIMER\_FOR\_RUN\_TIME\_STATS() defined in your}}
\DoxyCodeLine{02058 \textcolor{comment}{        FreeRTOSConfig.h file. */}}
\DoxyCodeLine{02059         portCONFIGURE\_TIMER\_FOR\_RUN\_TIME\_STATS();}
\DoxyCodeLine{02060 }
\DoxyCodeLine{02061         traceTASK\_SWITCHED\_IN();}
\DoxyCodeLine{02062 }
\DoxyCodeLine{02063         \textcolor{comment}{/* Setting up the timer tick is hardware specific and thus in the}}
\DoxyCodeLine{02064 \textcolor{comment}{        portable interface. */}}
\DoxyCodeLine{02065         \textcolor{keywordflow}{if}( xPortStartScheduler() != pdFALSE )}
\DoxyCodeLine{02066         \{}
\DoxyCodeLine{02067             \textcolor{comment}{/* Should not reach here as if the scheduler is running the}}
\DoxyCodeLine{02068 \textcolor{comment}{            function will not return. */}}
\DoxyCodeLine{02069         \}}
\DoxyCodeLine{02070         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02071         \{}
\DoxyCodeLine{02072             \textcolor{comment}{/* Should only reach here if a task calls xTaskEndScheduler(). */}}
\DoxyCodeLine{02073         \}}
\DoxyCodeLine{02074     \}}
\DoxyCodeLine{02075     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02076     \{}
\DoxyCodeLine{02077         \textcolor{comment}{/* This line will only be reached if the kernel could not be started,}}
\DoxyCodeLine{02078 \textcolor{comment}{        because there was not enough FreeRTOS heap to create the idle task}}
\DoxyCodeLine{02079 \textcolor{comment}{        or the timer task. */}}
\DoxyCodeLine{02080         configASSERT( xReturn != errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY );}
\DoxyCodeLine{02081     \}}
\DoxyCodeLine{02082 }
\DoxyCodeLine{02083     \textcolor{comment}{/* Prevent compiler warnings if INCLUDE\_xTaskGetIdleTaskHandle is set to 0,}}
\DoxyCodeLine{02084 \textcolor{comment}{    meaning xIdleTaskHandle is not used anywhere else. */}}
\DoxyCodeLine{02085     ( void ) xIdleTaskHandle;}
\DoxyCodeLine{02086 \}}
\DoxyCodeLine{02087 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02088 }
\DoxyCodeLine{02089 \textcolor{keywordtype}{void} vTaskEndScheduler( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02090 \{}
\DoxyCodeLine{02091     \textcolor{comment}{/* Stop the scheduler interrupts and call the portable scheduler end}}
\DoxyCodeLine{02092 \textcolor{comment}{    routine so the original ISRs can be restored if necessary.  The port}}
\DoxyCodeLine{02093 \textcolor{comment}{    layer must ensure interrupts enable bit is left in the correct state. */}}
\DoxyCodeLine{02094     portDISABLE\_INTERRUPTS();}
\DoxyCodeLine{02095     xSchedulerRunning = pdFALSE;}
\DoxyCodeLine{02096     vPortEndScheduler();}
\DoxyCodeLine{02097 \}}
\DoxyCodeLine{02098 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02099 }
\DoxyCodeLine{02100 \textcolor{keywordtype}{void} vTaskSuspendAll( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02101 \{}
\DoxyCodeLine{02102     \textcolor{comment}{/* A critical section is not required as the variable is of type}}
\DoxyCodeLine{02103 \textcolor{comment}{    BaseType\_t.  Please read Richard Barry's reply in the following link to a}}
\DoxyCodeLine{02104 \textcolor{comment}{    post in the FreeRTOS support forum before reporting this as a bug! -\/}}
\DoxyCodeLine{02105 \textcolor{comment}{    http://goo.gl/wu4acr */}}
\DoxyCodeLine{02106     ++uxSchedulerSuspended;}
\DoxyCodeLine{02107     portMEMORY\_BARRIER();}
\DoxyCodeLine{02108 \}}
\DoxyCodeLine{02109 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02110 }
\DoxyCodeLine{02111 \textcolor{preprocessor}{\#if ( configUSE\_TICKLESS\_IDLE != 0 )}}
\DoxyCodeLine{02112 }
\DoxyCodeLine{02113     \textcolor{keyword}{static} TickType\_t prvGetExpectedIdleTime( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02114     \{}
\DoxyCodeLine{02115     TickType\_t xReturn;}
\DoxyCodeLine{02116     UBaseType\_t uxHigherPriorityReadyTasks = pdFALSE;}
\DoxyCodeLine{02117 }
\DoxyCodeLine{02118         \textcolor{comment}{/* uxHigherPriorityReadyTasks takes care of the case where}}
\DoxyCodeLine{02119 \textcolor{comment}{        configUSE\_PREEMPTION is 0, so there may be tasks above the idle priority}}
\DoxyCodeLine{02120 \textcolor{comment}{        task that are in the Ready state, even though the idle task is}}
\DoxyCodeLine{02121 \textcolor{comment}{        running. */}}
\DoxyCodeLine{02122 \textcolor{preprocessor}{        \#if( configUSE\_PORT\_OPTIMISED\_TASK\_SELECTION == 0 )}}
\DoxyCodeLine{02123         \{}
\DoxyCodeLine{02124             \textcolor{keywordflow}{if}( uxTopReadyPriority > tskIDLE\_PRIORITY )}
\DoxyCodeLine{02125             \{}
\DoxyCodeLine{02126                 uxHigherPriorityReadyTasks = pdTRUE;}
\DoxyCodeLine{02127             \}}
\DoxyCodeLine{02128         \}}
\DoxyCodeLine{02129 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{02130         \{}
\DoxyCodeLine{02131             \textcolor{keyword}{const} UBaseType\_t uxLeastSignificantBit = ( UBaseType\_t ) 0x01;}
\DoxyCodeLine{02132 }
\DoxyCodeLine{02133             \textcolor{comment}{/* When port optimised task selection is used the uxTopReadyPriority}}
\DoxyCodeLine{02134 \textcolor{comment}{            variable is used as a bit map.  If bits other than the least}}
\DoxyCodeLine{02135 \textcolor{comment}{            significant bit are set then there are tasks that have a priority}}
\DoxyCodeLine{02136 \textcolor{comment}{            above the idle priority that are in the Ready state.  This takes}}
\DoxyCodeLine{02137 \textcolor{comment}{            care of the case where the co-\/operative scheduler is in use. */}}
\DoxyCodeLine{02138             \textcolor{keywordflow}{if}( uxTopReadyPriority > uxLeastSignificantBit )}
\DoxyCodeLine{02139             \{}
\DoxyCodeLine{02140                 uxHigherPriorityReadyTasks = pdTRUE;}
\DoxyCodeLine{02141             \}}
\DoxyCodeLine{02142         \}}
\DoxyCodeLine{02143 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{02144 }
\DoxyCodeLine{02145         \textcolor{keywordflow}{if}( pxCurrentTCB-\/>uxPriority > tskIDLE\_PRIORITY )}
\DoxyCodeLine{02146         \{}
\DoxyCodeLine{02147             xReturn = 0;}
\DoxyCodeLine{02148         \}}
\DoxyCodeLine{02149         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( \&( pxReadyTasksLists[ tskIDLE\_PRIORITY ] ) ) > 1 )}
\DoxyCodeLine{02150         \{}
\DoxyCodeLine{02151             \textcolor{comment}{/* There are other idle priority tasks in the ready state.  If}}
\DoxyCodeLine{02152 \textcolor{comment}{            time slicing is used then the very next tick interrupt must be}}
\DoxyCodeLine{02153 \textcolor{comment}{            processed. */}}
\DoxyCodeLine{02154             xReturn = 0;}
\DoxyCodeLine{02155         \}}
\DoxyCodeLine{02156         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( uxHigherPriorityReadyTasks != pdFALSE )}
\DoxyCodeLine{02157         \{}
\DoxyCodeLine{02158             \textcolor{comment}{/* There are tasks in the Ready state that have a priority above the}}
\DoxyCodeLine{02159 \textcolor{comment}{            idle priority.  This path can only be reached if}}
\DoxyCodeLine{02160 \textcolor{comment}{            configUSE\_PREEMPTION is 0. */}}
\DoxyCodeLine{02161             xReturn = 0;}
\DoxyCodeLine{02162         \}}
\DoxyCodeLine{02163         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02164         \{}
\DoxyCodeLine{02165             xReturn = xNextTaskUnblockTime -\/ xTickCount;}
\DoxyCodeLine{02166         \}}
\DoxyCodeLine{02167 }
\DoxyCodeLine{02168         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02169     \}}
\DoxyCodeLine{02170 }
\DoxyCodeLine{02171 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TICKLESS\_IDLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02172 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02173 }
\DoxyCodeLine{02174 BaseType\_t xTaskResumeAll( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02175 \{}
\DoxyCodeLine{02176 TCB\_t *pxTCB = NULL;}
\DoxyCodeLine{02177 BaseType\_t xAlreadyYielded = pdFALSE;}
\DoxyCodeLine{02178 }
\DoxyCodeLine{02179     \textcolor{comment}{/* If uxSchedulerSuspended is zero then this function does not match a}}
\DoxyCodeLine{02180 \textcolor{comment}{    previous call to vTaskSuspendAll(). */}}
\DoxyCodeLine{02181     configASSERT( uxSchedulerSuspended );}
\DoxyCodeLine{02182 }
\DoxyCodeLine{02183     \textcolor{comment}{/* It is possible that an ISR caused a task to be removed from an event}}
\DoxyCodeLine{02184 \textcolor{comment}{    list while the scheduler was suspended.  If this was the case then the}}
\DoxyCodeLine{02185 \textcolor{comment}{    removed task will have been added to the xPendingReadyList.  Once the}}
\DoxyCodeLine{02186 \textcolor{comment}{    scheduler has been resumed it is safe to move all the pending ready}}
\DoxyCodeLine{02187 \textcolor{comment}{    tasks from this list into their appropriate ready list. */}}
\DoxyCodeLine{02188     taskENTER\_CRITICAL();}
\DoxyCodeLine{02189     \{}
\DoxyCodeLine{02190         -\/-\/uxSchedulerSuspended;}
\DoxyCodeLine{02191 }
\DoxyCodeLine{02192         \textcolor{keywordflow}{if}( uxSchedulerSuspended == ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{02193         \{}
\DoxyCodeLine{02194             \textcolor{keywordflow}{if}( uxCurrentNumberOfTasks > ( UBaseType\_t ) 0U )}
\DoxyCodeLine{02195             \{}
\DoxyCodeLine{02196                 \textcolor{comment}{/* Move any readied tasks from the pending list into the}}
\DoxyCodeLine{02197 \textcolor{comment}{                appropriate ready list. */}}
\DoxyCodeLine{02198                 \textcolor{keywordflow}{while}( listLIST\_IS\_EMPTY( \&xPendingReadyList ) == pdFALSE )}
\DoxyCodeLine{02199                 \{}
\DoxyCodeLine{02200                     pxTCB = listGET\_OWNER\_OF\_HEAD\_ENTRY( ( \&xPendingReadyList ) ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{02201                     ( void ) uxListRemove( \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{02202                     ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{02203                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{02204 }
\DoxyCodeLine{02205                     \textcolor{comment}{/* If the moved task has a priority higher than the current}}
\DoxyCodeLine{02206 \textcolor{comment}{                    task then a yield must be performed. */}}
\DoxyCodeLine{02207                     \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority >= pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{02208                     \{}
\DoxyCodeLine{02209                         xYieldPending = pdTRUE;}
\DoxyCodeLine{02210                     \}}
\DoxyCodeLine{02211                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02212                     \{}
\DoxyCodeLine{02213                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02214                     \}}
\DoxyCodeLine{02215                 \}}
\DoxyCodeLine{02216 }
\DoxyCodeLine{02217                 \textcolor{keywordflow}{if}( pxTCB != NULL )}
\DoxyCodeLine{02218                 \{}
\DoxyCodeLine{02219                     \textcolor{comment}{/* A task was unblocked while the scheduler was suspended,}}
\DoxyCodeLine{02220 \textcolor{comment}{                    which may have prevented the next unblock time from being}}
\DoxyCodeLine{02221 \textcolor{comment}{                    re-\/calculated, in which case re-\/calculate it now.  Mainly}}
\DoxyCodeLine{02222 \textcolor{comment}{                    important for low power tickless implementations, where}}
\DoxyCodeLine{02223 \textcolor{comment}{                    this can prevent an unnecessary exit from low power}}
\DoxyCodeLine{02224 \textcolor{comment}{                    state. */}}
\DoxyCodeLine{02225                     prvResetNextTaskUnblockTime();}
\DoxyCodeLine{02226                 \}}
\DoxyCodeLine{02227 }
\DoxyCodeLine{02228                 \textcolor{comment}{/* If any ticks occurred while the scheduler was suspended then}}
\DoxyCodeLine{02229 \textcolor{comment}{                they should be processed now.  This ensures the tick count does}}
\DoxyCodeLine{02230 \textcolor{comment}{                not slip, and that any delayed tasks are resumed at the correct}}
\DoxyCodeLine{02231 \textcolor{comment}{                time. */}}
\DoxyCodeLine{02232                 \{}
\DoxyCodeLine{02233                     UBaseType\_t uxPendedCounts = uxPendedTicks; \textcolor{comment}{/* Non-\/volatile copy. */}}
\DoxyCodeLine{02234 }
\DoxyCodeLine{02235                     \textcolor{keywordflow}{if}( uxPendedCounts > ( UBaseType\_t ) 0U )}
\DoxyCodeLine{02236                     \{}
\DoxyCodeLine{02237                         \textcolor{keywordflow}{do}}
\DoxyCodeLine{02238                         \{}
\DoxyCodeLine{02239                             \textcolor{keywordflow}{if}( xTaskIncrementTick() != pdFALSE )}
\DoxyCodeLine{02240                             \{}
\DoxyCodeLine{02241                                 xYieldPending = pdTRUE;}
\DoxyCodeLine{02242                             \}}
\DoxyCodeLine{02243                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02244                             \{}
\DoxyCodeLine{02245                                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02246                             \}}
\DoxyCodeLine{02247                             -\/-\/uxPendedCounts;}
\DoxyCodeLine{02248                         \} \textcolor{keywordflow}{while}( uxPendedCounts > ( UBaseType\_t ) 0U );}
\DoxyCodeLine{02249 }
\DoxyCodeLine{02250                         uxPendedTicks = 0;}
\DoxyCodeLine{02251                     \}}
\DoxyCodeLine{02252                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02253                     \{}
\DoxyCodeLine{02254                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02255                     \}}
\DoxyCodeLine{02256                 \}}
\DoxyCodeLine{02257 }
\DoxyCodeLine{02258                 \textcolor{keywordflow}{if}( xYieldPending != pdFALSE )}
\DoxyCodeLine{02259                 \{}
\DoxyCodeLine{02260 \textcolor{preprocessor}{                    \#if( configUSE\_PREEMPTION != 0 )}}
\DoxyCodeLine{02261                     \{}
\DoxyCodeLine{02262                         xAlreadyYielded = pdTRUE;}
\DoxyCodeLine{02263                     \}}
\DoxyCodeLine{02264 \textcolor{preprocessor}{                    \#endif}}
\DoxyCodeLine{02265                     taskYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{02266                 \}}
\DoxyCodeLine{02267                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02268                 \{}
\DoxyCodeLine{02269                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02270                 \}}
\DoxyCodeLine{02271             \}}
\DoxyCodeLine{02272         \}}
\DoxyCodeLine{02273         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02274         \{}
\DoxyCodeLine{02275             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02276         \}}
\DoxyCodeLine{02277     \}}
\DoxyCodeLine{02278     taskEXIT\_CRITICAL();}
\DoxyCodeLine{02279 }
\DoxyCodeLine{02280     \textcolor{keywordflow}{return} xAlreadyYielded;}
\DoxyCodeLine{02281 \}}
\DoxyCodeLine{02282 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02283 }
\DoxyCodeLine{02284 TickType\_t xTaskGetTickCount( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02285 \{}
\DoxyCodeLine{02286 TickType\_t xTicks;}
\DoxyCodeLine{02287 }
\DoxyCodeLine{02288     \textcolor{comment}{/* Critical section required if running on a 16 bit processor. */}}
\DoxyCodeLine{02289     portTICK\_TYPE\_ENTER\_CRITICAL();}
\DoxyCodeLine{02290     \{}
\DoxyCodeLine{02291         xTicks = xTickCount;}
\DoxyCodeLine{02292     \}}
\DoxyCodeLine{02293     portTICK\_TYPE\_EXIT\_CRITICAL();}
\DoxyCodeLine{02294 }
\DoxyCodeLine{02295     \textcolor{keywordflow}{return} xTicks;}
\DoxyCodeLine{02296 \}}
\DoxyCodeLine{02297 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02298 }
\DoxyCodeLine{02299 TickType\_t xTaskGetTickCountFromISR( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02300 \{}
\DoxyCodeLine{02301 TickType\_t xReturn;}
\DoxyCodeLine{02302 UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{02303 }
\DoxyCodeLine{02304     \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a maximum}}
\DoxyCodeLine{02305 \textcolor{comment}{    system call (or maximum API call) interrupt priority.  Interrupts that are}}
\DoxyCodeLine{02306 \textcolor{comment}{    above the maximum system call priority are kept permanently enabled, even}}
\DoxyCodeLine{02307 \textcolor{comment}{    when the RTOS kernel is in a critical section, but cannot make any calls to}}
\DoxyCodeLine{02308 \textcolor{comment}{    FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h}}
\DoxyCodeLine{02309 \textcolor{comment}{    then portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{02310 \textcolor{comment}{    failure if a FreeRTOS API function is called from an interrupt that has been}}
\DoxyCodeLine{02311 \textcolor{comment}{    assigned a priority above the configured maximum system call priority.}}
\DoxyCodeLine{02312 \textcolor{comment}{    Only FreeRTOS functions that end in FromISR can be called from interrupts}}
\DoxyCodeLine{02313 \textcolor{comment}{    that have been assigned a priority at or (logically) below the maximum}}
\DoxyCodeLine{02314 \textcolor{comment}{    system call interrupt priority.  FreeRTOS maintains a separate interrupt}}
\DoxyCodeLine{02315 \textcolor{comment}{    safe API to ensure interrupt entry is as fast and as simple as possible.}}
\DoxyCodeLine{02316 \textcolor{comment}{    More information (albeit Cortex-\/M specific) is provided on the following}}
\DoxyCodeLine{02317 \textcolor{comment}{    link: https://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{02318     portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{02319 }
\DoxyCodeLine{02320     uxSavedInterruptStatus = portTICK\_TYPE\_SET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{02321     \{}
\DoxyCodeLine{02322         xReturn = xTickCount;}
\DoxyCodeLine{02323     \}}
\DoxyCodeLine{02324     portTICK\_TYPE\_CLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{02325 }
\DoxyCodeLine{02326     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02327 \}}
\DoxyCodeLine{02328 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02329 }
\DoxyCodeLine{02330 UBaseType\_t uxTaskGetNumberOfTasks( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02331 \{}
\DoxyCodeLine{02332     \textcolor{comment}{/* A critical section is not required because the variables are of type}}
\DoxyCodeLine{02333 \textcolor{comment}{    BaseType\_t. */}}
\DoxyCodeLine{02334     \textcolor{keywordflow}{return} uxCurrentNumberOfTasks;}
\DoxyCodeLine{02335 \}}
\DoxyCodeLine{02336 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02337 }
\DoxyCodeLine{02338 \textcolor{keywordtype}{char} *pcTaskGetName( TaskHandle\_t xTaskToQuery ) \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{02339 \{}
\DoxyCodeLine{02340 TCB\_t *pxTCB;}
\DoxyCodeLine{02341 }
\DoxyCodeLine{02342     \textcolor{comment}{/* If null is passed in here then the name of the calling task is being}}
\DoxyCodeLine{02343 \textcolor{comment}{    queried. */}}
\DoxyCodeLine{02344     pxTCB = prvGetTCBFromHandle( xTaskToQuery );}
\DoxyCodeLine{02345     configASSERT( pxTCB );}
\DoxyCodeLine{02346     \textcolor{keywordflow}{return} \&( pxTCB-\/>pcTaskName[ 0 ] );}
\DoxyCodeLine{02347 \}}
\DoxyCodeLine{02348 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02349 }
\DoxyCodeLine{02350 \textcolor{preprocessor}{\#if ( INCLUDE\_xTaskGetHandle == 1 )}}
\DoxyCodeLine{02351 }
\DoxyCodeLine{02352     \textcolor{keyword}{static} TCB\_t *prvSearchForNameWithinSingleList( List\_t *pxList, \textcolor{keyword}{const} \textcolor{keywordtype}{char} pcNameToQuery[] )}
\DoxyCodeLine{02353     \{}
\DoxyCodeLine{02354     TCB\_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;}
\DoxyCodeLine{02355     UBaseType\_t x;}
\DoxyCodeLine{02356     \textcolor{keywordtype}{char} cNextChar;}
\DoxyCodeLine{02357     BaseType\_t xBreakLoop;}
\DoxyCodeLine{02358 }
\DoxyCodeLine{02359         \textcolor{comment}{/* This function is called with the scheduler suspended. */}}
\DoxyCodeLine{02360 }
\DoxyCodeLine{02361         \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( pxList ) > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{02362         \{}
\DoxyCodeLine{02363             listGET\_OWNER\_OF\_NEXT\_ENTRY( pxFirstTCB, pxList );  \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{02364 }
\DoxyCodeLine{02365             \textcolor{keywordflow}{do}}
\DoxyCodeLine{02366             \{}
\DoxyCodeLine{02367                 listGET\_OWNER\_OF\_NEXT\_ENTRY( pxNextTCB, pxList ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{02368 }
\DoxyCodeLine{02369                 \textcolor{comment}{/* Check each character in the name looking for a match or}}
\DoxyCodeLine{02370 \textcolor{comment}{                mismatch. */}}
\DoxyCodeLine{02371                 xBreakLoop = pdFALSE;}
\DoxyCodeLine{02372                 \textcolor{keywordflow}{for}( x = ( UBaseType\_t ) 0; x < ( UBaseType\_t ) configMAX\_TASK\_NAME\_LEN; x++ )}
\DoxyCodeLine{02373                 \{}
\DoxyCodeLine{02374                     cNextChar = pxNextTCB-\/>pcTaskName[ x ];}
\DoxyCodeLine{02375 }
\DoxyCodeLine{02376                     \textcolor{keywordflow}{if}( cNextChar != pcNameToQuery[ x ] )}
\DoxyCodeLine{02377                     \{}
\DoxyCodeLine{02378                         \textcolor{comment}{/* Characters didn't match. */}}
\DoxyCodeLine{02379                         xBreakLoop = pdTRUE;}
\DoxyCodeLine{02380                     \}}
\DoxyCodeLine{02381                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( cNextChar == ( \textcolor{keywordtype}{char} ) 0x00 )}
\DoxyCodeLine{02382                     \{}
\DoxyCodeLine{02383                         \textcolor{comment}{/* Both strings terminated, a match must have been}}
\DoxyCodeLine{02384 \textcolor{comment}{                        found. */}}
\DoxyCodeLine{02385                         pxReturn = pxNextTCB;}
\DoxyCodeLine{02386                         xBreakLoop = pdTRUE;}
\DoxyCodeLine{02387                     \}}
\DoxyCodeLine{02388                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02389                     \{}
\DoxyCodeLine{02390                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02391                     \}}
\DoxyCodeLine{02392 }
\DoxyCodeLine{02393                     \textcolor{keywordflow}{if}( xBreakLoop != pdFALSE )}
\DoxyCodeLine{02394                     \{}
\DoxyCodeLine{02395                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{02396                     \}}
\DoxyCodeLine{02397                 \}}
\DoxyCodeLine{02398 }
\DoxyCodeLine{02399                 \textcolor{keywordflow}{if}( pxReturn != NULL )}
\DoxyCodeLine{02400                 \{}
\DoxyCodeLine{02401                     \textcolor{comment}{/* The handle has been found. */}}
\DoxyCodeLine{02402                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{02403                 \}}
\DoxyCodeLine{02404 }
\DoxyCodeLine{02405             \} \textcolor{keywordflow}{while}( pxNextTCB != pxFirstTCB );}
\DoxyCodeLine{02406         \}}
\DoxyCodeLine{02407         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02408         \{}
\DoxyCodeLine{02409             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02410         \}}
\DoxyCodeLine{02411 }
\DoxyCodeLine{02412         \textcolor{keywordflow}{return} pxReturn;}
\DoxyCodeLine{02413     \}}
\DoxyCodeLine{02414 }
\DoxyCodeLine{02415 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_xTaskGetHandle */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02416 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02417 }
\DoxyCodeLine{02418 \textcolor{preprocessor}{\#if ( INCLUDE\_xTaskGetHandle == 1 )}}
\DoxyCodeLine{02419 }
\DoxyCodeLine{02420     TaskHandle\_t xTaskGetHandle( \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pcNameToQuery ) \textcolor{comment}{/*lint !e971 Unqualified char types are allowed for strings and single characters only. */}}
\DoxyCodeLine{02421     \{}
\DoxyCodeLine{02422     UBaseType\_t uxQueue = configMAX\_PRIORITIES;}
\DoxyCodeLine{02423     TCB\_t* pxTCB;}
\DoxyCodeLine{02424 }
\DoxyCodeLine{02425         \textcolor{comment}{/* Task names will be truncated to configMAX\_TASK\_NAME\_LEN -\/ 1 bytes. */}}
\DoxyCodeLine{02426         configASSERT( strlen( pcNameToQuery ) < configMAX\_TASK\_NAME\_LEN );}
\DoxyCodeLine{02427 }
\DoxyCodeLine{02428         vTaskSuspendAll();}
\DoxyCodeLine{02429         \{}
\DoxyCodeLine{02430             \textcolor{comment}{/* Search the ready lists. */}}
\DoxyCodeLine{02431             \textcolor{keywordflow}{do}}
\DoxyCodeLine{02432             \{}
\DoxyCodeLine{02433                 uxQueue-\/-\/;}
\DoxyCodeLine{02434                 pxTCB = prvSearchForNameWithinSingleList( ( List\_t * ) \&( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );}
\DoxyCodeLine{02435 }
\DoxyCodeLine{02436                 \textcolor{keywordflow}{if}( pxTCB != NULL )}
\DoxyCodeLine{02437                 \{}
\DoxyCodeLine{02438                     \textcolor{comment}{/* Found the handle. */}}
\DoxyCodeLine{02439                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{02440                 \}}
\DoxyCodeLine{02441 }
\DoxyCodeLine{02442             \} \textcolor{keywordflow}{while}( uxQueue > ( UBaseType\_t ) tskIDLE\_PRIORITY ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{02443 }
\DoxyCodeLine{02444             \textcolor{comment}{/* Search the delayed lists. */}}
\DoxyCodeLine{02445             \textcolor{keywordflow}{if}( pxTCB == NULL )}
\DoxyCodeLine{02446             \{}
\DoxyCodeLine{02447                 pxTCB = prvSearchForNameWithinSingleList( ( List\_t * ) pxDelayedTaskList, pcNameToQuery );}
\DoxyCodeLine{02448             \}}
\DoxyCodeLine{02449 }
\DoxyCodeLine{02450             \textcolor{keywordflow}{if}( pxTCB == NULL )}
\DoxyCodeLine{02451             \{}
\DoxyCodeLine{02452                 pxTCB = prvSearchForNameWithinSingleList( ( List\_t * ) pxOverflowDelayedTaskList, pcNameToQuery );}
\DoxyCodeLine{02453             \}}
\DoxyCodeLine{02454 }
\DoxyCodeLine{02455 \textcolor{preprocessor}{            \#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{02456             \{}
\DoxyCodeLine{02457                 \textcolor{keywordflow}{if}( pxTCB == NULL )}
\DoxyCodeLine{02458                 \{}
\DoxyCodeLine{02459                     \textcolor{comment}{/* Search the suspended list. */}}
\DoxyCodeLine{02460                     pxTCB = prvSearchForNameWithinSingleList( \&xSuspendedTaskList, pcNameToQuery );}
\DoxyCodeLine{02461                 \}}
\DoxyCodeLine{02462             \}}
\DoxyCodeLine{02463 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{02464 }
\DoxyCodeLine{02465 \textcolor{preprocessor}{            \#if( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{02466             \{}
\DoxyCodeLine{02467                 \textcolor{keywordflow}{if}( pxTCB == NULL )}
\DoxyCodeLine{02468                 \{}
\DoxyCodeLine{02469                     \textcolor{comment}{/* Search the deleted list. */}}
\DoxyCodeLine{02470                     pxTCB = prvSearchForNameWithinSingleList( \&xTasksWaitingTermination, pcNameToQuery );}
\DoxyCodeLine{02471                 \}}
\DoxyCodeLine{02472             \}}
\DoxyCodeLine{02473 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{02474         \}}
\DoxyCodeLine{02475         ( void ) xTaskResumeAll();}
\DoxyCodeLine{02476 }
\DoxyCodeLine{02477         \textcolor{keywordflow}{return} pxTCB;}
\DoxyCodeLine{02478     \}}
\DoxyCodeLine{02479 }
\DoxyCodeLine{02480 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_xTaskGetHandle */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02481 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02482 }
\DoxyCodeLine{02483 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{02484 }
\DoxyCodeLine{02485     UBaseType\_t uxTaskGetSystemState( TaskStatus\_t * \textcolor{keyword}{const} pxTaskStatusArray, \textcolor{keyword}{const} UBaseType\_t uxArraySize, uint32\_t * \textcolor{keyword}{const} pulTotalRunTime )}
\DoxyCodeLine{02486     \{}
\DoxyCodeLine{02487     UBaseType\_t uxTask = 0, uxQueue = configMAX\_PRIORITIES;}
\DoxyCodeLine{02488 }
\DoxyCodeLine{02489         vTaskSuspendAll();}
\DoxyCodeLine{02490         \{}
\DoxyCodeLine{02491             \textcolor{comment}{/* Is there a space in the array for each task in the system? */}}
\DoxyCodeLine{02492             \textcolor{keywordflow}{if}( uxArraySize >= uxCurrentNumberOfTasks )}
\DoxyCodeLine{02493             \{}
\DoxyCodeLine{02494                 \textcolor{comment}{/* Fill in an TaskStatus\_t structure with information on each}}
\DoxyCodeLine{02495 \textcolor{comment}{                task in the Ready state. */}}
\DoxyCodeLine{02496                 \textcolor{keywordflow}{do}}
\DoxyCodeLine{02497                 \{}
\DoxyCodeLine{02498                     uxQueue-\/-\/;}
\DoxyCodeLine{02499                     uxTask += prvListTasksWithinSingleList( \&( pxTaskStatusArray[ uxTask ] ), \&( pxReadyTasksLists[ uxQueue ] ), eReady );}
\DoxyCodeLine{02500 }
\DoxyCodeLine{02501                 \} \textcolor{keywordflow}{while}( uxQueue > ( UBaseType\_t ) tskIDLE\_PRIORITY ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{02502 }
\DoxyCodeLine{02503                 \textcolor{comment}{/* Fill in an TaskStatus\_t structure with information on each}}
\DoxyCodeLine{02504 \textcolor{comment}{                task in the Blocked state. */}}
\DoxyCodeLine{02505                 uxTask += prvListTasksWithinSingleList( \&( pxTaskStatusArray[ uxTask ] ), ( List\_t * ) pxDelayedTaskList, eBlocked );}
\DoxyCodeLine{02506                 uxTask += prvListTasksWithinSingleList( \&( pxTaskStatusArray[ uxTask ] ), ( List\_t * ) pxOverflowDelayedTaskList, eBlocked );}
\DoxyCodeLine{02507 }
\DoxyCodeLine{02508 \textcolor{preprocessor}{                \#if( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{02509                 \{}
\DoxyCodeLine{02510                     \textcolor{comment}{/* Fill in an TaskStatus\_t structure with information on}}
\DoxyCodeLine{02511 \textcolor{comment}{                    each task that has been deleted but not yet cleaned up. */}}
\DoxyCodeLine{02512                     uxTask += prvListTasksWithinSingleList( \&( pxTaskStatusArray[ uxTask ] ), \&xTasksWaitingTermination, eDeleted );}
\DoxyCodeLine{02513                 \}}
\DoxyCodeLine{02514 \textcolor{preprocessor}{                \#endif}}
\DoxyCodeLine{02515 }
\DoxyCodeLine{02516 \textcolor{preprocessor}{                \#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{02517                 \{}
\DoxyCodeLine{02518                     \textcolor{comment}{/* Fill in an TaskStatus\_t structure with information on}}
\DoxyCodeLine{02519 \textcolor{comment}{                    each task in the Suspended state. */}}
\DoxyCodeLine{02520                     uxTask += prvListTasksWithinSingleList( \&( pxTaskStatusArray[ uxTask ] ), \&xSuspendedTaskList, eSuspended );}
\DoxyCodeLine{02521                 \}}
\DoxyCodeLine{02522 \textcolor{preprocessor}{                \#endif}}
\DoxyCodeLine{02523 }
\DoxyCodeLine{02524 \textcolor{preprocessor}{                \#if ( configGENERATE\_RUN\_TIME\_STATS == 1)}}
\DoxyCodeLine{02525                 \{}
\DoxyCodeLine{02526                     \textcolor{keywordflow}{if}( pulTotalRunTime != NULL )}
\DoxyCodeLine{02527                     \{}
\DoxyCodeLine{02528 \textcolor{preprocessor}{                        \#ifdef portALT\_GET\_RUN\_TIME\_COUNTER\_VALUE}}
\DoxyCodeLine{02529                             portALT\_GET\_RUN\_TIME\_COUNTER\_VALUE( ( *pulTotalRunTime ) );}
\DoxyCodeLine{02530 \textcolor{preprocessor}{                        \#else}}
\DoxyCodeLine{02531                             *pulTotalRunTime = portGET\_RUN\_TIME\_COUNTER\_VALUE();}
\DoxyCodeLine{02532 \textcolor{preprocessor}{                        \#endif}}
\DoxyCodeLine{02533                     \}}
\DoxyCodeLine{02534                 \}}
\DoxyCodeLine{02535 \textcolor{preprocessor}{                \#else}}
\DoxyCodeLine{02536                 \{}
\DoxyCodeLine{02537                     \textcolor{keywordflow}{if}( pulTotalRunTime != NULL )}
\DoxyCodeLine{02538                     \{}
\DoxyCodeLine{02539                         *pulTotalRunTime = 0;}
\DoxyCodeLine{02540                     \}}
\DoxyCodeLine{02541                 \}}
\DoxyCodeLine{02542 \textcolor{preprocessor}{                \#endif}}
\DoxyCodeLine{02543             \}}
\DoxyCodeLine{02544             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02545             \{}
\DoxyCodeLine{02546                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02547             \}}
\DoxyCodeLine{02548         \}}
\DoxyCodeLine{02549         ( void ) xTaskResumeAll();}
\DoxyCodeLine{02550 }
\DoxyCodeLine{02551         \textcolor{keywordflow}{return} uxTask;}
\DoxyCodeLine{02552     \}}
\DoxyCodeLine{02553 }
\DoxyCodeLine{02554 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02555 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02556 }
\DoxyCodeLine{02557 \textcolor{preprocessor}{\#if ( INCLUDE\_xTaskGetIdleTaskHandle == 1 )}}
\DoxyCodeLine{02558 }
\DoxyCodeLine{02559     TaskHandle\_t xTaskGetIdleTaskHandle( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02560     \{}
\DoxyCodeLine{02561         \textcolor{comment}{/* If xTaskGetIdleTaskHandle() is called before the scheduler has been}}
\DoxyCodeLine{02562 \textcolor{comment}{        started, then xIdleTaskHandle will be NULL. */}}
\DoxyCodeLine{02563         configASSERT( ( xIdleTaskHandle != NULL ) );}
\DoxyCodeLine{02564         \textcolor{keywordflow}{return} xIdleTaskHandle;}
\DoxyCodeLine{02565     \}}
\DoxyCodeLine{02566 }
\DoxyCodeLine{02567 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_xTaskGetIdleTaskHandle */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02568 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02569 }
\DoxyCodeLine{02570 \textcolor{comment}{/* This conditional compilation should use inequality to 0, not equality to 1.}}
\DoxyCodeLine{02571 \textcolor{comment}{This is to ensure vTaskStepTick() is available when user defined low power mode}}
\DoxyCodeLine{02572 \textcolor{comment}{implementations require configUSE\_TICKLESS\_IDLE to be set to a value other than}}
\DoxyCodeLine{02573 \textcolor{comment}{1. */}}
\DoxyCodeLine{02574 \textcolor{preprocessor}{\#if ( configUSE\_TICKLESS\_IDLE != 0 )}}
\DoxyCodeLine{02575 }
\DoxyCodeLine{02576     \textcolor{keywordtype}{void} vTaskStepTick( \textcolor{keyword}{const} TickType\_t xTicksToJump )}
\DoxyCodeLine{02577     \{}
\DoxyCodeLine{02578         \textcolor{comment}{/* Correct the tick count value after a period during which the tick}}
\DoxyCodeLine{02579 \textcolor{comment}{        was suppressed.  Note this does *not* call the tick hook function for}}
\DoxyCodeLine{02580 \textcolor{comment}{        each stepped tick. */}}
\DoxyCodeLine{02581         configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );}
\DoxyCodeLine{02582         xTickCount += xTicksToJump;}
\DoxyCodeLine{02583         traceINCREASE\_TICK\_COUNT( xTicksToJump );}
\DoxyCodeLine{02584     \}}
\DoxyCodeLine{02585 }
\DoxyCodeLine{02586 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TICKLESS\_IDLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02587 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02588 }
\DoxyCodeLine{02589 \textcolor{preprocessor}{\#if ( INCLUDE\_xTaskAbortDelay == 1 )}}
\DoxyCodeLine{02590 }
\DoxyCodeLine{02591     BaseType\_t xTaskAbortDelay( TaskHandle\_t xTask )}
\DoxyCodeLine{02592     \{}
\DoxyCodeLine{02593     TCB\_t *pxTCB = xTask;}
\DoxyCodeLine{02594     BaseType\_t xReturn;}
\DoxyCodeLine{02595 }
\DoxyCodeLine{02596         configASSERT( pxTCB );}
\DoxyCodeLine{02597 }
\DoxyCodeLine{02598         vTaskSuspendAll();}
\DoxyCodeLine{02599         \{}
\DoxyCodeLine{02600             \textcolor{comment}{/* A task can only be prematurely removed from the Blocked state if}}
\DoxyCodeLine{02601 \textcolor{comment}{            it is actually in the Blocked state. */}}
\DoxyCodeLine{02602             \textcolor{keywordflow}{if}( eTaskGetState( xTask ) == eBlocked )}
\DoxyCodeLine{02603             \{}
\DoxyCodeLine{02604                 xReturn = pdPASS;}
\DoxyCodeLine{02605 }
\DoxyCodeLine{02606                 \textcolor{comment}{/* Remove the reference to the task from the blocked list.  An}}
\DoxyCodeLine{02607 \textcolor{comment}{                interrupt won't touch the xStateListItem because the}}
\DoxyCodeLine{02608 \textcolor{comment}{                scheduler is suspended. */}}
\DoxyCodeLine{02609                 ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{02610 }
\DoxyCodeLine{02611                 \textcolor{comment}{/* Is the task waiting on an event also?  If so remove it from}}
\DoxyCodeLine{02612 \textcolor{comment}{                the event list too.  Interrupts can touch the event list item,}}
\DoxyCodeLine{02613 \textcolor{comment}{                even though the scheduler is suspended, so a critical section}}
\DoxyCodeLine{02614 \textcolor{comment}{                is used. */}}
\DoxyCodeLine{02615                 taskENTER\_CRITICAL();}
\DoxyCodeLine{02616                 \{}
\DoxyCodeLine{02617                     \textcolor{keywordflow}{if}( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) != NULL )}
\DoxyCodeLine{02618                     \{}
\DoxyCodeLine{02619                         ( void ) uxListRemove( \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{02620                         pxTCB-\/>ucDelayAborted = pdTRUE;}
\DoxyCodeLine{02621                     \}}
\DoxyCodeLine{02622                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02623                     \{}
\DoxyCodeLine{02624                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02625                     \}}
\DoxyCodeLine{02626                 \}}
\DoxyCodeLine{02627                 taskEXIT\_CRITICAL();}
\DoxyCodeLine{02628 }
\DoxyCodeLine{02629                 \textcolor{comment}{/* Place the unblocked task into the appropriate ready list. */}}
\DoxyCodeLine{02630                 prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{02631 }
\DoxyCodeLine{02632                 \textcolor{comment}{/* A task being unblocked cannot cause an immediate context}}
\DoxyCodeLine{02633 \textcolor{comment}{                switch if preemption is turned off. */}}
\DoxyCodeLine{02634 \textcolor{preprocessor}{                \#if (  configUSE\_PREEMPTION == 1 )}}
\DoxyCodeLine{02635                 \{}
\DoxyCodeLine{02636                     \textcolor{comment}{/* Preemption is on, but a context switch should only be}}
\DoxyCodeLine{02637 \textcolor{comment}{                    performed if the unblocked task has a priority that is}}
\DoxyCodeLine{02638 \textcolor{comment}{                    equal to or higher than the currently executing task. */}}
\DoxyCodeLine{02639                     \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority > pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{02640                     \{}
\DoxyCodeLine{02641                         \textcolor{comment}{/* Pend the yield to be performed when the scheduler}}
\DoxyCodeLine{02642 \textcolor{comment}{                        is unsuspended. */}}
\DoxyCodeLine{02643                         xYieldPending = pdTRUE;}
\DoxyCodeLine{02644                     \}}
\DoxyCodeLine{02645                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02646                     \{}
\DoxyCodeLine{02647                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02648                     \}}
\DoxyCodeLine{02649                 \}}
\DoxyCodeLine{02650 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* configUSE\_PREEMPTION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02651             \}}
\DoxyCodeLine{02652             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02653             \{}
\DoxyCodeLine{02654                 xReturn = pdFAIL;}
\DoxyCodeLine{02655             \}}
\DoxyCodeLine{02656         \}}
\DoxyCodeLine{02657         ( void ) xTaskResumeAll();}
\DoxyCodeLine{02658 }
\DoxyCodeLine{02659         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02660     \}}
\DoxyCodeLine{02661 }
\DoxyCodeLine{02662 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_xTaskAbortDelay */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02663 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02664 }
\DoxyCodeLine{02665 BaseType\_t xTaskIncrementTick( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02666 \{}
\DoxyCodeLine{02667 TCB\_t * pxTCB;}
\DoxyCodeLine{02668 TickType\_t xItemValue;}
\DoxyCodeLine{02669 BaseType\_t xSwitchRequired = pdFALSE;}
\DoxyCodeLine{02670 }
\DoxyCodeLine{02671     \textcolor{comment}{/* Called by the portable layer each time a tick interrupt occurs.}}
\DoxyCodeLine{02672 \textcolor{comment}{    Increments the tick then checks to see if the new tick value will cause any}}
\DoxyCodeLine{02673 \textcolor{comment}{    tasks to be unblocked. */}}
\DoxyCodeLine{02674     traceTASK\_INCREMENT\_TICK( xTickCount );}
\DoxyCodeLine{02675     \textcolor{keywordflow}{if}( uxSchedulerSuspended == ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{02676     \{}
\DoxyCodeLine{02677         \textcolor{comment}{/* Minor optimisation.  The tick count cannot change in this}}
\DoxyCodeLine{02678 \textcolor{comment}{        block. */}}
\DoxyCodeLine{02679         \textcolor{keyword}{const} TickType\_t xConstTickCount = xTickCount + ( TickType\_t ) 1;}
\DoxyCodeLine{02680 }
\DoxyCodeLine{02681         \textcolor{comment}{/* Increment the RTOS tick, switching the delayed and overflowed}}
\DoxyCodeLine{02682 \textcolor{comment}{        delayed lists if it wraps to 0. */}}
\DoxyCodeLine{02683         xTickCount = xConstTickCount;}
\DoxyCodeLine{02684 }
\DoxyCodeLine{02685         \textcolor{keywordflow}{if}( xConstTickCount == ( TickType\_t ) 0U ) \textcolor{comment}{/*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */}}
\DoxyCodeLine{02686         \{}
\DoxyCodeLine{02687             taskSWITCH\_DELAYED\_LISTS();}
\DoxyCodeLine{02688         \}}
\DoxyCodeLine{02689         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02690         \{}
\DoxyCodeLine{02691             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02692         \}}
\DoxyCodeLine{02693 }
\DoxyCodeLine{02694         \textcolor{comment}{/* See if this tick has made a timeout expire.  Tasks are stored in}}
\DoxyCodeLine{02695 \textcolor{comment}{        the queue in the order of their wake time -\/ meaning once one task}}
\DoxyCodeLine{02696 \textcolor{comment}{        has been found whose block time has not expired there is no need to}}
\DoxyCodeLine{02697 \textcolor{comment}{        look any further down the list. */}}
\DoxyCodeLine{02698         \textcolor{keywordflow}{if}( xConstTickCount >= xNextTaskUnblockTime )}
\DoxyCodeLine{02699         \{}
\DoxyCodeLine{02700             \textcolor{keywordflow}{for}( ;; )}
\DoxyCodeLine{02701             \{}
\DoxyCodeLine{02702                 \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( pxDelayedTaskList ) != pdFALSE )}
\DoxyCodeLine{02703                 \{}
\DoxyCodeLine{02704                     \textcolor{comment}{/* The delayed list is empty.  Set xNextTaskUnblockTime}}
\DoxyCodeLine{02705 \textcolor{comment}{                    to the maximum possible value so it is extremely}}
\DoxyCodeLine{02706 \textcolor{comment}{                    unlikely that the}}
\DoxyCodeLine{02707 \textcolor{comment}{                    if( xTickCount >= xNextTaskUnblockTime ) test will pass}}
\DoxyCodeLine{02708 \textcolor{comment}{                    next time through. */}}
\DoxyCodeLine{02709                     xNextTaskUnblockTime = portMAX\_DELAY; \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{02710                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{02711                 \}}
\DoxyCodeLine{02712                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{02713                 \{}
\DoxyCodeLine{02714                     \textcolor{comment}{/* The delayed list is not empty, get the value of the}}
\DoxyCodeLine{02715 \textcolor{comment}{                    item at the head of the delayed list.  This is the time}}
\DoxyCodeLine{02716 \textcolor{comment}{                    at which the task at the head of the delayed list must}}
\DoxyCodeLine{02717 \textcolor{comment}{                    be removed from the Blocked state. */}}
\DoxyCodeLine{02718                     pxTCB = listGET\_OWNER\_OF\_HEAD\_ENTRY( pxDelayedTaskList ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{02719                     xItemValue = listGET\_LIST\_ITEM\_VALUE( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{02720 }
\DoxyCodeLine{02721                     \textcolor{keywordflow}{if}( xConstTickCount < xItemValue )}
\DoxyCodeLine{02722                     \{}
\DoxyCodeLine{02723                         \textcolor{comment}{/* It is not time to unblock this item yet, but the}}
\DoxyCodeLine{02724 \textcolor{comment}{                        item value is the time at which the task at the head}}
\DoxyCodeLine{02725 \textcolor{comment}{                        of the blocked list must be removed from the Blocked}}
\DoxyCodeLine{02726 \textcolor{comment}{                        state -\/ so record the item value in}}
\DoxyCodeLine{02727 \textcolor{comment}{                        xNextTaskUnblockTime. */}}
\DoxyCodeLine{02728                         xNextTaskUnblockTime = xItemValue;}
\DoxyCodeLine{02729                         \textcolor{keywordflow}{break}; \textcolor{comment}{/*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */}}
\DoxyCodeLine{02730                     \}}
\DoxyCodeLine{02731                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02732                     \{}
\DoxyCodeLine{02733                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02734                     \}}
\DoxyCodeLine{02735 }
\DoxyCodeLine{02736                     \textcolor{comment}{/* It is time to remove the item from the Blocked state. */}}
\DoxyCodeLine{02737                     ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{02738 }
\DoxyCodeLine{02739                     \textcolor{comment}{/* Is the task waiting on an event also?  If so remove}}
\DoxyCodeLine{02740 \textcolor{comment}{                    it from the event list. */}}
\DoxyCodeLine{02741                     \textcolor{keywordflow}{if}( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) != NULL )}
\DoxyCodeLine{02742                     \{}
\DoxyCodeLine{02743                         ( void ) uxListRemove( \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{02744                     \}}
\DoxyCodeLine{02745                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02746                     \{}
\DoxyCodeLine{02747                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02748                     \}}
\DoxyCodeLine{02749 }
\DoxyCodeLine{02750                     \textcolor{comment}{/* Place the unblocked task into the appropriate ready}}
\DoxyCodeLine{02751 \textcolor{comment}{                    list. */}}
\DoxyCodeLine{02752                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{02753 }
\DoxyCodeLine{02754                     \textcolor{comment}{/* A task being unblocked cannot cause an immediate}}
\DoxyCodeLine{02755 \textcolor{comment}{                    context switch if preemption is turned off. */}}
\DoxyCodeLine{02756 \textcolor{preprocessor}{                    \#if (  configUSE\_PREEMPTION == 1 )}}
\DoxyCodeLine{02757                     \{}
\DoxyCodeLine{02758                         \textcolor{comment}{/* Preemption is on, but a context switch should}}
\DoxyCodeLine{02759 \textcolor{comment}{                        only be performed if the unblocked task has a}}
\DoxyCodeLine{02760 \textcolor{comment}{                        priority that is equal to or higher than the}}
\DoxyCodeLine{02761 \textcolor{comment}{                        currently executing task. */}}
\DoxyCodeLine{02762                         \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority >= pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{02763                         \{}
\DoxyCodeLine{02764                             xSwitchRequired = pdTRUE;}
\DoxyCodeLine{02765                         \}}
\DoxyCodeLine{02766                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02767                         \{}
\DoxyCodeLine{02768                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02769                         \}}
\DoxyCodeLine{02770                     \}}
\DoxyCodeLine{02771 \textcolor{preprocessor}{                    \#endif }\textcolor{comment}{/* configUSE\_PREEMPTION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02772                 \}}
\DoxyCodeLine{02773             \}}
\DoxyCodeLine{02774         \}}
\DoxyCodeLine{02775 }
\DoxyCodeLine{02776         \textcolor{comment}{/* Tasks of equal priority to the currently running task will share}}
\DoxyCodeLine{02777 \textcolor{comment}{        processing time (time slice) if preemption is on, and the application}}
\DoxyCodeLine{02778 \textcolor{comment}{        writer has not explicitly turned time slicing off. */}}
\DoxyCodeLine{02779 \textcolor{preprocessor}{        \#if ( ( configUSE\_PREEMPTION == 1 ) \&\& ( configUSE\_TIME\_SLICING == 1 ) )}}
\DoxyCodeLine{02780         \{}
\DoxyCodeLine{02781             \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( \&( pxReadyTasksLists[ pxCurrentTCB-\/>uxPriority ] ) ) > ( UBaseType\_t ) 1 )}
\DoxyCodeLine{02782             \{}
\DoxyCodeLine{02783                 xSwitchRequired = pdTRUE;}
\DoxyCodeLine{02784             \}}
\DoxyCodeLine{02785             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02786             \{}
\DoxyCodeLine{02787                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02788             \}}
\DoxyCodeLine{02789         \}}
\DoxyCodeLine{02790 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* ( ( configUSE\_PREEMPTION == 1 ) \&\& ( configUSE\_TIME\_SLICING == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02791 }
\DoxyCodeLine{02792 \textcolor{preprocessor}{        \#if ( configUSE\_TICK\_HOOK == 1 )}}
\DoxyCodeLine{02793         \{}
\DoxyCodeLine{02794             \textcolor{comment}{/* Guard against the tick hook being called when the pended tick}}
\DoxyCodeLine{02795 \textcolor{comment}{            count is being unwound (when the scheduler is being unlocked). */}}
\DoxyCodeLine{02796             \textcolor{keywordflow}{if}( uxPendedTicks == ( UBaseType\_t ) 0U )}
\DoxyCodeLine{02797             \{}
\DoxyCodeLine{02798                 vApplicationTickHook();}
\DoxyCodeLine{02799             \}}
\DoxyCodeLine{02800             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02801             \{}
\DoxyCodeLine{02802                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02803             \}}
\DoxyCodeLine{02804         \}}
\DoxyCodeLine{02805 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_TICK\_HOOK */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02806     \}}
\DoxyCodeLine{02807     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02808     \{}
\DoxyCodeLine{02809         ++uxPendedTicks;}
\DoxyCodeLine{02810 }
\DoxyCodeLine{02811         \textcolor{comment}{/* The tick hook gets called at regular intervals, even if the}}
\DoxyCodeLine{02812 \textcolor{comment}{        scheduler is locked. */}}
\DoxyCodeLine{02813 \textcolor{preprocessor}{        \#if ( configUSE\_TICK\_HOOK == 1 )}}
\DoxyCodeLine{02814         \{}
\DoxyCodeLine{02815             vApplicationTickHook();}
\DoxyCodeLine{02816         \}}
\DoxyCodeLine{02817 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{02818     \}}
\DoxyCodeLine{02819 }
\DoxyCodeLine{02820 \textcolor{preprocessor}{    \#if ( configUSE\_PREEMPTION == 1 )}}
\DoxyCodeLine{02821     \{}
\DoxyCodeLine{02822         \textcolor{keywordflow}{if}( xYieldPending != pdFALSE )}
\DoxyCodeLine{02823         \{}
\DoxyCodeLine{02824             xSwitchRequired = pdTRUE;}
\DoxyCodeLine{02825         \}}
\DoxyCodeLine{02826         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02827         \{}
\DoxyCodeLine{02828             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02829         \}}
\DoxyCodeLine{02830     \}}
\DoxyCodeLine{02831 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* configUSE\_PREEMPTION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02832 }
\DoxyCodeLine{02833     \textcolor{keywordflow}{return} xSwitchRequired;}
\DoxyCodeLine{02834 \}}
\DoxyCodeLine{02835 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02836 }
\DoxyCodeLine{02837 \textcolor{preprocessor}{\#if ( configUSE\_APPLICATION\_TASK\_TAG == 1 )}}
\DoxyCodeLine{02838 }
\DoxyCodeLine{02839     \textcolor{keywordtype}{void} vTaskSetApplicationTaskTag( TaskHandle\_t xTask, TaskHookFunction\_t pxHookFunction )}
\DoxyCodeLine{02840     \{}
\DoxyCodeLine{02841     TCB\_t *xTCB;}
\DoxyCodeLine{02842 }
\DoxyCodeLine{02843         \textcolor{comment}{/* If xTask is NULL then it is the task hook of the calling task that is}}
\DoxyCodeLine{02844 \textcolor{comment}{        getting set. */}}
\DoxyCodeLine{02845         \textcolor{keywordflow}{if}( xTask == NULL )}
\DoxyCodeLine{02846         \{}
\DoxyCodeLine{02847             xTCB = ( TCB\_t * ) pxCurrentTCB;}
\DoxyCodeLine{02848         \}}
\DoxyCodeLine{02849         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02850         \{}
\DoxyCodeLine{02851             xTCB = xTask;}
\DoxyCodeLine{02852         \}}
\DoxyCodeLine{02853 }
\DoxyCodeLine{02854         \textcolor{comment}{/* Save the hook function in the TCB.  A critical section is required as}}
\DoxyCodeLine{02855 \textcolor{comment}{        the value can be accessed from an interrupt. */}}
\DoxyCodeLine{02856         taskENTER\_CRITICAL();}
\DoxyCodeLine{02857         \{}
\DoxyCodeLine{02858             xTCB-\/>pxTaskTag = pxHookFunction;}
\DoxyCodeLine{02859         \}}
\DoxyCodeLine{02860         taskEXIT\_CRITICAL();}
\DoxyCodeLine{02861     \}}
\DoxyCodeLine{02862 }
\DoxyCodeLine{02863 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_APPLICATION\_TASK\_TAG */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02864 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02865 }
\DoxyCodeLine{02866 \textcolor{preprocessor}{\#if ( configUSE\_APPLICATION\_TASK\_TAG == 1 )}}
\DoxyCodeLine{02867 }
\DoxyCodeLine{02868     TaskHookFunction\_t xTaskGetApplicationTaskTag( TaskHandle\_t xTask )}
\DoxyCodeLine{02869     \{}
\DoxyCodeLine{02870     TCB\_t *pxTCB;}
\DoxyCodeLine{02871     TaskHookFunction\_t xReturn;}
\DoxyCodeLine{02872 }
\DoxyCodeLine{02873         \textcolor{comment}{/* If xTask is NULL then set the calling task's hook. */}}
\DoxyCodeLine{02874         pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{02875 }
\DoxyCodeLine{02876         \textcolor{comment}{/* Save the hook function in the TCB.  A critical section is required as}}
\DoxyCodeLine{02877 \textcolor{comment}{        the value can be accessed from an interrupt. */}}
\DoxyCodeLine{02878         taskENTER\_CRITICAL();}
\DoxyCodeLine{02879         \{}
\DoxyCodeLine{02880             xReturn = pxTCB-\/>pxTaskTag;}
\DoxyCodeLine{02881         \}}
\DoxyCodeLine{02882         taskEXIT\_CRITICAL();}
\DoxyCodeLine{02883 }
\DoxyCodeLine{02884         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02885     \}}
\DoxyCodeLine{02886 }
\DoxyCodeLine{02887 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_APPLICATION\_TASK\_TAG */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02888 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02889 }
\DoxyCodeLine{02890 \textcolor{preprocessor}{\#if ( configUSE\_APPLICATION\_TASK\_TAG == 1 )}}
\DoxyCodeLine{02891 }
\DoxyCodeLine{02892     TaskHookFunction\_t xTaskGetApplicationTaskTagFromISR( TaskHandle\_t xTask )}
\DoxyCodeLine{02893     \{}
\DoxyCodeLine{02894     TCB\_t *pxTCB;}
\DoxyCodeLine{02895     TaskHookFunction\_t xReturn;}
\DoxyCodeLine{02896     UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{02897 }
\DoxyCodeLine{02898         \textcolor{comment}{/* If xTask is NULL then set the calling task's hook. */}}
\DoxyCodeLine{02899         pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{02900 }
\DoxyCodeLine{02901         \textcolor{comment}{/* Save the hook function in the TCB.  A critical section is required as}}
\DoxyCodeLine{02902 \textcolor{comment}{        the value can be accessed from an interrupt. */}}
\DoxyCodeLine{02903         uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{02904         \{}
\DoxyCodeLine{02905             xReturn = pxTCB-\/>pxTaskTag;}
\DoxyCodeLine{02906         \}}
\DoxyCodeLine{02907         portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{02908 }
\DoxyCodeLine{02909         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02910     \}}
\DoxyCodeLine{02911 }
\DoxyCodeLine{02912 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_APPLICATION\_TASK\_TAG */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02913 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02914 }
\DoxyCodeLine{02915 \textcolor{preprocessor}{\#if ( configUSE\_APPLICATION\_TASK\_TAG == 1 )}}
\DoxyCodeLine{02916 }
\DoxyCodeLine{02917     BaseType\_t xTaskCallApplicationTaskHook( TaskHandle\_t xTask, \textcolor{keywordtype}{void} *pvParameter )}
\DoxyCodeLine{02918     \{}
\DoxyCodeLine{02919     TCB\_t *xTCB;}
\DoxyCodeLine{02920     BaseType\_t xReturn;}
\DoxyCodeLine{02921 }
\DoxyCodeLine{02922         \textcolor{comment}{/* If xTask is NULL then we are calling our own task hook. */}}
\DoxyCodeLine{02923         \textcolor{keywordflow}{if}( xTask == NULL )}
\DoxyCodeLine{02924         \{}
\DoxyCodeLine{02925             xTCB = pxCurrentTCB;}
\DoxyCodeLine{02926         \}}
\DoxyCodeLine{02927         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02928         \{}
\DoxyCodeLine{02929             xTCB = xTask;}
\DoxyCodeLine{02930         \}}
\DoxyCodeLine{02931 }
\DoxyCodeLine{02932         \textcolor{keywordflow}{if}( xTCB-\/>pxTaskTag != NULL )}
\DoxyCodeLine{02933         \{}
\DoxyCodeLine{02934             xReturn = xTCB-\/>pxTaskTag( pvParameter );}
\DoxyCodeLine{02935         \}}
\DoxyCodeLine{02936         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02937         \{}
\DoxyCodeLine{02938             xReturn = pdFAIL;}
\DoxyCodeLine{02939         \}}
\DoxyCodeLine{02940 }
\DoxyCodeLine{02941         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{02942     \}}
\DoxyCodeLine{02943 }
\DoxyCodeLine{02944 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_APPLICATION\_TASK\_TAG */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02945 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{02946 }
\DoxyCodeLine{02947 \textcolor{keywordtype}{void} vTaskSwitchContext( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{02948 \{}
\DoxyCodeLine{02949     \textcolor{keywordflow}{if}( uxSchedulerSuspended != ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{02950     \{}
\DoxyCodeLine{02951         \textcolor{comment}{/* The scheduler is currently suspended -\/ do not allow a context}}
\DoxyCodeLine{02952 \textcolor{comment}{        switch. */}}
\DoxyCodeLine{02953         xYieldPending = pdTRUE;}
\DoxyCodeLine{02954     \}}
\DoxyCodeLine{02955     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02956     \{}
\DoxyCodeLine{02957         xYieldPending = pdFALSE;}
\DoxyCodeLine{02958         traceTASK\_SWITCHED\_OUT();}
\DoxyCodeLine{02959 }
\DoxyCodeLine{02960 \textcolor{preprocessor}{        \#if ( configGENERATE\_RUN\_TIME\_STATS == 1 )}}
\DoxyCodeLine{02961         \{}
\DoxyCodeLine{02962 \textcolor{preprocessor}{            \#ifdef portALT\_GET\_RUN\_TIME\_COUNTER\_VALUE}}
\DoxyCodeLine{02963                 portALT\_GET\_RUN\_TIME\_COUNTER\_VALUE( ulTotalRunTime );}
\DoxyCodeLine{02964 \textcolor{preprocessor}{            \#else}}
\DoxyCodeLine{02965                 ulTotalRunTime = portGET\_RUN\_TIME\_COUNTER\_VALUE();}
\DoxyCodeLine{02966 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{02967 }
\DoxyCodeLine{02968             \textcolor{comment}{/* Add the amount of time the task has been running to the}}
\DoxyCodeLine{02969 \textcolor{comment}{            accumulated time so far.  The time the task started running was}}
\DoxyCodeLine{02970 \textcolor{comment}{            stored in ulTaskSwitchedInTime.  Note that there is no overflow}}
\DoxyCodeLine{02971 \textcolor{comment}{            protection here so count values are only valid until the timer}}
\DoxyCodeLine{02972 \textcolor{comment}{            overflows.  The guard against negative values is to protect}}
\DoxyCodeLine{02973 \textcolor{comment}{            against suspect run time stat counter implementations -\/ which}}
\DoxyCodeLine{02974 \textcolor{comment}{            are provided by the application, not the kernel. */}}
\DoxyCodeLine{02975             \textcolor{keywordflow}{if}( ulTotalRunTime > ulTaskSwitchedInTime )}
\DoxyCodeLine{02976             \{}
\DoxyCodeLine{02977                 pxCurrentTCB-\/>ulRunTimeCounter += ( ulTotalRunTime -\/ ulTaskSwitchedInTime );}
\DoxyCodeLine{02978             \}}
\DoxyCodeLine{02979             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02980             \{}
\DoxyCodeLine{02981                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{02982             \}}
\DoxyCodeLine{02983             ulTaskSwitchedInTime = ulTotalRunTime;}
\DoxyCodeLine{02984         \}}
\DoxyCodeLine{02985 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configGENERATE\_RUN\_TIME\_STATS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02986 }
\DoxyCodeLine{02987         \textcolor{comment}{/* Check for stack overflow, if configured. */}}
\DoxyCodeLine{02988         taskCHECK\_FOR\_STACK\_OVERFLOW();}
\DoxyCodeLine{02989 }
\DoxyCodeLine{02990         \textcolor{comment}{/* Before the currently running task is switched out, save its errno. */}}
\DoxyCodeLine{02991 \textcolor{preprocessor}{        \#if( configUSE\_POSIX\_ERRNO == 1 )}}
\DoxyCodeLine{02992         \{}
\DoxyCodeLine{02993             pxCurrentTCB-\/>iTaskErrno = FreeRTOS\_errno;}
\DoxyCodeLine{02994         \}}
\DoxyCodeLine{02995 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{02996 }
\DoxyCodeLine{02997         \textcolor{comment}{/* Select a new task to run using either the generic C or port}}
\DoxyCodeLine{02998 \textcolor{comment}{        optimised asm code. */}}
\DoxyCodeLine{02999         taskSELECT\_HIGHEST\_PRIORITY\_TASK(); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{03000         traceTASK\_SWITCHED\_IN();}
\DoxyCodeLine{03001 }
\DoxyCodeLine{03002         \textcolor{comment}{/* After the new task is switched in, update the global errno. */}}
\DoxyCodeLine{03003 \textcolor{preprocessor}{        \#if( configUSE\_POSIX\_ERRNO == 1 )}}
\DoxyCodeLine{03004         \{}
\DoxyCodeLine{03005             FreeRTOS\_errno = pxCurrentTCB-\/>iTaskErrno;}
\DoxyCodeLine{03006         \}}
\DoxyCodeLine{03007 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03008 }
\DoxyCodeLine{03009 \textcolor{preprocessor}{        \#if ( configUSE\_NEWLIB\_REENTRANT == 1 )}}
\DoxyCodeLine{03010         \{}
\DoxyCodeLine{03011             \textcolor{comment}{/* Switch Newlib's \_impure\_ptr variable to point to the \_reent}}
\DoxyCodeLine{03012 \textcolor{comment}{            structure specific to this task. */}}
\DoxyCodeLine{03013             \_impure\_ptr = \&( pxCurrentTCB-\/>xNewLib\_reent );}
\DoxyCodeLine{03014         \}}
\DoxyCodeLine{03015 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_NEWLIB\_REENTRANT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03016     \}}
\DoxyCodeLine{03017 \}}
\DoxyCodeLine{03018 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03019 }
\DoxyCodeLine{03020 \textcolor{keywordtype}{void} vTaskPlaceOnEventList( List\_t * \textcolor{keyword}{const} pxEventList, \textcolor{keyword}{const} TickType\_t xTicksToWait )}
\DoxyCodeLine{03021 \{}
\DoxyCodeLine{03022     configASSERT( pxEventList );}
\DoxyCodeLine{03023 }
\DoxyCodeLine{03024     \textcolor{comment}{/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE}}
\DoxyCodeLine{03025 \textcolor{comment}{    SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */}}
\DoxyCodeLine{03026 }
\DoxyCodeLine{03027     \textcolor{comment}{/* Place the event list item of the TCB in the appropriate event list.}}
\DoxyCodeLine{03028 \textcolor{comment}{    This is placed in the list in priority order so the highest priority task}}
\DoxyCodeLine{03029 \textcolor{comment}{    is the first to be woken by the event.  The queue that contains the event}}
\DoxyCodeLine{03030 \textcolor{comment}{    list is locked, preventing simultaneous access from interrupts. */}}
\DoxyCodeLine{03031     vListInsert( pxEventList, \&( pxCurrentTCB-\/>xEventListItem ) );}
\DoxyCodeLine{03032 }
\DoxyCodeLine{03033     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );}
\DoxyCodeLine{03034 \}}
\DoxyCodeLine{03035 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03036 }
\DoxyCodeLine{03037 \textcolor{keywordtype}{void} vTaskPlaceOnUnorderedEventList( List\_t * pxEventList, \textcolor{keyword}{const} TickType\_t xItemValue, \textcolor{keyword}{const} TickType\_t xTicksToWait )}
\DoxyCodeLine{03038 \{}
\DoxyCodeLine{03039     configASSERT( pxEventList );}
\DoxyCodeLine{03040 }
\DoxyCodeLine{03041     \textcolor{comment}{/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by}}
\DoxyCodeLine{03042 \textcolor{comment}{    the event groups implementation. */}}
\DoxyCodeLine{03043     configASSERT( uxSchedulerSuspended != 0 );}
\DoxyCodeLine{03044 }
\DoxyCodeLine{03045     \textcolor{comment}{/* Store the item value in the event list item.  It is safe to access the}}
\DoxyCodeLine{03046 \textcolor{comment}{    event list item here as interrupts won't access the event list item of a}}
\DoxyCodeLine{03047 \textcolor{comment}{    task that is not in the Blocked state. */}}
\DoxyCodeLine{03048     listSET\_LIST\_ITEM\_VALUE( \&( pxCurrentTCB-\/>xEventListItem ), xItemValue | taskEVENT\_LIST\_ITEM\_VALUE\_IN\_USE );}
\DoxyCodeLine{03049 }
\DoxyCodeLine{03050     \textcolor{comment}{/* Place the event list item of the TCB at the end of the appropriate event}}
\DoxyCodeLine{03051 \textcolor{comment}{    list.  It is safe to access the event list here because it is part of an}}
\DoxyCodeLine{03052 \textcolor{comment}{    event group implementation -\/ and interrupts don't access event groups}}
\DoxyCodeLine{03053 \textcolor{comment}{    directly (instead they access them indirectly by pending function calls to}}
\DoxyCodeLine{03054 \textcolor{comment}{    the task level). */}}
\DoxyCodeLine{03055     vListInsertEnd( pxEventList, \&( pxCurrentTCB-\/>xEventListItem ) );}
\DoxyCodeLine{03056 }
\DoxyCodeLine{03057     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );}
\DoxyCodeLine{03058 \}}
\DoxyCodeLine{03059 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03060 }
\DoxyCodeLine{03061 \textcolor{preprocessor}{\#if( configUSE\_TIMERS == 1 )}}
\DoxyCodeLine{03062 }
\DoxyCodeLine{03063     \textcolor{keywordtype}{void} vTaskPlaceOnEventListRestricted( List\_t * \textcolor{keyword}{const} pxEventList, TickType\_t xTicksToWait, \textcolor{keyword}{const} BaseType\_t xWaitIndefinitely )}
\DoxyCodeLine{03064     \{}
\DoxyCodeLine{03065         configASSERT( pxEventList );}
\DoxyCodeLine{03066 }
\DoxyCodeLine{03067         \textcolor{comment}{/* This function should not be called by application code hence the}}
\DoxyCodeLine{03068 \textcolor{comment}{        'Restricted' in its name.  It is not part of the public API.  It is}}
\DoxyCodeLine{03069 \textcolor{comment}{        designed for use by kernel code, and has special calling requirements -\/}}
\DoxyCodeLine{03070 \textcolor{comment}{        it should be called with the scheduler suspended. */}}
\DoxyCodeLine{03071 }
\DoxyCodeLine{03072 }
\DoxyCodeLine{03073         \textcolor{comment}{/* Place the event list item of the TCB in the appropriate event list.}}
\DoxyCodeLine{03074 \textcolor{comment}{        In this case it is assume that this is the only task that is going to}}
\DoxyCodeLine{03075 \textcolor{comment}{        be waiting on this event list, so the faster vListInsertEnd() function}}
\DoxyCodeLine{03076 \textcolor{comment}{        can be used in place of vListInsert. */}}
\DoxyCodeLine{03077         vListInsertEnd( pxEventList, \&( pxCurrentTCB-\/>xEventListItem ) );}
\DoxyCodeLine{03078 }
\DoxyCodeLine{03079         \textcolor{comment}{/* If the task should block indefinitely then set the block time to a}}
\DoxyCodeLine{03080 \textcolor{comment}{        value that will be recognised as an indefinite delay inside the}}
\DoxyCodeLine{03081 \textcolor{comment}{        prvAddCurrentTaskToDelayedList() function. */}}
\DoxyCodeLine{03082         \textcolor{keywordflow}{if}( xWaitIndefinitely != pdFALSE )}
\DoxyCodeLine{03083         \{}
\DoxyCodeLine{03084             xTicksToWait = portMAX\_DELAY;}
\DoxyCodeLine{03085         \}}
\DoxyCodeLine{03086 }
\DoxyCodeLine{03087         traceTASK\_DELAY\_UNTIL( ( xTickCount + xTicksToWait ) );}
\DoxyCodeLine{03088         prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );}
\DoxyCodeLine{03089     \}}
\DoxyCodeLine{03090 }
\DoxyCodeLine{03091 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TIMERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03092 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03093 }
\DoxyCodeLine{03094 BaseType\_t xTaskRemoveFromEventList( \textcolor{keyword}{const} List\_t * \textcolor{keyword}{const} pxEventList )}
\DoxyCodeLine{03095 \{}
\DoxyCodeLine{03096 TCB\_t *pxUnblockedTCB;}
\DoxyCodeLine{03097 BaseType\_t xReturn;}
\DoxyCodeLine{03098 }
\DoxyCodeLine{03099     \textcolor{comment}{/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be}}
\DoxyCodeLine{03100 \textcolor{comment}{    called from a critical section within an ISR. */}}
\DoxyCodeLine{03101 }
\DoxyCodeLine{03102     \textcolor{comment}{/* The event list is sorted in priority order, so the first in the list can}}
\DoxyCodeLine{03103 \textcolor{comment}{    be removed as it is known to be the highest priority.  Remove the TCB from}}
\DoxyCodeLine{03104 \textcolor{comment}{    the delayed list, and add it to the ready list.}}
\DoxyCodeLine{03105 \textcolor{comment}{}}
\DoxyCodeLine{03106 \textcolor{comment}{    If an event is for a queue that is locked then this function will never}}
\DoxyCodeLine{03107 \textcolor{comment}{    get called -\/ the lock count on the queue will get modified instead.  This}}
\DoxyCodeLine{03108 \textcolor{comment}{    means exclusive access to the event list is guaranteed here.}}
\DoxyCodeLine{03109 \textcolor{comment}{}}
\DoxyCodeLine{03110 \textcolor{comment}{    This function assumes that a check has already been made to ensure that}}
\DoxyCodeLine{03111 \textcolor{comment}{    pxEventList is not empty. */}}
\DoxyCodeLine{03112     pxUnblockedTCB = listGET\_OWNER\_OF\_HEAD\_ENTRY( pxEventList ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{03113     configASSERT( pxUnblockedTCB );}
\DoxyCodeLine{03114     ( void ) uxListRemove( \&( pxUnblockedTCB-\/>xEventListItem ) );}
\DoxyCodeLine{03115 }
\DoxyCodeLine{03116     \textcolor{keywordflow}{if}( uxSchedulerSuspended == ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{03117     \{}
\DoxyCodeLine{03118         ( void ) uxListRemove( \&( pxUnblockedTCB-\/>xStateListItem ) );}
\DoxyCodeLine{03119         prvAddTaskToReadyList( pxUnblockedTCB );}
\DoxyCodeLine{03120 }
\DoxyCodeLine{03121 \textcolor{preprocessor}{        \#if( configUSE\_TICKLESS\_IDLE != 0 )}}
\DoxyCodeLine{03122         \{}
\DoxyCodeLine{03123             \textcolor{comment}{/* If a task is blocked on a kernel object then xNextTaskUnblockTime}}
\DoxyCodeLine{03124 \textcolor{comment}{            might be set to the blocked task's time out time.  If the task is}}
\DoxyCodeLine{03125 \textcolor{comment}{            unblocked for a reason other than a timeout xNextTaskUnblockTime is}}
\DoxyCodeLine{03126 \textcolor{comment}{            normally left unchanged, because it is automatically reset to a new}}
\DoxyCodeLine{03127 \textcolor{comment}{            value when the tick count equals xNextTaskUnblockTime.  However if}}
\DoxyCodeLine{03128 \textcolor{comment}{            tickless idling is used it might be more important to enter sleep mode}}
\DoxyCodeLine{03129 \textcolor{comment}{            at the earliest possible time -\/ so reset xNextTaskUnblockTime here to}}
\DoxyCodeLine{03130 \textcolor{comment}{            ensure it is updated at the earliest possible time. */}}
\DoxyCodeLine{03131             prvResetNextTaskUnblockTime();}
\DoxyCodeLine{03132         \}}
\DoxyCodeLine{03133 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03134     \}}
\DoxyCodeLine{03135     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03136     \{}
\DoxyCodeLine{03137         \textcolor{comment}{/* The delayed and ready lists cannot be accessed, so hold this task}}
\DoxyCodeLine{03138 \textcolor{comment}{        pending until the scheduler is resumed. */}}
\DoxyCodeLine{03139         vListInsertEnd( \&( xPendingReadyList ), \&( pxUnblockedTCB-\/>xEventListItem ) );}
\DoxyCodeLine{03140     \}}
\DoxyCodeLine{03141 }
\DoxyCodeLine{03142     \textcolor{keywordflow}{if}( pxUnblockedTCB-\/>uxPriority > pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{03143     \{}
\DoxyCodeLine{03144         \textcolor{comment}{/* Return true if the task removed from the event list has a higher}}
\DoxyCodeLine{03145 \textcolor{comment}{        priority than the calling task.  This allows the calling task to know if}}
\DoxyCodeLine{03146 \textcolor{comment}{        it should force a context switch now. */}}
\DoxyCodeLine{03147         xReturn = pdTRUE;}
\DoxyCodeLine{03148 }
\DoxyCodeLine{03149         \textcolor{comment}{/* Mark that a yield is pending in case the user is not using the}}
\DoxyCodeLine{03150 \textcolor{comment}{        "{}xHigherPriorityTaskWoken"{} parameter to an ISR safe FreeRTOS function. */}}
\DoxyCodeLine{03151         xYieldPending = pdTRUE;}
\DoxyCodeLine{03152     \}}
\DoxyCodeLine{03153     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03154     \{}
\DoxyCodeLine{03155         xReturn = pdFALSE;}
\DoxyCodeLine{03156     \}}
\DoxyCodeLine{03157 }
\DoxyCodeLine{03158     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{03159 \}}
\DoxyCodeLine{03160 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03161 }
\DoxyCodeLine{03162 \textcolor{keywordtype}{void} vTaskRemoveFromUnorderedEventList( ListItem\_t * pxEventListItem, \textcolor{keyword}{const} TickType\_t xItemValue )}
\DoxyCodeLine{03163 \{}
\DoxyCodeLine{03164 TCB\_t *pxUnblockedTCB;}
\DoxyCodeLine{03165 }
\DoxyCodeLine{03166     \textcolor{comment}{/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by}}
\DoxyCodeLine{03167 \textcolor{comment}{    the event flags implementation. */}}
\DoxyCodeLine{03168     configASSERT( uxSchedulerSuspended != pdFALSE );}
\DoxyCodeLine{03169 }
\DoxyCodeLine{03170     \textcolor{comment}{/* Store the new item value in the event list. */}}
\DoxyCodeLine{03171     listSET\_LIST\_ITEM\_VALUE( pxEventListItem, xItemValue | taskEVENT\_LIST\_ITEM\_VALUE\_IN\_USE );}
\DoxyCodeLine{03172 }
\DoxyCodeLine{03173     \textcolor{comment}{/* Remove the event list form the event flag.  Interrupts do not access}}
\DoxyCodeLine{03174 \textcolor{comment}{    event flags. */}}
\DoxyCodeLine{03175     pxUnblockedTCB = listGET\_LIST\_ITEM\_OWNER( pxEventListItem ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{03176     configASSERT( pxUnblockedTCB );}
\DoxyCodeLine{03177     ( void ) uxListRemove( pxEventListItem );}
\DoxyCodeLine{03178 }
\DoxyCodeLine{03179     \textcolor{comment}{/* Remove the task from the delayed list and add it to the ready list.  The}}
\DoxyCodeLine{03180 \textcolor{comment}{    scheduler is suspended so interrupts will not be accessing the ready}}
\DoxyCodeLine{03181 \textcolor{comment}{    lists. */}}
\DoxyCodeLine{03182     ( void ) uxListRemove( \&( pxUnblockedTCB-\/>xStateListItem ) );}
\DoxyCodeLine{03183     prvAddTaskToReadyList( pxUnblockedTCB );}
\DoxyCodeLine{03184 }
\DoxyCodeLine{03185     \textcolor{keywordflow}{if}( pxUnblockedTCB-\/>uxPriority > pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{03186     \{}
\DoxyCodeLine{03187         \textcolor{comment}{/* The unblocked task has a priority above that of the calling task, so}}
\DoxyCodeLine{03188 \textcolor{comment}{        a context switch is required.  This function is called with the}}
\DoxyCodeLine{03189 \textcolor{comment}{        scheduler suspended so xYieldPending is set so the context switch}}
\DoxyCodeLine{03190 \textcolor{comment}{        occurs immediately that the scheduler is resumed (unsuspended). */}}
\DoxyCodeLine{03191         xYieldPending = pdTRUE;}
\DoxyCodeLine{03192     \}}
\DoxyCodeLine{03193 \}}
\DoxyCodeLine{03194 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03195 }
\DoxyCodeLine{03196 \textcolor{keywordtype}{void} vTaskSetTimeOutState( TimeOut\_t * \textcolor{keyword}{const} pxTimeOut )}
\DoxyCodeLine{03197 \{}
\DoxyCodeLine{03198     configASSERT( pxTimeOut );}
\DoxyCodeLine{03199     taskENTER\_CRITICAL();}
\DoxyCodeLine{03200     \{}
\DoxyCodeLine{03201         pxTimeOut-\/>xOverflowCount = xNumOfOverflows;}
\DoxyCodeLine{03202         pxTimeOut-\/>xTimeOnEntering = xTickCount;}
\DoxyCodeLine{03203     \}}
\DoxyCodeLine{03204     taskEXIT\_CRITICAL();}
\DoxyCodeLine{03205 \}}
\DoxyCodeLine{03206 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03207 }
\DoxyCodeLine{03208 \textcolor{keywordtype}{void} vTaskInternalSetTimeOutState( TimeOut\_t * \textcolor{keyword}{const} pxTimeOut )}
\DoxyCodeLine{03209 \{}
\DoxyCodeLine{03210     \textcolor{comment}{/* For internal use only as it does not use a critical section. */}}
\DoxyCodeLine{03211     pxTimeOut-\/>xOverflowCount = xNumOfOverflows;}
\DoxyCodeLine{03212     pxTimeOut-\/>xTimeOnEntering = xTickCount;}
\DoxyCodeLine{03213 \}}
\DoxyCodeLine{03214 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03215 }
\DoxyCodeLine{03216 BaseType\_t xTaskCheckForTimeOut( TimeOut\_t * \textcolor{keyword}{const} pxTimeOut, TickType\_t * \textcolor{keyword}{const} pxTicksToWait )}
\DoxyCodeLine{03217 \{}
\DoxyCodeLine{03218 BaseType\_t xReturn;}
\DoxyCodeLine{03219 }
\DoxyCodeLine{03220     configASSERT( pxTimeOut );}
\DoxyCodeLine{03221     configASSERT( pxTicksToWait );}
\DoxyCodeLine{03222 }
\DoxyCodeLine{03223     taskENTER\_CRITICAL();}
\DoxyCodeLine{03224     \{}
\DoxyCodeLine{03225         \textcolor{comment}{/* Minor optimisation.  The tick count cannot change in this block. */}}
\DoxyCodeLine{03226         \textcolor{keyword}{const} TickType\_t xConstTickCount = xTickCount;}
\DoxyCodeLine{03227         \textcolor{keyword}{const} TickType\_t xElapsedTime = xConstTickCount -\/ pxTimeOut-\/>xTimeOnEntering;}
\DoxyCodeLine{03228 }
\DoxyCodeLine{03229 \textcolor{preprocessor}{        \#if( INCLUDE\_xTaskAbortDelay == 1 )}}
\DoxyCodeLine{03230             \textcolor{keywordflow}{if}( pxCurrentTCB-\/>ucDelayAborted != ( uint8\_t ) pdFALSE )}
\DoxyCodeLine{03231             \{}
\DoxyCodeLine{03232                 \textcolor{comment}{/* The delay was aborted, which is not the same as a time out,}}
\DoxyCodeLine{03233 \textcolor{comment}{                but has the same result. */}}
\DoxyCodeLine{03234                 pxCurrentTCB-\/>ucDelayAborted = pdFALSE;}
\DoxyCodeLine{03235                 xReturn = pdTRUE;}
\DoxyCodeLine{03236             \}}
\DoxyCodeLine{03237             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03238 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03239 }
\DoxyCodeLine{03240 \textcolor{preprocessor}{        \#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{03241             \textcolor{keywordflow}{if}( *pxTicksToWait == portMAX\_DELAY )}
\DoxyCodeLine{03242             \{}
\DoxyCodeLine{03243                 \textcolor{comment}{/* If INCLUDE\_vTaskSuspend is set to 1 and the block time}}
\DoxyCodeLine{03244 \textcolor{comment}{                specified is the maximum block time then the task should block}}
\DoxyCodeLine{03245 \textcolor{comment}{                indefinitely, and therefore never time out. */}}
\DoxyCodeLine{03246                 xReturn = pdFALSE;}
\DoxyCodeLine{03247             \}}
\DoxyCodeLine{03248             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03249 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03250 }
\DoxyCodeLine{03251         \textcolor{keywordflow}{if}( ( xNumOfOverflows != pxTimeOut-\/>xOverflowCount ) \&\& ( xConstTickCount >= pxTimeOut-\/>xTimeOnEntering ) ) \textcolor{comment}{/*lint !e525 Indentation preferred as is to make code within pre-\/processor directives clearer. */}}
\DoxyCodeLine{03252         \{}
\DoxyCodeLine{03253             \textcolor{comment}{/* The tick count is greater than the time at which}}
\DoxyCodeLine{03254 \textcolor{comment}{            vTaskSetTimeout() was called, but has also overflowed since}}
\DoxyCodeLine{03255 \textcolor{comment}{            vTaskSetTimeOut() was called.  It must have wrapped all the way}}
\DoxyCodeLine{03256 \textcolor{comment}{            around and gone past again. This passed since vTaskSetTimeout()}}
\DoxyCodeLine{03257 \textcolor{comment}{            was called. */}}
\DoxyCodeLine{03258             xReturn = pdTRUE;}
\DoxyCodeLine{03259         \}}
\DoxyCodeLine{03260         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xElapsedTime < *pxTicksToWait ) \textcolor{comment}{/*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */}}
\DoxyCodeLine{03261         \{}
\DoxyCodeLine{03262             \textcolor{comment}{/* Not a genuine timeout. Adjust parameters for time remaining. */}}
\DoxyCodeLine{03263             *pxTicksToWait -\/= xElapsedTime;}
\DoxyCodeLine{03264             vTaskInternalSetTimeOutState( pxTimeOut );}
\DoxyCodeLine{03265             xReturn = pdFALSE;}
\DoxyCodeLine{03266         \}}
\DoxyCodeLine{03267         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03268         \{}
\DoxyCodeLine{03269             *pxTicksToWait = 0;}
\DoxyCodeLine{03270             xReturn = pdTRUE;}
\DoxyCodeLine{03271         \}}
\DoxyCodeLine{03272     \}}
\DoxyCodeLine{03273     taskEXIT\_CRITICAL();}
\DoxyCodeLine{03274 }
\DoxyCodeLine{03275     \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{03276 \}}
\DoxyCodeLine{03277 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03278 }
\DoxyCodeLine{03279 \textcolor{keywordtype}{void} vTaskMissedYield( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{03280 \{}
\DoxyCodeLine{03281     xYieldPending = pdTRUE;}
\DoxyCodeLine{03282 \}}
\DoxyCodeLine{03283 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03284 }
\DoxyCodeLine{03285 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{03286 }
\DoxyCodeLine{03287     UBaseType\_t uxTaskGetTaskNumber( TaskHandle\_t xTask )}
\DoxyCodeLine{03288     \{}
\DoxyCodeLine{03289     UBaseType\_t uxReturn;}
\DoxyCodeLine{03290     TCB\_t \textcolor{keyword}{const} *pxTCB;}
\DoxyCodeLine{03291 }
\DoxyCodeLine{03292         \textcolor{keywordflow}{if}( xTask != NULL )}
\DoxyCodeLine{03293         \{}
\DoxyCodeLine{03294             pxTCB = xTask;}
\DoxyCodeLine{03295             uxReturn = pxTCB-\/>uxTaskNumber;}
\DoxyCodeLine{03296         \}}
\DoxyCodeLine{03297         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03298         \{}
\DoxyCodeLine{03299             uxReturn = 0U;}
\DoxyCodeLine{03300         \}}
\DoxyCodeLine{03301 }
\DoxyCodeLine{03302         \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{03303     \}}
\DoxyCodeLine{03304 }
\DoxyCodeLine{03305 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03306 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03307 }
\DoxyCodeLine{03308 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{03309 }
\DoxyCodeLine{03310     \textcolor{keywordtype}{void} vTaskSetTaskNumber( TaskHandle\_t xTask, \textcolor{keyword}{const} UBaseType\_t uxHandle )}
\DoxyCodeLine{03311     \{}
\DoxyCodeLine{03312     TCB\_t * pxTCB;}
\DoxyCodeLine{03313 }
\DoxyCodeLine{03314         \textcolor{keywordflow}{if}( xTask != NULL )}
\DoxyCodeLine{03315         \{}
\DoxyCodeLine{03316             pxTCB = xTask;}
\DoxyCodeLine{03317             pxTCB-\/>uxTaskNumber = uxHandle;}
\DoxyCodeLine{03318         \}}
\DoxyCodeLine{03319     \}}
\DoxyCodeLine{03320 }
\DoxyCodeLine{03321 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03322 }
\DoxyCodeLine{03323 \textcolor{comment}{/*}}
\DoxyCodeLine{03324 \textcolor{comment}{ * -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{03325 \textcolor{comment}{ * The Idle task.}}
\DoxyCodeLine{03326 \textcolor{comment}{ * -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{03327 \textcolor{comment}{ *}}
\DoxyCodeLine{03328 \textcolor{comment}{ * The portTASK\_FUNCTION() macro is used to allow port/compiler specific}}
\DoxyCodeLine{03329 \textcolor{comment}{ * language extensions.  The equivalent prototype for this function is:}}
\DoxyCodeLine{03330 \textcolor{comment}{ *}}
\DoxyCodeLine{03331 \textcolor{comment}{ * void prvIdleTask( void *pvParameters );}}
\DoxyCodeLine{03332 \textcolor{comment}{ *}}
\DoxyCodeLine{03333 \textcolor{comment}{ */}}
\DoxyCodeLine{03334 \textcolor{keyword}{static} portTASK\_FUNCTION( prvIdleTask, pvParameters )}
\DoxyCodeLine{03335 \{}
\DoxyCodeLine{03336     \textcolor{comment}{/* Stop warnings. */}}
\DoxyCodeLine{03337     ( void ) pvParameters;}
\DoxyCodeLine{03338 }
\DoxyCodeLine{03342     \textcolor{comment}{/* In case a task that has a secure context deletes itself, in which case}}
\DoxyCodeLine{03343 \textcolor{comment}{    the idle task is responsible for deleting the task's secure context, if}}
\DoxyCodeLine{03344 \textcolor{comment}{    any. */}}
\DoxyCodeLine{03345     portALLOCATE\_SECURE\_CONTEXT( configMINIMAL\_SECURE\_STACK\_SIZE );}
\DoxyCodeLine{03346 }
\DoxyCodeLine{03347     \textcolor{keywordflow}{for}( ;; )}
\DoxyCodeLine{03348     \{}
\DoxyCodeLine{03349         \textcolor{comment}{/* See if any tasks have deleted themselves -\/ if so then the idle task}}
\DoxyCodeLine{03350 \textcolor{comment}{        is responsible for freeing the deleted task's TCB and stack. */}}
\DoxyCodeLine{03351         prvCheckTasksWaitingTermination();}
\DoxyCodeLine{03352 }
\DoxyCodeLine{03353 \textcolor{preprocessor}{        \#if ( configUSE\_PREEMPTION == 0 )}}
\DoxyCodeLine{03354         \{}
\DoxyCodeLine{03355             \textcolor{comment}{/* If we are not using preemption we keep forcing a task switch to}}
\DoxyCodeLine{03356 \textcolor{comment}{            see if any other task has become available.  If we are using}}
\DoxyCodeLine{03357 \textcolor{comment}{            preemption we don't need to do this as any task becoming available}}
\DoxyCodeLine{03358 \textcolor{comment}{            will automatically get the processor anyway. */}}
\DoxyCodeLine{03359             taskYIELD();}
\DoxyCodeLine{03360         \}}
\DoxyCodeLine{03361 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_PREEMPTION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03362 }
\DoxyCodeLine{03363 \textcolor{preprocessor}{        \#if ( ( configUSE\_PREEMPTION == 1 ) \&\& ( configIDLE\_SHOULD\_YIELD == 1 ) )}}
\DoxyCodeLine{03364         \{}
\DoxyCodeLine{03365             \textcolor{comment}{/* When using preemption tasks of equal priority will be}}
\DoxyCodeLine{03366 \textcolor{comment}{            timesliced.  If a task that is sharing the idle priority is ready}}
\DoxyCodeLine{03367 \textcolor{comment}{            to run then the idle task should yield before the end of the}}
\DoxyCodeLine{03368 \textcolor{comment}{            timeslice.}}
\DoxyCodeLine{03369 \textcolor{comment}{}}
\DoxyCodeLine{03370 \textcolor{comment}{            A critical region is not required here as we are just reading from}}
\DoxyCodeLine{03371 \textcolor{comment}{            the list, and an occasional incorrect value will not matter.  If}}
\DoxyCodeLine{03372 \textcolor{comment}{            the ready list at the idle priority contains more than one task}}
\DoxyCodeLine{03373 \textcolor{comment}{            then a task other than the idle task is ready to execute. */}}
\DoxyCodeLine{03374             \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( \&( pxReadyTasksLists[ tskIDLE\_PRIORITY ] ) ) > ( UBaseType\_t ) 1 )}
\DoxyCodeLine{03375             \{}
\DoxyCodeLine{03376                 taskYIELD();}
\DoxyCodeLine{03377             \}}
\DoxyCodeLine{03378             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03379             \{}
\DoxyCodeLine{03380                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03381             \}}
\DoxyCodeLine{03382         \}}
\DoxyCodeLine{03383 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* ( ( configUSE\_PREEMPTION == 1 ) \&\& ( configIDLE\_SHOULD\_YIELD == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03384 }
\DoxyCodeLine{03385 \textcolor{preprocessor}{        \#if ( configUSE\_IDLE\_HOOK == 1 )}}
\DoxyCodeLine{03386         \{}
\DoxyCodeLine{03387             \textcolor{keyword}{extern} \textcolor{keywordtype}{void} vApplicationIdleHook( \textcolor{keywordtype}{void} );}
\DoxyCodeLine{03388 }
\DoxyCodeLine{03389             \textcolor{comment}{/* Call the user defined function from within the idle task.  This}}
\DoxyCodeLine{03390 \textcolor{comment}{            allows the application designer to add background functionality}}
\DoxyCodeLine{03391 \textcolor{comment}{            without the overhead of a separate task.}}
\DoxyCodeLine{03392 \textcolor{comment}{            NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,}}
\DoxyCodeLine{03393 \textcolor{comment}{            CALL A FUNCTION THAT MIGHT BLOCK. */}}
\DoxyCodeLine{03394             vApplicationIdleHook();}
\DoxyCodeLine{03395         \}}
\DoxyCodeLine{03396 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_IDLE\_HOOK */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03397 }
\DoxyCodeLine{03398         \textcolor{comment}{/* This conditional compilation should use inequality to 0, not equality}}
\DoxyCodeLine{03399 \textcolor{comment}{        to 1.  This is to ensure portSUPPRESS\_TICKS\_AND\_SLEEP() is called when}}
\DoxyCodeLine{03400 \textcolor{comment}{        user defined low power mode implementations require}}
\DoxyCodeLine{03401 \textcolor{comment}{        configUSE\_TICKLESS\_IDLE to be set to a value other than 1. */}}
\DoxyCodeLine{03402 \textcolor{preprocessor}{        \#if ( configUSE\_TICKLESS\_IDLE != 0 )}}
\DoxyCodeLine{03403         \{}
\DoxyCodeLine{03404         TickType\_t xExpectedIdleTime;}
\DoxyCodeLine{03405 }
\DoxyCodeLine{03406             \textcolor{comment}{/* It is not desirable to suspend then resume the scheduler on}}
\DoxyCodeLine{03407 \textcolor{comment}{            each iteration of the idle task.  Therefore, a preliminary}}
\DoxyCodeLine{03408 \textcolor{comment}{            test of the expected idle time is performed without the}}
\DoxyCodeLine{03409 \textcolor{comment}{            scheduler suspended.  The result here is not necessarily}}
\DoxyCodeLine{03410 \textcolor{comment}{            valid. */}}
\DoxyCodeLine{03411             xExpectedIdleTime = prvGetExpectedIdleTime();}
\DoxyCodeLine{03412 }
\DoxyCodeLine{03413             \textcolor{keywordflow}{if}( xExpectedIdleTime >= configEXPECTED\_IDLE\_TIME\_BEFORE\_SLEEP )}
\DoxyCodeLine{03414             \{}
\DoxyCodeLine{03415                 vTaskSuspendAll();}
\DoxyCodeLine{03416                 \{}
\DoxyCodeLine{03417                     \textcolor{comment}{/* Now the scheduler is suspended, the expected idle}}
\DoxyCodeLine{03418 \textcolor{comment}{                    time can be sampled again, and this time its value can}}
\DoxyCodeLine{03419 \textcolor{comment}{                    be used. */}}
\DoxyCodeLine{03420                     configASSERT( xNextTaskUnblockTime >= xTickCount );}
\DoxyCodeLine{03421                     xExpectedIdleTime = prvGetExpectedIdleTime();}
\DoxyCodeLine{03422 }
\DoxyCodeLine{03423                     \textcolor{comment}{/* Define the following macro to set xExpectedIdleTime to 0}}
\DoxyCodeLine{03424 \textcolor{comment}{                    if the application does not want}}
\DoxyCodeLine{03425 \textcolor{comment}{                    portSUPPRESS\_TICKS\_AND\_SLEEP() to be called. */}}
\DoxyCodeLine{03426                     configPRE\_SUPPRESS\_TICKS\_AND\_SLEEP\_PROCESSING( xExpectedIdleTime );}
\DoxyCodeLine{03427 }
\DoxyCodeLine{03428                     \textcolor{keywordflow}{if}( xExpectedIdleTime >= configEXPECTED\_IDLE\_TIME\_BEFORE\_SLEEP )}
\DoxyCodeLine{03429                     \{}
\DoxyCodeLine{03430                         traceLOW\_POWER\_IDLE\_BEGIN();}
\DoxyCodeLine{03431                         portSUPPRESS\_TICKS\_AND\_SLEEP( xExpectedIdleTime );}
\DoxyCodeLine{03432                         traceLOW\_POWER\_IDLE\_END();}
\DoxyCodeLine{03433                     \}}
\DoxyCodeLine{03434                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03435                     \{}
\DoxyCodeLine{03436                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03437                     \}}
\DoxyCodeLine{03438                 \}}
\DoxyCodeLine{03439                 ( void ) xTaskResumeAll();}
\DoxyCodeLine{03440             \}}
\DoxyCodeLine{03441             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03442             \{}
\DoxyCodeLine{03443                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03444             \}}
\DoxyCodeLine{03445         \}}
\DoxyCodeLine{03446 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_TICKLESS\_IDLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03447     \}}
\DoxyCodeLine{03448 \}}
\DoxyCodeLine{03449 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03450 }
\DoxyCodeLine{03451 \textcolor{preprocessor}{\#if( configUSE\_TICKLESS\_IDLE != 0 )}}
\DoxyCodeLine{03452 }
\DoxyCodeLine{03453     eSleepModeStatus eTaskConfirmSleepModeStatus( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{03454     \{}
\DoxyCodeLine{03455     \textcolor{comment}{/* The idle task exists in addition to the application tasks. */}}
\DoxyCodeLine{03456     \textcolor{keyword}{const} UBaseType\_t uxNonApplicationTasks = 1;}
\DoxyCodeLine{03457     eSleepModeStatus eReturn = eStandardSleep;}
\DoxyCodeLine{03458 }
\DoxyCodeLine{03459         \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( \&xPendingReadyList ) != 0 )}
\DoxyCodeLine{03460         \{}
\DoxyCodeLine{03461             \textcolor{comment}{/* A task was made ready while the scheduler was suspended. */}}
\DoxyCodeLine{03462             eReturn = eAbortSleep;}
\DoxyCodeLine{03463         \}}
\DoxyCodeLine{03464         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( xYieldPending != pdFALSE )}
\DoxyCodeLine{03465         \{}
\DoxyCodeLine{03466             \textcolor{comment}{/* A yield was pended while the scheduler was suspended. */}}
\DoxyCodeLine{03467             eReturn = eAbortSleep;}
\DoxyCodeLine{03468         \}}
\DoxyCodeLine{03469         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03470         \{}
\DoxyCodeLine{03471             \textcolor{comment}{/* If all the tasks are in the suspended list (which might mean they}}
\DoxyCodeLine{03472 \textcolor{comment}{            have an infinite block time rather than actually being suspended)}}
\DoxyCodeLine{03473 \textcolor{comment}{            then it is safe to turn all clocks off and just wait for external}}
\DoxyCodeLine{03474 \textcolor{comment}{            interrupts. */}}
\DoxyCodeLine{03475             \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( \&xSuspendedTaskList ) == ( uxCurrentNumberOfTasks -\/ uxNonApplicationTasks ) )}
\DoxyCodeLine{03476             \{}
\DoxyCodeLine{03477                 eReturn = eNoTasksWaitingTimeout;}
\DoxyCodeLine{03478             \}}
\DoxyCodeLine{03479             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03480             \{}
\DoxyCodeLine{03481                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03482             \}}
\DoxyCodeLine{03483         \}}
\DoxyCodeLine{03484 }
\DoxyCodeLine{03485         \textcolor{keywordflow}{return} eReturn;}
\DoxyCodeLine{03486     \}}
\DoxyCodeLine{03487 }
\DoxyCodeLine{03488 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TICKLESS\_IDLE */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03489 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03490 }
\DoxyCodeLine{03491 \textcolor{preprocessor}{\#if ( configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS != 0 )}}
\DoxyCodeLine{03492 }
\DoxyCodeLine{03493     \textcolor{keywordtype}{void} vTaskSetThreadLocalStoragePointer( TaskHandle\_t xTaskToSet, BaseType\_t xIndex, \textcolor{keywordtype}{void} *pvValue )}
\DoxyCodeLine{03494     \{}
\DoxyCodeLine{03495     TCB\_t *pxTCB;}
\DoxyCodeLine{03496 }
\DoxyCodeLine{03497         \textcolor{keywordflow}{if}( xIndex < configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS )}
\DoxyCodeLine{03498         \{}
\DoxyCodeLine{03499             pxTCB = prvGetTCBFromHandle( xTaskToSet );}
\DoxyCodeLine{03500             pxTCB-\/>pvThreadLocalStoragePointers[ xIndex ] = pvValue;}
\DoxyCodeLine{03501         \}}
\DoxyCodeLine{03502     \}}
\DoxyCodeLine{03503 }
\DoxyCodeLine{03504 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03505 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03506 }
\DoxyCodeLine{03507 \textcolor{preprocessor}{\#if ( configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS != 0 )}}
\DoxyCodeLine{03508 }
\DoxyCodeLine{03509     \textcolor{keywordtype}{void} *pvTaskGetThreadLocalStoragePointer( TaskHandle\_t xTaskToQuery, BaseType\_t xIndex )}
\DoxyCodeLine{03510     \{}
\DoxyCodeLine{03511     \textcolor{keywordtype}{void} *pvReturn = NULL;}
\DoxyCodeLine{03512     TCB\_t *pxTCB;}
\DoxyCodeLine{03513 }
\DoxyCodeLine{03514         \textcolor{keywordflow}{if}( xIndex < configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS )}
\DoxyCodeLine{03515         \{}
\DoxyCodeLine{03516             pxTCB = prvGetTCBFromHandle( xTaskToQuery );}
\DoxyCodeLine{03517             pvReturn = pxTCB-\/>pvThreadLocalStoragePointers[ xIndex ];}
\DoxyCodeLine{03518         \}}
\DoxyCodeLine{03519         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03520         \{}
\DoxyCodeLine{03521             pvReturn = NULL;}
\DoxyCodeLine{03522         \}}
\DoxyCodeLine{03523 }
\DoxyCodeLine{03524         \textcolor{keywordflow}{return} pvReturn;}
\DoxyCodeLine{03525     \}}
\DoxyCodeLine{03526 }
\DoxyCodeLine{03527 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configNUM\_THREAD\_LOCAL\_STORAGE\_POINTERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03528 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03529 }
\DoxyCodeLine{03530 \textcolor{preprocessor}{\#if ( portUSING\_MPU\_WRAPPERS == 1 )}}
\DoxyCodeLine{03531 }
\DoxyCodeLine{03532     \textcolor{keywordtype}{void} vTaskAllocateMPURegions( TaskHandle\_t xTaskToModify, \textcolor{keyword}{const} MemoryRegion\_t * \textcolor{keyword}{const} xRegions )}
\DoxyCodeLine{03533     \{}
\DoxyCodeLine{03534     TCB\_t *pxTCB;}
\DoxyCodeLine{03535 }
\DoxyCodeLine{03536         \textcolor{comment}{/* If null is passed in here then we are modifying the MPU settings of}}
\DoxyCodeLine{03537 \textcolor{comment}{        the calling task. */}}
\DoxyCodeLine{03538         pxTCB = prvGetTCBFromHandle( xTaskToModify );}
\DoxyCodeLine{03539 }
\DoxyCodeLine{03540         vPortStoreTaskMPUSettings( \&( pxTCB-\/>xMPUSettings ), xRegions, NULL, 0 );}
\DoxyCodeLine{03541     \}}
\DoxyCodeLine{03542 }
\DoxyCodeLine{03543 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* portUSING\_MPU\_WRAPPERS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03544 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03545 }
\DoxyCodeLine{03546 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvInitialiseTaskLists( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{03547 \{}
\DoxyCodeLine{03548 UBaseType\_t uxPriority;}
\DoxyCodeLine{03549 }
\DoxyCodeLine{03550     \textcolor{keywordflow}{for}( uxPriority = ( UBaseType\_t ) 0U; uxPriority < ( UBaseType\_t ) configMAX\_PRIORITIES; uxPriority++ )}
\DoxyCodeLine{03551     \{}
\DoxyCodeLine{03552         vListInitialise( \&( pxReadyTasksLists[ uxPriority ] ) );}
\DoxyCodeLine{03553     \}}
\DoxyCodeLine{03554 }
\DoxyCodeLine{03555     vListInitialise( \&xDelayedTaskList1 );}
\DoxyCodeLine{03556     vListInitialise( \&xDelayedTaskList2 );}
\DoxyCodeLine{03557     vListInitialise( \&xPendingReadyList );}
\DoxyCodeLine{03558 }
\DoxyCodeLine{03559 \textcolor{preprocessor}{    \#if ( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{03560     \{}
\DoxyCodeLine{03561         vListInitialise( \&xTasksWaitingTermination );}
\DoxyCodeLine{03562     \}}
\DoxyCodeLine{03563 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* INCLUDE\_vTaskDelete */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03564 }
\DoxyCodeLine{03565 \textcolor{preprocessor}{    \#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{03566     \{}
\DoxyCodeLine{03567         vListInitialise( \&xSuspendedTaskList );}
\DoxyCodeLine{03568     \}}
\DoxyCodeLine{03569 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03570 }
\DoxyCodeLine{03571     \textcolor{comment}{/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList}}
\DoxyCodeLine{03572 \textcolor{comment}{    using list2. */}}
\DoxyCodeLine{03573     pxDelayedTaskList = \&xDelayedTaskList1;}
\DoxyCodeLine{03574     pxOverflowDelayedTaskList = \&xDelayedTaskList2;}
\DoxyCodeLine{03575 \}}
\DoxyCodeLine{03576 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03577 }
\DoxyCodeLine{03578 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvCheckTasksWaitingTermination( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{03579 \{}
\DoxyCodeLine{03580 }
\DoxyCodeLine{03583 \textcolor{preprocessor}{    \#if ( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{03584     \{}
\DoxyCodeLine{03585         TCB\_t *pxTCB;}
\DoxyCodeLine{03586 }
\DoxyCodeLine{03587         \textcolor{comment}{/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER\_CRITICAL()}}
\DoxyCodeLine{03588 \textcolor{comment}{        being called too often in the idle task. */}}
\DoxyCodeLine{03589         \textcolor{keywordflow}{while}( uxDeletedTasksWaitingCleanUp > ( UBaseType\_t ) 0U )}
\DoxyCodeLine{03590         \{}
\DoxyCodeLine{03591             taskENTER\_CRITICAL();}
\DoxyCodeLine{03592             \{}
\DoxyCodeLine{03593                 pxTCB = listGET\_OWNER\_OF\_HEAD\_ENTRY( ( \&xTasksWaitingTermination ) ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{03594                 ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{03595                 -\/-\/uxCurrentNumberOfTasks;}
\DoxyCodeLine{03596                 -\/-\/uxDeletedTasksWaitingCleanUp;}
\DoxyCodeLine{03597             \}}
\DoxyCodeLine{03598             taskEXIT\_CRITICAL();}
\DoxyCodeLine{03599 }
\DoxyCodeLine{03600             prvDeleteTCB( pxTCB );}
\DoxyCodeLine{03601         \}}
\DoxyCodeLine{03602     \}}
\DoxyCodeLine{03603 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* INCLUDE\_vTaskDelete */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03604 \}}
\DoxyCodeLine{03605 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03606 }
\DoxyCodeLine{03607 \textcolor{preprocessor}{\#if( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{03608 }
\DoxyCodeLine{03609     \textcolor{keywordtype}{void} vTaskGetInfo( TaskHandle\_t xTask, TaskStatus\_t *pxTaskStatus, BaseType\_t xGetFreeStackSpace, eTaskState eState )}
\DoxyCodeLine{03610     \{}
\DoxyCodeLine{03611     TCB\_t *pxTCB;}
\DoxyCodeLine{03612 }
\DoxyCodeLine{03613         \textcolor{comment}{/* xTask is NULL then get the state of the calling task. */}}
\DoxyCodeLine{03614         pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{03615 }
\DoxyCodeLine{03616         pxTaskStatus-\/>xHandle = ( TaskHandle\_t ) pxTCB;}
\DoxyCodeLine{03617         pxTaskStatus-\/>pcTaskName = ( \textcolor{keyword}{const} \textcolor{keywordtype}{char} * ) \&( pxTCB-\/>pcTaskName [ 0 ] );}
\DoxyCodeLine{03618         pxTaskStatus-\/>uxCurrentPriority = pxTCB-\/>uxPriority;}
\DoxyCodeLine{03619         pxTaskStatus-\/>pxStackBase = pxTCB-\/>pxStack;}
\DoxyCodeLine{03620         pxTaskStatus-\/>xTaskNumber = pxTCB-\/>uxTCBNumber;}
\DoxyCodeLine{03621 }
\DoxyCodeLine{03622 \textcolor{preprocessor}{        \#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{03623         \{}
\DoxyCodeLine{03624             pxTaskStatus-\/>uxBasePriority = pxTCB-\/>uxBasePriority;}
\DoxyCodeLine{03625         \}}
\DoxyCodeLine{03626 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{03627         \{}
\DoxyCodeLine{03628             pxTaskStatus-\/>uxBasePriority = 0;}
\DoxyCodeLine{03629         \}}
\DoxyCodeLine{03630 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03631 }
\DoxyCodeLine{03632 \textcolor{preprocessor}{        \#if ( configGENERATE\_RUN\_TIME\_STATS == 1 )}}
\DoxyCodeLine{03633         \{}
\DoxyCodeLine{03634             pxTaskStatus-\/>ulRunTimeCounter = pxTCB-\/>ulRunTimeCounter;}
\DoxyCodeLine{03635         \}}
\DoxyCodeLine{03636 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{03637         \{}
\DoxyCodeLine{03638             pxTaskStatus-\/>ulRunTimeCounter = 0;}
\DoxyCodeLine{03639         \}}
\DoxyCodeLine{03640 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03641 }
\DoxyCodeLine{03642         \textcolor{comment}{/* Obtaining the task state is a little fiddly, so is only done if the}}
\DoxyCodeLine{03643 \textcolor{comment}{        value of eState passed into this function is eInvalid -\/ otherwise the}}
\DoxyCodeLine{03644 \textcolor{comment}{        state is just set to whatever is passed in. */}}
\DoxyCodeLine{03645         \textcolor{keywordflow}{if}( eState != eInvalid )}
\DoxyCodeLine{03646         \{}
\DoxyCodeLine{03647             \textcolor{keywordflow}{if}( pxTCB == pxCurrentTCB )}
\DoxyCodeLine{03648             \{}
\DoxyCodeLine{03649                 pxTaskStatus-\/>eCurrentState = eRunning;}
\DoxyCodeLine{03650             \}}
\DoxyCodeLine{03651             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03652             \{}
\DoxyCodeLine{03653                 pxTaskStatus-\/>eCurrentState = eState;}
\DoxyCodeLine{03654 }
\DoxyCodeLine{03655 \textcolor{preprocessor}{                \#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{03656                 \{}
\DoxyCodeLine{03657                     \textcolor{comment}{/* If the task is in the suspended list then there is a}}
\DoxyCodeLine{03658 \textcolor{comment}{                    chance it is actually just blocked indefinitely -\/ so really}}
\DoxyCodeLine{03659 \textcolor{comment}{                    it should be reported as being in the Blocked state. */}}
\DoxyCodeLine{03660                     \textcolor{keywordflow}{if}( eState == eSuspended )}
\DoxyCodeLine{03661                     \{}
\DoxyCodeLine{03662                         vTaskSuspendAll();}
\DoxyCodeLine{03663                         \{}
\DoxyCodeLine{03664                             \textcolor{keywordflow}{if}( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) != NULL )}
\DoxyCodeLine{03665                             \{}
\DoxyCodeLine{03666                                 pxTaskStatus-\/>eCurrentState = eBlocked;}
\DoxyCodeLine{03667                             \}}
\DoxyCodeLine{03668                         \}}
\DoxyCodeLine{03669                         ( void ) xTaskResumeAll();}
\DoxyCodeLine{03670                     \}}
\DoxyCodeLine{03671                 \}}
\DoxyCodeLine{03672 \textcolor{preprocessor}{                \#endif }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03673             \}}
\DoxyCodeLine{03674         \}}
\DoxyCodeLine{03675         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03676         \{}
\DoxyCodeLine{03677             pxTaskStatus-\/>eCurrentState = eTaskGetState( pxTCB );}
\DoxyCodeLine{03678         \}}
\DoxyCodeLine{03679 }
\DoxyCodeLine{03680         \textcolor{comment}{/* Obtaining the stack space takes some time, so the xGetFreeStackSpace}}
\DoxyCodeLine{03681 \textcolor{comment}{        parameter is provided to allow it to be skipped. */}}
\DoxyCodeLine{03682         \textcolor{keywordflow}{if}( xGetFreeStackSpace != pdFALSE )}
\DoxyCodeLine{03683         \{}
\DoxyCodeLine{03684 \textcolor{preprocessor}{            \#if ( portSTACK\_GROWTH > 0 )}}
\DoxyCodeLine{03685             \{}
\DoxyCodeLine{03686                 pxTaskStatus-\/>usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8\_t * ) pxTCB-\/>pxEndOfStack );}
\DoxyCodeLine{03687             \}}
\DoxyCodeLine{03688 \textcolor{preprocessor}{            \#else}}
\DoxyCodeLine{03689             \{}
\DoxyCodeLine{03690                 pxTaskStatus-\/>usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8\_t * ) pxTCB-\/>pxStack );}
\DoxyCodeLine{03691             \}}
\DoxyCodeLine{03692 \textcolor{preprocessor}{            \#endif}}
\DoxyCodeLine{03693         \}}
\DoxyCodeLine{03694         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03695         \{}
\DoxyCodeLine{03696             pxTaskStatus-\/>usStackHighWaterMark = 0;}
\DoxyCodeLine{03697         \}}
\DoxyCodeLine{03698     \}}
\DoxyCodeLine{03699 }
\DoxyCodeLine{03700 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03701 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03702 }
\DoxyCodeLine{03703 \textcolor{preprocessor}{\#if ( configUSE\_TRACE\_FACILITY == 1 )}}
\DoxyCodeLine{03704 }
\DoxyCodeLine{03705     \textcolor{keyword}{static} UBaseType\_t prvListTasksWithinSingleList( TaskStatus\_t *pxTaskStatusArray, List\_t *pxList, eTaskState eState )}
\DoxyCodeLine{03706     \{}
\DoxyCodeLine{03707     configLIST\_VOLATILE TCB\_t *pxNextTCB, *pxFirstTCB;}
\DoxyCodeLine{03708     UBaseType\_t uxTask = 0;}
\DoxyCodeLine{03709 }
\DoxyCodeLine{03710         \textcolor{keywordflow}{if}( listCURRENT\_LIST\_LENGTH( pxList ) > ( UBaseType\_t ) 0 )}
\DoxyCodeLine{03711         \{}
\DoxyCodeLine{03712             listGET\_OWNER\_OF\_NEXT\_ENTRY( pxFirstTCB, pxList ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{03713 }
\DoxyCodeLine{03714             \textcolor{comment}{/* Populate an TaskStatus\_t structure within the}}
\DoxyCodeLine{03715 \textcolor{comment}{            pxTaskStatusArray array for each task that is referenced from}}
\DoxyCodeLine{03716 \textcolor{comment}{            pxList.  See the definition of TaskStatus\_t in task.h for the}}
\DoxyCodeLine{03717 \textcolor{comment}{            meaning of each TaskStatus\_t structure member. */}}
\DoxyCodeLine{03718             \textcolor{keywordflow}{do}}
\DoxyCodeLine{03719             \{}
\DoxyCodeLine{03720                 listGET\_OWNER\_OF\_NEXT\_ENTRY( pxNextTCB, pxList ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{03721                 vTaskGetInfo( ( TaskHandle\_t ) pxNextTCB, \&( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );}
\DoxyCodeLine{03722                 uxTask++;}
\DoxyCodeLine{03723             \} \textcolor{keywordflow}{while}( pxNextTCB != pxFirstTCB );}
\DoxyCodeLine{03724         \}}
\DoxyCodeLine{03725         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03726         \{}
\DoxyCodeLine{03727             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03728         \}}
\DoxyCodeLine{03729 }
\DoxyCodeLine{03730         \textcolor{keywordflow}{return} uxTask;}
\DoxyCodeLine{03731     \}}
\DoxyCodeLine{03732 }
\DoxyCodeLine{03733 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TRACE\_FACILITY */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03734 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03735 }
\DoxyCodeLine{03736 \textcolor{preprocessor}{\#if ( ( configUSE\_TRACE\_FACILITY == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark2 == 1 ) )}}
\DoxyCodeLine{03737 }
\DoxyCodeLine{03738     \textcolor{keyword}{static} configSTACK\_DEPTH\_TYPE prvTaskCheckFreeStackSpace( \textcolor{keyword}{const} uint8\_t * pucStackByte )}
\DoxyCodeLine{03739     \{}
\DoxyCodeLine{03740     uint32\_t ulCount = 0U;}
\DoxyCodeLine{03741 }
\DoxyCodeLine{03742         \textcolor{keywordflow}{while}( *pucStackByte == ( uint8\_t ) tskSTACK\_FILL\_BYTE )}
\DoxyCodeLine{03743         \{}
\DoxyCodeLine{03744             pucStackByte -\/= portSTACK\_GROWTH;}
\DoxyCodeLine{03745             ulCount++;}
\DoxyCodeLine{03746         \}}
\DoxyCodeLine{03747 }
\DoxyCodeLine{03748         ulCount /= ( uint32\_t ) \textcolor{keyword}{sizeof}( StackType\_t ); \textcolor{comment}{/*lint !e961 Casting is not redundant on smaller architectures. */}}
\DoxyCodeLine{03749 }
\DoxyCodeLine{03750         \textcolor{keywordflow}{return} ( configSTACK\_DEPTH\_TYPE ) ulCount;}
\DoxyCodeLine{03751     \}}
\DoxyCodeLine{03752 }
\DoxyCodeLine{03753 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( configUSE\_TRACE\_FACILITY == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE\_uxTaskGetStackHighWaterMark2 == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03754 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03755 }
\DoxyCodeLine{03756 \textcolor{preprocessor}{\#if ( INCLUDE\_uxTaskGetStackHighWaterMark2 == 1 )}}
\DoxyCodeLine{03757 }
\DoxyCodeLine{03758     \textcolor{comment}{/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the}}
\DoxyCodeLine{03759 \textcolor{comment}{    same except for their return type.  Using configSTACK\_DEPTH\_TYPE allows the}}
\DoxyCodeLine{03760 \textcolor{comment}{    user to determine the return type.  It gets around the problem of the value}}
\DoxyCodeLine{03761 \textcolor{comment}{    overflowing on 8-\/bit types without breaking backward compatibility for}}
\DoxyCodeLine{03762 \textcolor{comment}{    applications that expect an 8-\/bit return type. */}}
\DoxyCodeLine{03763     configSTACK\_DEPTH\_TYPE uxTaskGetStackHighWaterMark2( TaskHandle\_t xTask )}
\DoxyCodeLine{03764     \{}
\DoxyCodeLine{03765     TCB\_t *pxTCB;}
\DoxyCodeLine{03766     uint8\_t *pucEndOfStack;}
\DoxyCodeLine{03767     configSTACK\_DEPTH\_TYPE uxReturn;}
\DoxyCodeLine{03768 }
\DoxyCodeLine{03769         \textcolor{comment}{/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are}}
\DoxyCodeLine{03770 \textcolor{comment}{        the same except for their return type.  Using configSTACK\_DEPTH\_TYPE}}
\DoxyCodeLine{03771 \textcolor{comment}{        allows the user to determine the return type.  It gets around the}}
\DoxyCodeLine{03772 \textcolor{comment}{        problem of the value overflowing on 8-\/bit types without breaking}}
\DoxyCodeLine{03773 \textcolor{comment}{        backward compatibility for applications that expect an 8-\/bit return}}
\DoxyCodeLine{03774 \textcolor{comment}{        type. */}}
\DoxyCodeLine{03775 }
\DoxyCodeLine{03776         pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{03777 }
\DoxyCodeLine{03778 \textcolor{preprocessor}{        \#if portSTACK\_GROWTH < 0}}
\DoxyCodeLine{03779         \{}
\DoxyCodeLine{03780             pucEndOfStack = ( uint8\_t * ) pxTCB-\/>pxStack;}
\DoxyCodeLine{03781         \}}
\DoxyCodeLine{03782 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{03783         \{}
\DoxyCodeLine{03784             pucEndOfStack = ( uint8\_t * ) pxTCB-\/>pxEndOfStack;}
\DoxyCodeLine{03785         \}}
\DoxyCodeLine{03786 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03787 }
\DoxyCodeLine{03788         uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );}
\DoxyCodeLine{03789 }
\DoxyCodeLine{03790         \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{03791     \}}
\DoxyCodeLine{03792 }
\DoxyCodeLine{03793 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_uxTaskGetStackHighWaterMark2 */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03794 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03795 }
\DoxyCodeLine{03796 \textcolor{preprocessor}{\#if ( INCLUDE\_uxTaskGetStackHighWaterMark == 1 )}}
\DoxyCodeLine{03797 }
\DoxyCodeLine{03798     UBaseType\_t uxTaskGetStackHighWaterMark( TaskHandle\_t xTask )}
\DoxyCodeLine{03799     \{}
\DoxyCodeLine{03800     TCB\_t *pxTCB;}
\DoxyCodeLine{03801     uint8\_t *pucEndOfStack;}
\DoxyCodeLine{03802     UBaseType\_t uxReturn;}
\DoxyCodeLine{03803 }
\DoxyCodeLine{03804         pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{03805 }
\DoxyCodeLine{03806 \textcolor{preprocessor}{        \#if portSTACK\_GROWTH < 0}}
\DoxyCodeLine{03807         \{}
\DoxyCodeLine{03808             pucEndOfStack = ( uint8\_t * ) pxTCB-\/>pxStack;}
\DoxyCodeLine{03809         \}}
\DoxyCodeLine{03810 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{03811         \{}
\DoxyCodeLine{03812             pucEndOfStack = ( uint8\_t * ) pxTCB-\/>pxEndOfStack;}
\DoxyCodeLine{03813         \}}
\DoxyCodeLine{03814 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{03815 }
\DoxyCodeLine{03816         uxReturn = ( UBaseType\_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );}
\DoxyCodeLine{03817 }
\DoxyCodeLine{03818         \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{03819     \}}
\DoxyCodeLine{03820 }
\DoxyCodeLine{03821 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_uxTaskGetStackHighWaterMark */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03822 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03823 }
\DoxyCodeLine{03824 \textcolor{preprocessor}{\#if ( INCLUDE\_vTaskDelete == 1 )}}
\DoxyCodeLine{03825 }
\DoxyCodeLine{03826     \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvDeleteTCB( TCB\_t *pxTCB )}
\DoxyCodeLine{03827     \{}
\DoxyCodeLine{03828         \textcolor{comment}{/* This call is required specifically for the TriCore port.  It must be}}
\DoxyCodeLine{03829 \textcolor{comment}{        above the vPortFree() calls.  The call is also used by ports/demos that}}
\DoxyCodeLine{03830 \textcolor{comment}{        want to allocate and clean RAM statically. */}}
\DoxyCodeLine{03831         portCLEAN\_UP\_TCB( pxTCB );}
\DoxyCodeLine{03832 }
\DoxyCodeLine{03833         \textcolor{comment}{/* Free up the memory allocated by the scheduler for the task.  It is up}}
\DoxyCodeLine{03834 \textcolor{comment}{        to the task to free any memory allocated at the application level. */}}
\DoxyCodeLine{03835 \textcolor{preprocessor}{        \#if ( configUSE\_NEWLIB\_REENTRANT == 1 )}}
\DoxyCodeLine{03836         \{}
\DoxyCodeLine{03837             \_reclaim\_reent( \&( pxTCB-\/>xNewLib\_reent ) );}
\DoxyCodeLine{03838         \}}
\DoxyCodeLine{03839 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configUSE\_NEWLIB\_REENTRANT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03840 }
\DoxyCodeLine{03841 \textcolor{preprocessor}{        \#if( ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 0 ) \&\& ( portUSING\_MPU\_WRAPPERS == 0 ) )}}
\DoxyCodeLine{03842         \{}
\DoxyCodeLine{03843             \textcolor{comment}{/* The task can only have been allocated dynamically -\/ free both}}
\DoxyCodeLine{03844 \textcolor{comment}{            the stack and TCB. */}}
\DoxyCodeLine{03845             vPortFree( pxTCB-\/>pxStack );}
\DoxyCodeLine{03846             vPortFree( pxTCB );}
\DoxyCodeLine{03847         \}}
\DoxyCodeLine{03848 \textcolor{preprocessor}{        \#elif( tskSTATIC\_AND\_DYNAMIC\_ALLOCATION\_POSSIBLE != 0 ) }\textcolor{comment}{/*lint !e731 !e9029 Macro has been consolidated for readability reasons. */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03849         \{}
\DoxyCodeLine{03850             \textcolor{comment}{/* The task could have been allocated statically or dynamically, so}}
\DoxyCodeLine{03851 \textcolor{comment}{            check what was statically allocated before trying to free the}}
\DoxyCodeLine{03852 \textcolor{comment}{            memory. */}}
\DoxyCodeLine{03853             \textcolor{keywordflow}{if}( pxTCB-\/>ucStaticallyAllocated == tskDYNAMICALLY\_ALLOCATED\_STACK\_AND\_TCB )}
\DoxyCodeLine{03854             \{}
\DoxyCodeLine{03855                 \textcolor{comment}{/* Both the stack and TCB were allocated dynamically, so both}}
\DoxyCodeLine{03856 \textcolor{comment}{                must be freed. */}}
\DoxyCodeLine{03857                 vPortFree( pxTCB-\/>pxStack );}
\DoxyCodeLine{03858                 vPortFree( pxTCB );}
\DoxyCodeLine{03859             \}}
\DoxyCodeLine{03860             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( pxTCB-\/>ucStaticallyAllocated == tskSTATICALLY\_ALLOCATED\_STACK\_ONLY )}
\DoxyCodeLine{03861             \{}
\DoxyCodeLine{03862                 \textcolor{comment}{/* Only the stack was statically allocated, so the TCB is the}}
\DoxyCodeLine{03863 \textcolor{comment}{                only memory that must be freed. */}}
\DoxyCodeLine{03864                 vPortFree( pxTCB );}
\DoxyCodeLine{03865             \}}
\DoxyCodeLine{03866             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03867             \{}
\DoxyCodeLine{03868                 \textcolor{comment}{/* Neither the stack nor the TCB were allocated dynamically, so}}
\DoxyCodeLine{03869 \textcolor{comment}{                nothing needs to be freed. */}}
\DoxyCodeLine{03870                 configASSERT( pxTCB-\/>ucStaticallyAllocated == tskSTATICALLY\_ALLOCATED\_STACK\_AND\_TCB );}
\DoxyCodeLine{03871                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03872             \}}
\DoxyCodeLine{03873         \}}
\DoxyCodeLine{03874 \textcolor{preprocessor}{        \#endif }\textcolor{comment}{/* configSUPPORT\_DYNAMIC\_ALLOCATION */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03875     \}}
\DoxyCodeLine{03876 }
\DoxyCodeLine{03877 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* INCLUDE\_vTaskDelete */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03878 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03879 }
\DoxyCodeLine{03880 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvResetNextTaskUnblockTime( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{03881 \{}
\DoxyCodeLine{03882 TCB\_t *pxTCB;}
\DoxyCodeLine{03883 }
\DoxyCodeLine{03884     \textcolor{keywordflow}{if}( listLIST\_IS\_EMPTY( pxDelayedTaskList ) != pdFALSE )}
\DoxyCodeLine{03885     \{}
\DoxyCodeLine{03886         \textcolor{comment}{/* The new current delayed list is empty.  Set xNextTaskUnblockTime to}}
\DoxyCodeLine{03887 \textcolor{comment}{        the maximum possible value so it is extremely unlikely that the}}
\DoxyCodeLine{03888 \textcolor{comment}{        if( xTickCount >= xNextTaskUnblockTime ) test will pass until}}
\DoxyCodeLine{03889 \textcolor{comment}{        there is an item in the delayed list. */}}
\DoxyCodeLine{03890         xNextTaskUnblockTime = portMAX\_DELAY;}
\DoxyCodeLine{03891     \}}
\DoxyCodeLine{03892     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03893     \{}
\DoxyCodeLine{03894         \textcolor{comment}{/* The new current delayed list is not empty, get the value of}}
\DoxyCodeLine{03895 \textcolor{comment}{        the item at the head of the delayed list.  This is the time at}}
\DoxyCodeLine{03896 \textcolor{comment}{        which the task at the head of the delayed list should be removed}}
\DoxyCodeLine{03897 \textcolor{comment}{        from the Blocked state. */}}
\DoxyCodeLine{03898         ( pxTCB ) = listGET\_OWNER\_OF\_HEAD\_ENTRY( pxDelayedTaskList ); \textcolor{comment}{/*lint !e9079 void * is used as this macro is used with timers and co-\/routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */}}
\DoxyCodeLine{03899         xNextTaskUnblockTime = listGET\_LIST\_ITEM\_VALUE( \&( ( pxTCB )-\/>xStateListItem ) );}
\DoxyCodeLine{03900     \}}
\DoxyCodeLine{03901 \}}
\DoxyCodeLine{03902 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03903 }
\DoxyCodeLine{03904 \textcolor{preprocessor}{\#if ( ( INCLUDE\_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE\_MUTEXES == 1 ) )}}
\DoxyCodeLine{03905 }
\DoxyCodeLine{03906     TaskHandle\_t xTaskGetCurrentTaskHandle( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{03907     \{}
\DoxyCodeLine{03908     TaskHandle\_t xReturn;}
\DoxyCodeLine{03909 }
\DoxyCodeLine{03910         \textcolor{comment}{/* A critical section is not required as this is not called from}}
\DoxyCodeLine{03911 \textcolor{comment}{        an interrupt and the current TCB will always be the same for any}}
\DoxyCodeLine{03912 \textcolor{comment}{        individual execution thread. */}}
\DoxyCodeLine{03913         xReturn = pxCurrentTCB;}
\DoxyCodeLine{03914 }
\DoxyCodeLine{03915         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{03916     \}}
\DoxyCodeLine{03917 }
\DoxyCodeLine{03918 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( INCLUDE\_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE\_MUTEXES == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03919 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03920 }
\DoxyCodeLine{03921 \textcolor{preprocessor}{\#if ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) )}}
\DoxyCodeLine{03922 }
\DoxyCodeLine{03923     BaseType\_t xTaskGetSchedulerState( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{03924     \{}
\DoxyCodeLine{03925     BaseType\_t xReturn;}
\DoxyCodeLine{03926 }
\DoxyCodeLine{03927         \textcolor{keywordflow}{if}( xSchedulerRunning == pdFALSE )}
\DoxyCodeLine{03928         \{}
\DoxyCodeLine{03929             xReturn = taskSCHEDULER\_NOT\_STARTED;}
\DoxyCodeLine{03930         \}}
\DoxyCodeLine{03931         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03932         \{}
\DoxyCodeLine{03933             \textcolor{keywordflow}{if}( uxSchedulerSuspended == ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{03934             \{}
\DoxyCodeLine{03935                 xReturn = taskSCHEDULER\_RUNNING;}
\DoxyCodeLine{03936             \}}
\DoxyCodeLine{03937             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03938             \{}
\DoxyCodeLine{03939                 xReturn = taskSCHEDULER\_SUSPENDED;}
\DoxyCodeLine{03940             \}}
\DoxyCodeLine{03941         \}}
\DoxyCodeLine{03942 }
\DoxyCodeLine{03943         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{03944     \}}
\DoxyCodeLine{03945 }
\DoxyCodeLine{03946 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( INCLUDE\_xTaskGetSchedulerState == 1 ) || ( configUSE\_TIMERS == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03947 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{03948 }
\DoxyCodeLine{03949 \textcolor{preprocessor}{\#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{03950 }
\DoxyCodeLine{03951     BaseType\_t xTaskPriorityInherit( TaskHandle\_t \textcolor{keyword}{const} pxMutexHolder )}
\DoxyCodeLine{03952     \{}
\DoxyCodeLine{03953     TCB\_t * \textcolor{keyword}{const} pxMutexHolderTCB = pxMutexHolder;}
\DoxyCodeLine{03954     BaseType\_t xReturn = pdFALSE;}
\DoxyCodeLine{03955 }
\DoxyCodeLine{03956         \textcolor{comment}{/* If the mutex was given back by an interrupt while the queue was}}
\DoxyCodeLine{03957 \textcolor{comment}{        locked then the mutex holder might now be NULL.  \_RB\_ Is this still}}
\DoxyCodeLine{03958 \textcolor{comment}{        needed as interrupts can no longer use mutexes? */}}
\DoxyCodeLine{03959         \textcolor{keywordflow}{if}( pxMutexHolder != NULL )}
\DoxyCodeLine{03960         \{}
\DoxyCodeLine{03961             \textcolor{comment}{/* If the holder of the mutex has a priority below the priority of}}
\DoxyCodeLine{03962 \textcolor{comment}{            the task attempting to obtain the mutex then it will temporarily}}
\DoxyCodeLine{03963 \textcolor{comment}{            inherit the priority of the task attempting to obtain the mutex. */}}
\DoxyCodeLine{03964             \textcolor{keywordflow}{if}( pxMutexHolderTCB-\/>uxPriority < pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{03965             \{}
\DoxyCodeLine{03966                 \textcolor{comment}{/* Adjust the mutex holder state to account for its new}}
\DoxyCodeLine{03967 \textcolor{comment}{                priority.  Only reset the event list item value if the value is}}
\DoxyCodeLine{03968 \textcolor{comment}{                not being used for anything else. */}}
\DoxyCodeLine{03969                 \textcolor{keywordflow}{if}( ( listGET\_LIST\_ITEM\_VALUE( \&( pxMutexHolderTCB-\/>xEventListItem ) ) \& taskEVENT\_LIST\_ITEM\_VALUE\_IN\_USE ) == 0UL )}
\DoxyCodeLine{03970                 \{}
\DoxyCodeLine{03971                     listSET\_LIST\_ITEM\_VALUE( \&( pxMutexHolderTCB-\/>xEventListItem ), ( TickType\_t ) configMAX\_PRIORITIES -\/ ( TickType\_t ) pxCurrentTCB-\/>uxPriority ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{03972                 \}}
\DoxyCodeLine{03973                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{03974                 \{}
\DoxyCodeLine{03975                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03976                 \}}
\DoxyCodeLine{03977 }
\DoxyCodeLine{03978                 \textcolor{comment}{/* If the task being modified is in the ready state it will need}}
\DoxyCodeLine{03979 \textcolor{comment}{                to be moved into a new list. */}}
\DoxyCodeLine{03980                 \textcolor{keywordflow}{if}( listIS\_CONTAINED\_WITHIN( \&( pxReadyTasksLists[ pxMutexHolderTCB-\/>uxPriority ] ), \&( pxMutexHolderTCB-\/>xStateListItem ) ) != pdFALSE )}
\DoxyCodeLine{03981                 \{}
\DoxyCodeLine{03982                     \textcolor{keywordflow}{if}( uxListRemove( \&( pxMutexHolderTCB-\/>xStateListItem ) ) == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{03983                     \{}
\DoxyCodeLine{03984                         taskRESET\_READY\_PRIORITY( pxMutexHolderTCB-\/>uxPriority );}
\DoxyCodeLine{03985                     \}}
\DoxyCodeLine{03986                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03987                     \{}
\DoxyCodeLine{03988                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{03989                     \}}
\DoxyCodeLine{03990 }
\DoxyCodeLine{03991                     \textcolor{comment}{/* Inherit the priority before being moved into the new list. */}}
\DoxyCodeLine{03992                     pxMutexHolderTCB-\/>uxPriority = pxCurrentTCB-\/>uxPriority;}
\DoxyCodeLine{03993                     prvAddTaskToReadyList( pxMutexHolderTCB );}
\DoxyCodeLine{03994                 \}}
\DoxyCodeLine{03995                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{03996                 \{}
\DoxyCodeLine{03997                     \textcolor{comment}{/* Just inherit the priority. */}}
\DoxyCodeLine{03998                     pxMutexHolderTCB-\/>uxPriority = pxCurrentTCB-\/>uxPriority;}
\DoxyCodeLine{03999                 \}}
\DoxyCodeLine{04000 }
\DoxyCodeLine{04001                 traceTASK\_PRIORITY\_INHERIT( pxMutexHolderTCB, pxCurrentTCB-\/>uxPriority );}
\DoxyCodeLine{04002 }
\DoxyCodeLine{04003                 \textcolor{comment}{/* Inheritance occurred. */}}
\DoxyCodeLine{04004                 xReturn = pdTRUE;}
\DoxyCodeLine{04005             \}}
\DoxyCodeLine{04006             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04007             \{}
\DoxyCodeLine{04008                 \textcolor{keywordflow}{if}( pxMutexHolderTCB-\/>uxBasePriority < pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{04009                 \{}
\DoxyCodeLine{04010                     \textcolor{comment}{/* The base priority of the mutex holder is lower than the}}
\DoxyCodeLine{04011 \textcolor{comment}{                    priority of the task attempting to take the mutex, but the}}
\DoxyCodeLine{04012 \textcolor{comment}{                    current priority of the mutex holder is not lower than the}}
\DoxyCodeLine{04013 \textcolor{comment}{                    priority of the task attempting to take the mutex.}}
\DoxyCodeLine{04014 \textcolor{comment}{                    Therefore the mutex holder must have already inherited a}}
\DoxyCodeLine{04015 \textcolor{comment}{                    priority, but inheritance would have occurred if that had}}
\DoxyCodeLine{04016 \textcolor{comment}{                    not been the case. */}}
\DoxyCodeLine{04017                     xReturn = pdTRUE;}
\DoxyCodeLine{04018                 \}}
\DoxyCodeLine{04019                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04020                 \{}
\DoxyCodeLine{04021                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04022                 \}}
\DoxyCodeLine{04023             \}}
\DoxyCodeLine{04024         \}}
\DoxyCodeLine{04025         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04026         \{}
\DoxyCodeLine{04027             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04028         \}}
\DoxyCodeLine{04029 }
\DoxyCodeLine{04030         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{04031     \}}
\DoxyCodeLine{04032 }
\DoxyCodeLine{04033 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04034 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04035 }
\DoxyCodeLine{04036 \textcolor{preprocessor}{\#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{04037 }
\DoxyCodeLine{04038     BaseType\_t xTaskPriorityDisinherit( TaskHandle\_t \textcolor{keyword}{const} pxMutexHolder )}
\DoxyCodeLine{04039     \{}
\DoxyCodeLine{04040     TCB\_t * \textcolor{keyword}{const} pxTCB = pxMutexHolder;}
\DoxyCodeLine{04041     BaseType\_t xReturn = pdFALSE;}
\DoxyCodeLine{04042 }
\DoxyCodeLine{04043         \textcolor{keywordflow}{if}( pxMutexHolder != NULL )}
\DoxyCodeLine{04044         \{}
\DoxyCodeLine{04045             \textcolor{comment}{/* A task can only have an inherited priority if it holds the mutex.}}
\DoxyCodeLine{04046 \textcolor{comment}{            If the mutex is held by a task then it cannot be given from an}}
\DoxyCodeLine{04047 \textcolor{comment}{            interrupt, and if a mutex is given by the holding task then it must}}
\DoxyCodeLine{04048 \textcolor{comment}{            be the running state task. */}}
\DoxyCodeLine{04049             configASSERT( pxTCB == pxCurrentTCB );}
\DoxyCodeLine{04050             configASSERT( pxTCB-\/>uxMutexesHeld );}
\DoxyCodeLine{04051             ( pxTCB-\/>uxMutexesHeld )-\/-\/;}
\DoxyCodeLine{04052 }
\DoxyCodeLine{04053             \textcolor{comment}{/* Has the holder of the mutex inherited the priority of another}}
\DoxyCodeLine{04054 \textcolor{comment}{            task? */}}
\DoxyCodeLine{04055             \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority != pxTCB-\/>uxBasePriority )}
\DoxyCodeLine{04056             \{}
\DoxyCodeLine{04057                 \textcolor{comment}{/* Only disinherit if no other mutexes are held. */}}
\DoxyCodeLine{04058                 \textcolor{keywordflow}{if}( pxTCB-\/>uxMutexesHeld == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{04059                 \{}
\DoxyCodeLine{04060                     \textcolor{comment}{/* A task can only have an inherited priority if it holds}}
\DoxyCodeLine{04061 \textcolor{comment}{                    the mutex.  If the mutex is held by a task then it cannot be}}
\DoxyCodeLine{04062 \textcolor{comment}{                    given from an interrupt, and if a mutex is given by the}}
\DoxyCodeLine{04063 \textcolor{comment}{                    holding task then it must be the running state task.  Remove}}
\DoxyCodeLine{04064 \textcolor{comment}{                    the holding task from the ready list. */}}
\DoxyCodeLine{04065                     \textcolor{keywordflow}{if}( uxListRemove( \&( pxTCB-\/>xStateListItem ) ) == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{04066                     \{}
\DoxyCodeLine{04067                         taskRESET\_READY\_PRIORITY( pxTCB-\/>uxPriority );}
\DoxyCodeLine{04068                     \}}
\DoxyCodeLine{04069                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{04070                     \{}
\DoxyCodeLine{04071                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04072                     \}}
\DoxyCodeLine{04073 }
\DoxyCodeLine{04074                     \textcolor{comment}{/* Disinherit the priority before adding the task into the}}
\DoxyCodeLine{04075 \textcolor{comment}{                    new ready list. */}}
\DoxyCodeLine{04076                     traceTASK\_PRIORITY\_DISINHERIT( pxTCB, pxTCB-\/>uxBasePriority );}
\DoxyCodeLine{04077                     pxTCB-\/>uxPriority = pxTCB-\/>uxBasePriority;}
\DoxyCodeLine{04078 }
\DoxyCodeLine{04079                     \textcolor{comment}{/* Reset the event list item value.  It cannot be in use for}}
\DoxyCodeLine{04080 \textcolor{comment}{                    any other purpose if this task is running, and it must be}}
\DoxyCodeLine{04081 \textcolor{comment}{                    running to give back the mutex. */}}
\DoxyCodeLine{04082                     listSET\_LIST\_ITEM\_VALUE( \&( pxTCB-\/>xEventListItem ), ( TickType\_t ) configMAX\_PRIORITIES -\/ ( TickType\_t ) pxTCB-\/>uxPriority ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{04083                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{04084 }
\DoxyCodeLine{04085                     \textcolor{comment}{/* Return true to indicate that a context switch is required.}}
\DoxyCodeLine{04086 \textcolor{comment}{                    This is only actually required in the corner case whereby}}
\DoxyCodeLine{04087 \textcolor{comment}{                    multiple mutexes were held and the mutexes were given back}}
\DoxyCodeLine{04088 \textcolor{comment}{                    in an order different to that in which they were taken.}}
\DoxyCodeLine{04089 \textcolor{comment}{                    If a context switch did not occur when the first mutex was}}
\DoxyCodeLine{04090 \textcolor{comment}{                    returned, even if a task was waiting on it, then a context}}
\DoxyCodeLine{04091 \textcolor{comment}{                    switch should occur when the last mutex is returned whether}}
\DoxyCodeLine{04092 \textcolor{comment}{                    a task is waiting on it or not. */}}
\DoxyCodeLine{04093                     xReturn = pdTRUE;}
\DoxyCodeLine{04094                 \}}
\DoxyCodeLine{04095                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04096                 \{}
\DoxyCodeLine{04097                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04098                 \}}
\DoxyCodeLine{04099             \}}
\DoxyCodeLine{04100             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04101             \{}
\DoxyCodeLine{04102                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04103             \}}
\DoxyCodeLine{04104         \}}
\DoxyCodeLine{04105         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04106         \{}
\DoxyCodeLine{04107             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04108         \}}
\DoxyCodeLine{04109 }
\DoxyCodeLine{04110         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{04111     \}}
\DoxyCodeLine{04112 }
\DoxyCodeLine{04113 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04114 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04115 }
\DoxyCodeLine{04116 \textcolor{preprocessor}{\#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{04117 }
\DoxyCodeLine{04118     \textcolor{keywordtype}{void} vTaskPriorityDisinheritAfterTimeout( TaskHandle\_t \textcolor{keyword}{const} pxMutexHolder, UBaseType\_t uxHighestPriorityWaitingTask )}
\DoxyCodeLine{04119     \{}
\DoxyCodeLine{04120     TCB\_t * \textcolor{keyword}{const} pxTCB = pxMutexHolder;}
\DoxyCodeLine{04121     UBaseType\_t uxPriorityUsedOnEntry, uxPriorityToUse;}
\DoxyCodeLine{04122     \textcolor{keyword}{const} UBaseType\_t uxOnlyOneMutexHeld = ( UBaseType\_t ) 1;}
\DoxyCodeLine{04123 }
\DoxyCodeLine{04124         \textcolor{keywordflow}{if}( pxMutexHolder != NULL )}
\DoxyCodeLine{04125         \{}
\DoxyCodeLine{04126             \textcolor{comment}{/* If pxMutexHolder is not NULL then the holder must hold at least}}
\DoxyCodeLine{04127 \textcolor{comment}{            one mutex. */}}
\DoxyCodeLine{04128             configASSERT( pxTCB-\/>uxMutexesHeld );}
\DoxyCodeLine{04129 }
\DoxyCodeLine{04130             \textcolor{comment}{/* Determine the priority to which the priority of the task that}}
\DoxyCodeLine{04131 \textcolor{comment}{            holds the mutex should be set.  This will be the greater of the}}
\DoxyCodeLine{04132 \textcolor{comment}{            holding task's base priority and the priority of the highest}}
\DoxyCodeLine{04133 \textcolor{comment}{            priority task that is waiting to obtain the mutex. */}}
\DoxyCodeLine{04134             \textcolor{keywordflow}{if}( pxTCB-\/>uxBasePriority < uxHighestPriorityWaitingTask )}
\DoxyCodeLine{04135             \{}
\DoxyCodeLine{04136                 uxPriorityToUse = uxHighestPriorityWaitingTask;}
\DoxyCodeLine{04137             \}}
\DoxyCodeLine{04138             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04139             \{}
\DoxyCodeLine{04140                 uxPriorityToUse = pxTCB-\/>uxBasePriority;}
\DoxyCodeLine{04141             \}}
\DoxyCodeLine{04142 }
\DoxyCodeLine{04143             \textcolor{comment}{/* Does the priority need to change? */}}
\DoxyCodeLine{04144             \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority != uxPriorityToUse )}
\DoxyCodeLine{04145             \{}
\DoxyCodeLine{04146                 \textcolor{comment}{/* Only disinherit if no other mutexes are held.  This is a}}
\DoxyCodeLine{04147 \textcolor{comment}{                simplification in the priority inheritance implementation.  If}}
\DoxyCodeLine{04148 \textcolor{comment}{                the task that holds the mutex is also holding other mutexes then}}
\DoxyCodeLine{04149 \textcolor{comment}{                the other mutexes may have caused the priority inheritance. */}}
\DoxyCodeLine{04150                 \textcolor{keywordflow}{if}( pxTCB-\/>uxMutexesHeld == uxOnlyOneMutexHeld )}
\DoxyCodeLine{04151                 \{}
\DoxyCodeLine{04152                     \textcolor{comment}{/* If a task has timed out because it already holds the}}
\DoxyCodeLine{04153 \textcolor{comment}{                    mutex it was trying to obtain then it cannot of inherited}}
\DoxyCodeLine{04154 \textcolor{comment}{                    its own priority. */}}
\DoxyCodeLine{04155                     configASSERT( pxTCB != pxCurrentTCB );}
\DoxyCodeLine{04156 }
\DoxyCodeLine{04157                     \textcolor{comment}{/* Disinherit the priority, remembering the previous}}
\DoxyCodeLine{04158 \textcolor{comment}{                    priority to facilitate determining the subject task's}}
\DoxyCodeLine{04159 \textcolor{comment}{                    state. */}}
\DoxyCodeLine{04160                     traceTASK\_PRIORITY\_DISINHERIT( pxTCB, pxTCB-\/>uxBasePriority );}
\DoxyCodeLine{04161                     uxPriorityUsedOnEntry = pxTCB-\/>uxPriority;}
\DoxyCodeLine{04162                     pxTCB-\/>uxPriority = uxPriorityToUse;}
\DoxyCodeLine{04163 }
\DoxyCodeLine{04164                     \textcolor{comment}{/* Only reset the event list item value if the value is not}}
\DoxyCodeLine{04165 \textcolor{comment}{                    being used for anything else. */}}
\DoxyCodeLine{04166                     \textcolor{keywordflow}{if}( ( listGET\_LIST\_ITEM\_VALUE( \&( pxTCB-\/>xEventListItem ) ) \& taskEVENT\_LIST\_ITEM\_VALUE\_IN\_USE ) == 0UL )}
\DoxyCodeLine{04167                     \{}
\DoxyCodeLine{04168                         listSET\_LIST\_ITEM\_VALUE( \&( pxTCB-\/>xEventListItem ), ( TickType\_t ) configMAX\_PRIORITIES -\/ ( TickType\_t ) uxPriorityToUse ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{04169                     \}}
\DoxyCodeLine{04170                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{04171                     \{}
\DoxyCodeLine{04172                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04173                     \}}
\DoxyCodeLine{04174 }
\DoxyCodeLine{04175                     \textcolor{comment}{/* If the running task is not the task that holds the mutex}}
\DoxyCodeLine{04176 \textcolor{comment}{                    then the task that holds the mutex could be in either the}}
\DoxyCodeLine{04177 \textcolor{comment}{                    Ready, Blocked or Suspended states.  Only remove the task}}
\DoxyCodeLine{04178 \textcolor{comment}{                    from its current state list if it is in the Ready state as}}
\DoxyCodeLine{04179 \textcolor{comment}{                    the task's priority is going to change and there is one}}
\DoxyCodeLine{04180 \textcolor{comment}{                    Ready list per priority. */}}
\DoxyCodeLine{04181                     \textcolor{keywordflow}{if}( listIS\_CONTAINED\_WITHIN( \&( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), \&( pxTCB-\/>xStateListItem ) ) != pdFALSE )}
\DoxyCodeLine{04182                     \{}
\DoxyCodeLine{04183                         \textcolor{keywordflow}{if}( uxListRemove( \&( pxTCB-\/>xStateListItem ) ) == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{04184                         \{}
\DoxyCodeLine{04185                             taskRESET\_READY\_PRIORITY( pxTCB-\/>uxPriority );}
\DoxyCodeLine{04186                         \}}
\DoxyCodeLine{04187                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04188                         \{}
\DoxyCodeLine{04189                             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04190                         \}}
\DoxyCodeLine{04191 }
\DoxyCodeLine{04192                         prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{04193                     \}}
\DoxyCodeLine{04194                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{04195                     \{}
\DoxyCodeLine{04196                         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04197                     \}}
\DoxyCodeLine{04198                 \}}
\DoxyCodeLine{04199                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04200                 \{}
\DoxyCodeLine{04201                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04202                 \}}
\DoxyCodeLine{04203             \}}
\DoxyCodeLine{04204             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04205             \{}
\DoxyCodeLine{04206                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04207             \}}
\DoxyCodeLine{04208         \}}
\DoxyCodeLine{04209         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04210         \{}
\DoxyCodeLine{04211             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04212         \}}
\DoxyCodeLine{04213     \}}
\DoxyCodeLine{04214 }
\DoxyCodeLine{04215 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04216 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04217 }
\DoxyCodeLine{04218 \textcolor{preprocessor}{\#if ( portCRITICAL\_NESTING\_IN\_TCB == 1 )}}
\DoxyCodeLine{04219 }
\DoxyCodeLine{04220     \textcolor{keywordtype}{void} vTaskEnterCritical( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{04221     \{}
\DoxyCodeLine{04222         portDISABLE\_INTERRUPTS();}
\DoxyCodeLine{04223 }
\DoxyCodeLine{04224         \textcolor{keywordflow}{if}( xSchedulerRunning != pdFALSE )}
\DoxyCodeLine{04225         \{}
\DoxyCodeLine{04226             ( pxCurrentTCB-\/>uxCriticalNesting )++;}
\DoxyCodeLine{04227 }
\DoxyCodeLine{04228             \textcolor{comment}{/* This is not the interrupt safe version of the enter critical}}
\DoxyCodeLine{04229 \textcolor{comment}{            function so assert() if it is being called from an interrupt}}
\DoxyCodeLine{04230 \textcolor{comment}{            context.  Only API functions that end in "{}FromISR"{} can be used in an}}
\DoxyCodeLine{04231 \textcolor{comment}{            interrupt.  Only assert if the critical nesting count is 1 to}}
\DoxyCodeLine{04232 \textcolor{comment}{            protect against recursive calls if the assert function also uses a}}
\DoxyCodeLine{04233 \textcolor{comment}{            critical section. */}}
\DoxyCodeLine{04234             \textcolor{keywordflow}{if}( pxCurrentTCB-\/>uxCriticalNesting == 1 )}
\DoxyCodeLine{04235             \{}
\DoxyCodeLine{04236                 portASSERT\_IF\_IN\_ISR();}
\DoxyCodeLine{04237             \}}
\DoxyCodeLine{04238         \}}
\DoxyCodeLine{04239         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04240         \{}
\DoxyCodeLine{04241             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04242         \}}
\DoxyCodeLine{04243     \}}
\DoxyCodeLine{04244 }
\DoxyCodeLine{04245 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* portCRITICAL\_NESTING\_IN\_TCB */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04246 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04247 }
\DoxyCodeLine{04248 \textcolor{preprocessor}{\#if ( portCRITICAL\_NESTING\_IN\_TCB == 1 )}}
\DoxyCodeLine{04249 }
\DoxyCodeLine{04250     \textcolor{keywordtype}{void} vTaskExitCritical( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{04251     \{}
\DoxyCodeLine{04252         \textcolor{keywordflow}{if}( xSchedulerRunning != pdFALSE )}
\DoxyCodeLine{04253         \{}
\DoxyCodeLine{04254             \textcolor{keywordflow}{if}( pxCurrentTCB-\/>uxCriticalNesting > 0U )}
\DoxyCodeLine{04255             \{}
\DoxyCodeLine{04256                 ( pxCurrentTCB-\/>uxCriticalNesting )-\/-\/;}
\DoxyCodeLine{04257 }
\DoxyCodeLine{04258                 \textcolor{keywordflow}{if}( pxCurrentTCB-\/>uxCriticalNesting == 0U )}
\DoxyCodeLine{04259                 \{}
\DoxyCodeLine{04260                     portENABLE\_INTERRUPTS();}
\DoxyCodeLine{04261                 \}}
\DoxyCodeLine{04262                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04263                 \{}
\DoxyCodeLine{04264                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04265                 \}}
\DoxyCodeLine{04266             \}}
\DoxyCodeLine{04267             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04268             \{}
\DoxyCodeLine{04269                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04270             \}}
\DoxyCodeLine{04271         \}}
\DoxyCodeLine{04272         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04273         \{}
\DoxyCodeLine{04274             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04275         \}}
\DoxyCodeLine{04276     \}}
\DoxyCodeLine{04277 }
\DoxyCodeLine{04278 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* portCRITICAL\_NESTING\_IN\_TCB */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04279 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04280 }
\DoxyCodeLine{04281 \textcolor{preprocessor}{\#if ( ( configUSE\_TRACE\_FACILITY == 1 ) \&\& ( configUSE\_STATS\_FORMATTING\_FUNCTIONS > 0 ) )}}
\DoxyCodeLine{04282 }
\DoxyCodeLine{04283     \textcolor{keyword}{static} \textcolor{keywordtype}{char} *prvWriteNameToBuffer( \textcolor{keywordtype}{char} *pcBuffer, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *pcTaskName )}
\DoxyCodeLine{04284     \{}
\DoxyCodeLine{04285     \textcolor{keywordtype}{size\_t} x;}
\DoxyCodeLine{04286 }
\DoxyCodeLine{04287         \textcolor{comment}{/* Start by copying the entire string. */}}
\DoxyCodeLine{04288         strcpy( pcBuffer, pcTaskName );}
\DoxyCodeLine{04289 }
\DoxyCodeLine{04290         \textcolor{comment}{/* Pad the end of the string with spaces to ensure columns line up when}}
\DoxyCodeLine{04291 \textcolor{comment}{        printed out. */}}
\DoxyCodeLine{04292         \textcolor{keywordflow}{for}( x = strlen( pcBuffer ); x < ( size\_t ) ( configMAX\_TASK\_NAME\_LEN -\/ 1 ); x++ )}
\DoxyCodeLine{04293         \{}
\DoxyCodeLine{04294             pcBuffer[ x ] = \textcolor{charliteral}{' '};}
\DoxyCodeLine{04295         \}}
\DoxyCodeLine{04296 }
\DoxyCodeLine{04297         \textcolor{comment}{/* Terminate. */}}
\DoxyCodeLine{04298         pcBuffer[ x ] = ( char ) 0x00;}
\DoxyCodeLine{04299 }
\DoxyCodeLine{04300         \textcolor{comment}{/* Return the new end of string. */}}
\DoxyCodeLine{04301         \textcolor{keywordflow}{return} \&( pcBuffer[ x ] );}
\DoxyCodeLine{04302     \}}
\DoxyCodeLine{04303 }
\DoxyCodeLine{04304 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( configUSE\_TRACE\_FACILITY == 1 ) \&\& ( configUSE\_STATS\_FORMATTING\_FUNCTIONS > 0 ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04305 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04306 }
\DoxyCodeLine{04307 \textcolor{preprocessor}{\#if ( ( configUSE\_TRACE\_FACILITY == 1 ) \&\& ( configUSE\_STATS\_FORMATTING\_FUNCTIONS > 0 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{04308 }
\DoxyCodeLine{04309     \textcolor{keywordtype}{void} vTaskList( \textcolor{keywordtype}{char} * pcWriteBuffer )}
\DoxyCodeLine{04310     \{}
\DoxyCodeLine{04311     TaskStatus\_t *pxTaskStatusArray;}
\DoxyCodeLine{04312     UBaseType\_t uxArraySize, x;}
\DoxyCodeLine{04313     \textcolor{keywordtype}{char} cStatus;}
\DoxyCodeLine{04314 }
\DoxyCodeLine{04315         \textcolor{comment}{/*}}
\DoxyCodeLine{04316 \textcolor{comment}{         * PLEASE NOTE:}}
\DoxyCodeLine{04317 \textcolor{comment}{         *}}
\DoxyCodeLine{04318 \textcolor{comment}{         * This function is provided for convenience only, and is used by many}}
\DoxyCodeLine{04319 \textcolor{comment}{         * of the demo applications.  Do not consider it to be part of the}}
\DoxyCodeLine{04320 \textcolor{comment}{         * scheduler.}}
\DoxyCodeLine{04321 \textcolor{comment}{         *}}
\DoxyCodeLine{04322 \textcolor{comment}{         * vTaskList() calls uxTaskGetSystemState(), then formats part of the}}
\DoxyCodeLine{04323 \textcolor{comment}{         * uxTaskGetSystemState() output into a human readable table that}}
\DoxyCodeLine{04324 \textcolor{comment}{         * displays task names, states and stack usage.}}
\DoxyCodeLine{04325 \textcolor{comment}{         *}}
\DoxyCodeLine{04326 \textcolor{comment}{         * vTaskList() has a dependency on the sprintf() C library function that}}
\DoxyCodeLine{04327 \textcolor{comment}{         * might bloat the code size, use a lot of stack, and provide different}}
\DoxyCodeLine{04328 \textcolor{comment}{         * results on different platforms.  An alternative, tiny, third party,}}
\DoxyCodeLine{04329 \textcolor{comment}{         * and limited functionality implementation of sprintf() is provided in}}
\DoxyCodeLine{04330 \textcolor{comment}{         * many of the FreeRTOS/Demo sub-\/directories in a file called}}
\DoxyCodeLine{04331 \textcolor{comment}{         * printf-\/stdarg.c (note printf-\/stdarg.c does not provide a full}}
\DoxyCodeLine{04332 \textcolor{comment}{         * snprintf() implementation!).}}
\DoxyCodeLine{04333 \textcolor{comment}{         *}}
\DoxyCodeLine{04334 \textcolor{comment}{         * It is recommended that production systems call uxTaskGetSystemState()}}
\DoxyCodeLine{04335 \textcolor{comment}{         * directly to get access to raw stats data, rather than indirectly}}
\DoxyCodeLine{04336 \textcolor{comment}{         * through a call to vTaskList().}}
\DoxyCodeLine{04337 \textcolor{comment}{         */}}
\DoxyCodeLine{04338 }
\DoxyCodeLine{04339 }
\DoxyCodeLine{04340         \textcolor{comment}{/* Make sure the write buffer does not contain a string. */}}
\DoxyCodeLine{04341         *pcWriteBuffer = ( char ) 0x00;}
\DoxyCodeLine{04342 }
\DoxyCodeLine{04343         \textcolor{comment}{/* Take a snapshot of the number of tasks in case it changes while this}}
\DoxyCodeLine{04344 \textcolor{comment}{        function is executing. */}}
\DoxyCodeLine{04345         uxArraySize = uxCurrentNumberOfTasks;}
\DoxyCodeLine{04346 }
\DoxyCodeLine{04347         \textcolor{comment}{/* Allocate an array index for each task.  NOTE!  if}}
\DoxyCodeLine{04348 \textcolor{comment}{        configSUPPORT\_DYNAMIC\_ALLOCATION is set to 0 then pvPortMalloc() will}}
\DoxyCodeLine{04349 \textcolor{comment}{        equate to NULL. */}}
\DoxyCodeLine{04350         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * \textcolor{keyword}{sizeof}( TaskStatus\_t ) ); \textcolor{comment}{/*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */}}
\DoxyCodeLine{04351 }
\DoxyCodeLine{04352         \textcolor{keywordflow}{if}( pxTaskStatusArray != NULL )}
\DoxyCodeLine{04353         \{}
\DoxyCodeLine{04354             \textcolor{comment}{/* Generate the (binary) data. */}}
\DoxyCodeLine{04355             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );}
\DoxyCodeLine{04356 }
\DoxyCodeLine{04357             \textcolor{comment}{/* Create a human readable table from the binary data. */}}
\DoxyCodeLine{04358             \textcolor{keywordflow}{for}( x = 0; x < uxArraySize; x++ )}
\DoxyCodeLine{04359             \{}
\DoxyCodeLine{04360                 \textcolor{keywordflow}{switch}( pxTaskStatusArray[ x ].eCurrentState )}
\DoxyCodeLine{04361                 \{}
\DoxyCodeLine{04362                     \textcolor{keywordflow}{case} eRunning:      cStatus = tskRUNNING\_CHAR;}
\DoxyCodeLine{04363                                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{04364 }
\DoxyCodeLine{04365                     \textcolor{keywordflow}{case} eReady:        cStatus = tskREADY\_CHAR;}
\DoxyCodeLine{04366                                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{04367 }
\DoxyCodeLine{04368                     \textcolor{keywordflow}{case} eBlocked:      cStatus = tskBLOCKED\_CHAR;}
\DoxyCodeLine{04369                                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{04370 }
\DoxyCodeLine{04371                     \textcolor{keywordflow}{case} eSuspended:    cStatus = tskSUSPENDED\_CHAR;}
\DoxyCodeLine{04372                                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{04373 }
\DoxyCodeLine{04374                     \textcolor{keywordflow}{case} eDeleted:      cStatus = tskDELETED\_CHAR;}
\DoxyCodeLine{04375                                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{04376 }
\DoxyCodeLine{04377                     \textcolor{keywordflow}{case} eInvalid:      \textcolor{comment}{/* Fall through. */}}
\DoxyCodeLine{04378                     \textcolor{keywordflow}{default}:            \textcolor{comment}{/* Should not get here, but it is included}}
\DoxyCodeLine{04379 \textcolor{comment}{                                        to prevent static checking errors. */}}
\DoxyCodeLine{04380                                         cStatus = ( char ) 0x00;}
\DoxyCodeLine{04381                                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{04382                 \}}
\DoxyCodeLine{04383 }
\DoxyCodeLine{04384                 \textcolor{comment}{/* Write the task name to the string, padding with spaces so it}}
\DoxyCodeLine{04385 \textcolor{comment}{                can be printed in tabular form more easily. */}}
\DoxyCodeLine{04386                 pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );}
\DoxyCodeLine{04387 }
\DoxyCodeLine{04388                 \textcolor{comment}{/* Write the rest of the string. */}}
\DoxyCodeLine{04389                 sprintf( pcWriteBuffer, \textcolor{stringliteral}{"{}\(\backslash\)t\%c\(\backslash\)t\%u\(\backslash\)t\%u\(\backslash\)t\%u\(\backslash\)r\(\backslash\)n"{}}, cStatus, ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ) pxTaskStatusArray[ x ].uxCurrentPriority, ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ) pxTaskStatusArray[ x ].xTaskNumber ); \textcolor{comment}{/*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only -\/ not part of the core kernel implementation. */}}
\DoxyCodeLine{04390                 pcWriteBuffer += strlen( pcWriteBuffer ); \textcolor{comment}{/*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */}}
\DoxyCodeLine{04391             \}}
\DoxyCodeLine{04392 }
\DoxyCodeLine{04393             \textcolor{comment}{/* Free the array again.  NOTE!  If configSUPPORT\_DYNAMIC\_ALLOCATION}}
\DoxyCodeLine{04394 \textcolor{comment}{            is 0 then vPortFree() will be \#defined to nothing. */}}
\DoxyCodeLine{04395             vPortFree( pxTaskStatusArray );}
\DoxyCodeLine{04396         \}}
\DoxyCodeLine{04397         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04398         \{}
\DoxyCodeLine{04399             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04400         \}}
\DoxyCodeLine{04401     \}}
\DoxyCodeLine{04402 }
\DoxyCodeLine{04403 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( configUSE\_TRACE\_FACILITY == 1 ) \&\& ( configUSE\_STATS\_FORMATTING\_FUNCTIONS > 0 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04404 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04405 }
\DoxyCodeLine{04406 \textcolor{preprocessor}{\#if ( ( configGENERATE\_RUN\_TIME\_STATS == 1 ) \&\& ( configUSE\_STATS\_FORMATTING\_FUNCTIONS > 0 ) \&\& ( configSUPPORT\_DYNAMIC\_ALLOCATION == 1 ) )}}
\DoxyCodeLine{04407 }
\DoxyCodeLine{04408     \textcolor{keywordtype}{void} vTaskGetRunTimeStats( \textcolor{keywordtype}{char} *pcWriteBuffer )}
\DoxyCodeLine{04409     \{}
\DoxyCodeLine{04410     TaskStatus\_t *pxTaskStatusArray;}
\DoxyCodeLine{04411     UBaseType\_t uxArraySize, x;}
\DoxyCodeLine{04412     uint32\_t ulTotalTime, ulStatsAsPercentage;}
\DoxyCodeLine{04413 }
\DoxyCodeLine{04414 \textcolor{preprocessor}{        \#if( configUSE\_TRACE\_FACILITY != 1 )}}
\DoxyCodeLine{04415         \{}
\DoxyCodeLine{04416 \textcolor{preprocessor}{            \#error configUSE\_TRACE\_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().}}
\DoxyCodeLine{04417         \}}
\DoxyCodeLine{04418 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{04419 }
\DoxyCodeLine{04420         \textcolor{comment}{/*}}
\DoxyCodeLine{04421 \textcolor{comment}{         * PLEASE NOTE:}}
\DoxyCodeLine{04422 \textcolor{comment}{         *}}
\DoxyCodeLine{04423 \textcolor{comment}{         * This function is provided for convenience only, and is used by many}}
\DoxyCodeLine{04424 \textcolor{comment}{         * of the demo applications.  Do not consider it to be part of the}}
\DoxyCodeLine{04425 \textcolor{comment}{         * scheduler.}}
\DoxyCodeLine{04426 \textcolor{comment}{         *}}
\DoxyCodeLine{04427 \textcolor{comment}{         * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part}}
\DoxyCodeLine{04428 \textcolor{comment}{         * of the uxTaskGetSystemState() output into a human readable table that}}
\DoxyCodeLine{04429 \textcolor{comment}{         * displays the amount of time each task has spent in the Running state}}
\DoxyCodeLine{04430 \textcolor{comment}{         * in both absolute and percentage terms.}}
\DoxyCodeLine{04431 \textcolor{comment}{         *}}
\DoxyCodeLine{04432 \textcolor{comment}{         * vTaskGetRunTimeStats() has a dependency on the sprintf() C library}}
\DoxyCodeLine{04433 \textcolor{comment}{         * function that might bloat the code size, use a lot of stack, and}}
\DoxyCodeLine{04434 \textcolor{comment}{         * provide different results on different platforms.  An alternative,}}
\DoxyCodeLine{04435 \textcolor{comment}{         * tiny, third party, and limited functionality implementation of}}
\DoxyCodeLine{04436 \textcolor{comment}{         * sprintf() is provided in many of the FreeRTOS/Demo sub-\/directories in}}
\DoxyCodeLine{04437 \textcolor{comment}{         * a file called printf-\/stdarg.c (note printf-\/stdarg.c does not provide}}
\DoxyCodeLine{04438 \textcolor{comment}{         * a full snprintf() implementation!).}}
\DoxyCodeLine{04439 \textcolor{comment}{         *}}
\DoxyCodeLine{04440 \textcolor{comment}{         * It is recommended that production systems call uxTaskGetSystemState()}}
\DoxyCodeLine{04441 \textcolor{comment}{         * directly to get access to raw stats data, rather than indirectly}}
\DoxyCodeLine{04442 \textcolor{comment}{         * through a call to vTaskGetRunTimeStats().}}
\DoxyCodeLine{04443 \textcolor{comment}{         */}}
\DoxyCodeLine{04444 }
\DoxyCodeLine{04445         \textcolor{comment}{/* Make sure the write buffer does not contain a string. */}}
\DoxyCodeLine{04446         *pcWriteBuffer = ( char ) 0x00;}
\DoxyCodeLine{04447 }
\DoxyCodeLine{04448         \textcolor{comment}{/* Take a snapshot of the number of tasks in case it changes while this}}
\DoxyCodeLine{04449 \textcolor{comment}{        function is executing. */}}
\DoxyCodeLine{04450         uxArraySize = uxCurrentNumberOfTasks;}
\DoxyCodeLine{04451 }
\DoxyCodeLine{04452         \textcolor{comment}{/* Allocate an array index for each task.  NOTE!  If}}
\DoxyCodeLine{04453 \textcolor{comment}{        configSUPPORT\_DYNAMIC\_ALLOCATION is set to 0 then pvPortMalloc() will}}
\DoxyCodeLine{04454 \textcolor{comment}{        equate to NULL. */}}
\DoxyCodeLine{04455         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * \textcolor{keyword}{sizeof}( TaskStatus\_t ) ); \textcolor{comment}{/*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */}}
\DoxyCodeLine{04456 }
\DoxyCodeLine{04457         \textcolor{keywordflow}{if}( pxTaskStatusArray != NULL )}
\DoxyCodeLine{04458         \{}
\DoxyCodeLine{04459             \textcolor{comment}{/* Generate the (binary) data. */}}
\DoxyCodeLine{04460             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, \&ulTotalTime );}
\DoxyCodeLine{04461 }
\DoxyCodeLine{04462             \textcolor{comment}{/* For percentage calculations. */}}
\DoxyCodeLine{04463             ulTotalTime /= 100UL;}
\DoxyCodeLine{04464 }
\DoxyCodeLine{04465             \textcolor{comment}{/* Avoid divide by zero errors. */}}
\DoxyCodeLine{04466             \textcolor{keywordflow}{if}( ulTotalTime > 0UL )}
\DoxyCodeLine{04467             \{}
\DoxyCodeLine{04468                 \textcolor{comment}{/* Create a human readable table from the binary data. */}}
\DoxyCodeLine{04469                 \textcolor{keywordflow}{for}( x = 0; x < uxArraySize; x++ )}
\DoxyCodeLine{04470                 \{}
\DoxyCodeLine{04471                     \textcolor{comment}{/* What percentage of the total run time has the task used?}}
\DoxyCodeLine{04472 \textcolor{comment}{                    This will always be rounded down to the nearest integer.}}
\DoxyCodeLine{04473 \textcolor{comment}{                    ulTotalRunTimeDiv100 has already been divided by 100. */}}
\DoxyCodeLine{04474                     ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;}
\DoxyCodeLine{04475 }
\DoxyCodeLine{04476                     \textcolor{comment}{/* Write the task name to the string, padding with}}
\DoxyCodeLine{04477 \textcolor{comment}{                    spaces so it can be printed in tabular form more}}
\DoxyCodeLine{04478 \textcolor{comment}{                    easily. */}}
\DoxyCodeLine{04479                     pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );}
\DoxyCodeLine{04480 }
\DoxyCodeLine{04481                     \textcolor{keywordflow}{if}( ulStatsAsPercentage > 0UL )}
\DoxyCodeLine{04482                     \{}
\DoxyCodeLine{04483 \textcolor{preprocessor}{                        \#ifdef portLU\_PRINTF\_SPECIFIER\_REQUIRED}}
\DoxyCodeLine{04484                         \{}
\DoxyCodeLine{04485                             sprintf( pcWriteBuffer, \textcolor{stringliteral}{"{}\(\backslash\)t\%lu\(\backslash\)t\(\backslash\)t\%lu\%\%\(\backslash\)r\(\backslash\)n"{}}, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );}
\DoxyCodeLine{04486                         \}}
\DoxyCodeLine{04487 \textcolor{preprocessor}{                        \#else}}
\DoxyCodeLine{04488                         \{}
\DoxyCodeLine{04489                             \textcolor{comment}{/* sizeof( int ) == sizeof( long ) so a smaller}}
\DoxyCodeLine{04490 \textcolor{comment}{                            printf() library can be used. */}}
\DoxyCodeLine{04491                             sprintf( pcWriteBuffer, \textcolor{stringliteral}{"{}\(\backslash\)t\%u\(\backslash\)t\(\backslash\)t\%u\%\%\(\backslash\)r\(\backslash\)n"{}}, ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ) ulStatsAsPercentage ); \textcolor{comment}{/*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only -\/ not part of the core kernel implementation. */}}
\DoxyCodeLine{04492                         \}}
\DoxyCodeLine{04493 \textcolor{preprocessor}{                        \#endif}}
\DoxyCodeLine{04494                     \}}
\DoxyCodeLine{04495                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{04496                     \{}
\DoxyCodeLine{04497                         \textcolor{comment}{/* If the percentage is zero here then the task has}}
\DoxyCodeLine{04498 \textcolor{comment}{                        consumed less than 1\% of the total run time. */}}
\DoxyCodeLine{04499 \textcolor{preprocessor}{                        \#ifdef portLU\_PRINTF\_SPECIFIER\_REQUIRED}}
\DoxyCodeLine{04500                         \{}
\DoxyCodeLine{04501                             sprintf( pcWriteBuffer, \textcolor{stringliteral}{"{}\(\backslash\)t\%lu\(\backslash\)t\(\backslash\)t<1\%\%\(\backslash\)r\(\backslash\)n"{}}, pxTaskStatusArray[ x ].ulRunTimeCounter );}
\DoxyCodeLine{04502                         \}}
\DoxyCodeLine{04503 \textcolor{preprocessor}{                        \#else}}
\DoxyCodeLine{04504                         \{}
\DoxyCodeLine{04505                             \textcolor{comment}{/* sizeof( int ) == sizeof( long ) so a smaller}}
\DoxyCodeLine{04506 \textcolor{comment}{                            printf() library can be used. */}}
\DoxyCodeLine{04507                             sprintf( pcWriteBuffer, \textcolor{stringliteral}{"{}\(\backslash\)t\%u\(\backslash\)t\(\backslash\)t<1\%\%\(\backslash\)r\(\backslash\)n"{}}, ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ) pxTaskStatusArray[ x ].ulRunTimeCounter ); \textcolor{comment}{/*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only -\/ not part of the core kernel implementation. */}}
\DoxyCodeLine{04508                         \}}
\DoxyCodeLine{04509 \textcolor{preprocessor}{                        \#endif}}
\DoxyCodeLine{04510                     \}}
\DoxyCodeLine{04511 }
\DoxyCodeLine{04512                     pcWriteBuffer += strlen( pcWriteBuffer ); \textcolor{comment}{/*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */}}
\DoxyCodeLine{04513                 \}}
\DoxyCodeLine{04514             \}}
\DoxyCodeLine{04515             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04516             \{}
\DoxyCodeLine{04517                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04518             \}}
\DoxyCodeLine{04519 }
\DoxyCodeLine{04520             \textcolor{comment}{/* Free the array again.  NOTE!  If configSUPPORT\_DYNAMIC\_ALLOCATION}}
\DoxyCodeLine{04521 \textcolor{comment}{            is 0 then vPortFree() will be \#defined to nothing. */}}
\DoxyCodeLine{04522             vPortFree( pxTaskStatusArray );}
\DoxyCodeLine{04523         \}}
\DoxyCodeLine{04524         \textcolor{keywordflow}{else}}
\DoxyCodeLine{04525         \{}
\DoxyCodeLine{04526             mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04527         \}}
\DoxyCodeLine{04528     \}}
\DoxyCodeLine{04529 }
\DoxyCodeLine{04530 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ( ( configGENERATE\_RUN\_TIME\_STATS == 1 ) \&\& ( configUSE\_STATS\_FORMATTING\_FUNCTIONS > 0 ) \&\& ( configSUPPORT\_STATIC\_ALLOCATION == 1 ) ) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04531 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04532 }
\DoxyCodeLine{04533 TickType\_t uxTaskResetEventItemValue( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{04534 \{}
\DoxyCodeLine{04535 TickType\_t uxReturn;}
\DoxyCodeLine{04536 }
\DoxyCodeLine{04537     uxReturn = listGET\_LIST\_ITEM\_VALUE( \&( pxCurrentTCB-\/>xEventListItem ) );}
\DoxyCodeLine{04538 }
\DoxyCodeLine{04539     \textcolor{comment}{/* Reset the event list item to its normal value -\/ so it can be used with}}
\DoxyCodeLine{04540 \textcolor{comment}{    queues and semaphores. */}}
\DoxyCodeLine{04541     listSET\_LIST\_ITEM\_VALUE( \&( pxCurrentTCB-\/>xEventListItem ), ( ( TickType\_t ) configMAX\_PRIORITIES -\/ ( TickType\_t ) pxCurrentTCB-\/>uxPriority ) ); \textcolor{comment}{/*lint !e961 MISRA exception as the casts are only redundant for some ports. */}}
\DoxyCodeLine{04542 }
\DoxyCodeLine{04543     \textcolor{keywordflow}{return} uxReturn;}
\DoxyCodeLine{04544 \}}
\DoxyCodeLine{04545 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04546 }
\DoxyCodeLine{04547 \textcolor{preprocessor}{\#if ( configUSE\_MUTEXES == 1 )}}
\DoxyCodeLine{04548 }
\DoxyCodeLine{04549     TaskHandle\_t pvTaskIncrementMutexHeldCount( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{04550     \{}
\DoxyCodeLine{04551         \textcolor{comment}{/* If xSemaphoreCreateMutex() is called before any tasks have been created}}
\DoxyCodeLine{04552 \textcolor{comment}{        then pxCurrentTCB will be NULL. */}}
\DoxyCodeLine{04553         \textcolor{keywordflow}{if}( pxCurrentTCB != NULL )}
\DoxyCodeLine{04554         \{}
\DoxyCodeLine{04555             ( pxCurrentTCB-\/>uxMutexesHeld )++;}
\DoxyCodeLine{04556         \}}
\DoxyCodeLine{04557 }
\DoxyCodeLine{04558         \textcolor{keywordflow}{return} pxCurrentTCB;}
\DoxyCodeLine{04559     \}}
\DoxyCodeLine{04560 }
\DoxyCodeLine{04561 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_MUTEXES */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04562 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04563 }
\DoxyCodeLine{04564 \textcolor{preprocessor}{\#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{04565 }
\DoxyCodeLine{04566     uint32\_t ulTaskNotifyTake( BaseType\_t xClearCountOnExit, TickType\_t xTicksToWait )}
\DoxyCodeLine{04567     \{}
\DoxyCodeLine{04568     uint32\_t ulReturn;}
\DoxyCodeLine{04569 }
\DoxyCodeLine{04570         taskENTER\_CRITICAL();}
\DoxyCodeLine{04571         \{}
\DoxyCodeLine{04572             \textcolor{comment}{/* Only block if the notification count is not already non-\/zero. */}}
\DoxyCodeLine{04573             \textcolor{keywordflow}{if}( pxCurrentTCB-\/>ulNotifiedValue == 0UL )}
\DoxyCodeLine{04574             \{}
\DoxyCodeLine{04575                 \textcolor{comment}{/* Mark this task as waiting for a notification. */}}
\DoxyCodeLine{04576                 pxCurrentTCB-\/>ucNotifyState = taskWAITING\_NOTIFICATION;}
\DoxyCodeLine{04577 }
\DoxyCodeLine{04578                 \textcolor{keywordflow}{if}( xTicksToWait > ( TickType\_t ) 0 )}
\DoxyCodeLine{04579                 \{}
\DoxyCodeLine{04580                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );}
\DoxyCodeLine{04581                     traceTASK\_NOTIFY\_TAKE\_BLOCK();}
\DoxyCodeLine{04582 }
\DoxyCodeLine{04583                     \textcolor{comment}{/* All ports are written to allow a yield in a critical}}
\DoxyCodeLine{04584 \textcolor{comment}{                    section (some will yield immediately, others wait until the}}
\DoxyCodeLine{04585 \textcolor{comment}{                    critical section exits) -\/ but it is not something that}}
\DoxyCodeLine{04586 \textcolor{comment}{                    application code should ever do. */}}
\DoxyCodeLine{04587                     portYIELD\_WITHIN\_API();}
\DoxyCodeLine{04588                 \}}
\DoxyCodeLine{04589                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04590                 \{}
\DoxyCodeLine{04591                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04592                 \}}
\DoxyCodeLine{04593             \}}
\DoxyCodeLine{04594             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04595             \{}
\DoxyCodeLine{04596                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04597             \}}
\DoxyCodeLine{04598         \}}
\DoxyCodeLine{04599         taskEXIT\_CRITICAL();}
\DoxyCodeLine{04600 }
\DoxyCodeLine{04601         taskENTER\_CRITICAL();}
\DoxyCodeLine{04602         \{}
\DoxyCodeLine{04603             traceTASK\_NOTIFY\_TAKE();}
\DoxyCodeLine{04604             ulReturn = pxCurrentTCB-\/>ulNotifiedValue;}
\DoxyCodeLine{04605 }
\DoxyCodeLine{04606             \textcolor{keywordflow}{if}( ulReturn != 0UL )}
\DoxyCodeLine{04607             \{}
\DoxyCodeLine{04608                 \textcolor{keywordflow}{if}( xClearCountOnExit != pdFALSE )}
\DoxyCodeLine{04609                 \{}
\DoxyCodeLine{04610                     pxCurrentTCB-\/>ulNotifiedValue = 0UL;}
\DoxyCodeLine{04611                 \}}
\DoxyCodeLine{04612                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04613                 \{}
\DoxyCodeLine{04614                     pxCurrentTCB-\/>ulNotifiedValue = ulReturn -\/ ( uint32\_t ) 1;}
\DoxyCodeLine{04615                 \}}
\DoxyCodeLine{04616             \}}
\DoxyCodeLine{04617             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04618             \{}
\DoxyCodeLine{04619                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04620             \}}
\DoxyCodeLine{04621 }
\DoxyCodeLine{04622             pxCurrentTCB-\/>ucNotifyState = taskNOT\_WAITING\_NOTIFICATION;}
\DoxyCodeLine{04623         \}}
\DoxyCodeLine{04624         taskEXIT\_CRITICAL();}
\DoxyCodeLine{04625 }
\DoxyCodeLine{04626         \textcolor{keywordflow}{return} ulReturn;}
\DoxyCodeLine{04627     \}}
\DoxyCodeLine{04628 }
\DoxyCodeLine{04629 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TASK\_NOTIFICATIONS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04630 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04631 }
\DoxyCodeLine{04632 \textcolor{preprocessor}{\#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{04633 }
\DoxyCodeLine{04634     BaseType\_t xTaskNotifyWait( uint32\_t ulBitsToClearOnEntry, uint32\_t ulBitsToClearOnExit, uint32\_t *pulNotificationValue, TickType\_t xTicksToWait )}
\DoxyCodeLine{04635     \{}
\DoxyCodeLine{04636     BaseType\_t xReturn;}
\DoxyCodeLine{04637 }
\DoxyCodeLine{04638         taskENTER\_CRITICAL();}
\DoxyCodeLine{04639         \{}
\DoxyCodeLine{04640             \textcolor{comment}{/* Only block if a notification is not already pending. */}}
\DoxyCodeLine{04641             \textcolor{keywordflow}{if}( pxCurrentTCB-\/>ucNotifyState != taskNOTIFICATION\_RECEIVED )}
\DoxyCodeLine{04642             \{}
\DoxyCodeLine{04643                 \textcolor{comment}{/* Clear bits in the task's notification value as bits may get}}
\DoxyCodeLine{04644 \textcolor{comment}{                set by the notifying task or interrupt.  This can be used to}}
\DoxyCodeLine{04645 \textcolor{comment}{                clear the value to zero. */}}
\DoxyCodeLine{04646                 pxCurrentTCB-\/>ulNotifiedValue \&= \string~ulBitsToClearOnEntry;}
\DoxyCodeLine{04647 }
\DoxyCodeLine{04648                 \textcolor{comment}{/* Mark this task as waiting for a notification. */}}
\DoxyCodeLine{04649                 pxCurrentTCB-\/>ucNotifyState = taskWAITING\_NOTIFICATION;}
\DoxyCodeLine{04650 }
\DoxyCodeLine{04651                 \textcolor{keywordflow}{if}( xTicksToWait > ( TickType\_t ) 0 )}
\DoxyCodeLine{04652                 \{}
\DoxyCodeLine{04653                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );}
\DoxyCodeLine{04654                     traceTASK\_NOTIFY\_WAIT\_BLOCK();}
\DoxyCodeLine{04655 }
\DoxyCodeLine{04656                     \textcolor{comment}{/* All ports are written to allow a yield in a critical}}
\DoxyCodeLine{04657 \textcolor{comment}{                    section (some will yield immediately, others wait until the}}
\DoxyCodeLine{04658 \textcolor{comment}{                    critical section exits) -\/ but it is not something that}}
\DoxyCodeLine{04659 \textcolor{comment}{                    application code should ever do. */}}
\DoxyCodeLine{04660                     portYIELD\_WITHIN\_API();}
\DoxyCodeLine{04661                 \}}
\DoxyCodeLine{04662                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04663                 \{}
\DoxyCodeLine{04664                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04665                 \}}
\DoxyCodeLine{04666             \}}
\DoxyCodeLine{04667             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04668             \{}
\DoxyCodeLine{04669                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04670             \}}
\DoxyCodeLine{04671         \}}
\DoxyCodeLine{04672         taskEXIT\_CRITICAL();}
\DoxyCodeLine{04673 }
\DoxyCodeLine{04674         taskENTER\_CRITICAL();}
\DoxyCodeLine{04675         \{}
\DoxyCodeLine{04676             traceTASK\_NOTIFY\_WAIT();}
\DoxyCodeLine{04677 }
\DoxyCodeLine{04678             \textcolor{keywordflow}{if}( pulNotificationValue != NULL )}
\DoxyCodeLine{04679             \{}
\DoxyCodeLine{04680                 \textcolor{comment}{/* Output the current notification value, which may or may not}}
\DoxyCodeLine{04681 \textcolor{comment}{                have changed. */}}
\DoxyCodeLine{04682                 *pulNotificationValue = pxCurrentTCB-\/>ulNotifiedValue;}
\DoxyCodeLine{04683             \}}
\DoxyCodeLine{04684 }
\DoxyCodeLine{04685             \textcolor{comment}{/* If ucNotifyValue is set then either the task never entered the}}
\DoxyCodeLine{04686 \textcolor{comment}{            blocked state (because a notification was already pending) or the}}
\DoxyCodeLine{04687 \textcolor{comment}{            task unblocked because of a notification.  Otherwise the task}}
\DoxyCodeLine{04688 \textcolor{comment}{            unblocked because of a timeout. */}}
\DoxyCodeLine{04689             \textcolor{keywordflow}{if}( pxCurrentTCB-\/>ucNotifyState != taskNOTIFICATION\_RECEIVED )}
\DoxyCodeLine{04690             \{}
\DoxyCodeLine{04691                 \textcolor{comment}{/* A notification was not received. */}}
\DoxyCodeLine{04692                 xReturn = pdFALSE;}
\DoxyCodeLine{04693             \}}
\DoxyCodeLine{04694             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04695             \{}
\DoxyCodeLine{04696                 \textcolor{comment}{/* A notification was already pending or a notification was}}
\DoxyCodeLine{04697 \textcolor{comment}{                received while the task was waiting. */}}
\DoxyCodeLine{04698                 pxCurrentTCB-\/>ulNotifiedValue \&= \string~ulBitsToClearOnExit;}
\DoxyCodeLine{04699                 xReturn = pdTRUE;}
\DoxyCodeLine{04700             \}}
\DoxyCodeLine{04701 }
\DoxyCodeLine{04702             pxCurrentTCB-\/>ucNotifyState = taskNOT\_WAITING\_NOTIFICATION;}
\DoxyCodeLine{04703         \}}
\DoxyCodeLine{04704         taskEXIT\_CRITICAL();}
\DoxyCodeLine{04705 }
\DoxyCodeLine{04706         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{04707     \}}
\DoxyCodeLine{04708 }
\DoxyCodeLine{04709 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TASK\_NOTIFICATIONS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04710 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04711 }
\DoxyCodeLine{04712 \textcolor{preprocessor}{\#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{04713 }
\DoxyCodeLine{04714     BaseType\_t xTaskGenericNotify( TaskHandle\_t xTaskToNotify, uint32\_t ulValue, eNotifyAction eAction, uint32\_t *pulPreviousNotificationValue )}
\DoxyCodeLine{04715     \{}
\DoxyCodeLine{04716     TCB\_t * pxTCB;}
\DoxyCodeLine{04717     BaseType\_t xReturn = pdPASS;}
\DoxyCodeLine{04718     uint8\_t ucOriginalNotifyState;}
\DoxyCodeLine{04719 }
\DoxyCodeLine{04720         configASSERT( xTaskToNotify );}
\DoxyCodeLine{04721         pxTCB = xTaskToNotify;}
\DoxyCodeLine{04722 }
\DoxyCodeLine{04723         taskENTER\_CRITICAL();}
\DoxyCodeLine{04724         \{}
\DoxyCodeLine{04725             \textcolor{keywordflow}{if}( pulPreviousNotificationValue != NULL )}
\DoxyCodeLine{04726             \{}
\DoxyCodeLine{04727                 *pulPreviousNotificationValue = pxTCB-\/>ulNotifiedValue;}
\DoxyCodeLine{04728             \}}
\DoxyCodeLine{04729 }
\DoxyCodeLine{04730             ucOriginalNotifyState = pxTCB-\/>ucNotifyState;}
\DoxyCodeLine{04731 }
\DoxyCodeLine{04732             pxTCB-\/>ucNotifyState = taskNOTIFICATION\_RECEIVED;}
\DoxyCodeLine{04733 }
\DoxyCodeLine{04734             \textcolor{keywordflow}{switch}( eAction )}
\DoxyCodeLine{04735             \{}
\DoxyCodeLine{04736                 \textcolor{keywordflow}{case} eSetBits   :}
\DoxyCodeLine{04737                     pxTCB-\/>ulNotifiedValue |= ulValue;}
\DoxyCodeLine{04738                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04739 }
\DoxyCodeLine{04740                 \textcolor{keywordflow}{case} eIncrement :}
\DoxyCodeLine{04741                     ( pxTCB-\/>ulNotifiedValue )++;}
\DoxyCodeLine{04742                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04743 }
\DoxyCodeLine{04744                 \textcolor{keywordflow}{case} eSetValueWithOverwrite :}
\DoxyCodeLine{04745                     pxTCB-\/>ulNotifiedValue = ulValue;}
\DoxyCodeLine{04746                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04747 }
\DoxyCodeLine{04748                 \textcolor{keywordflow}{case} eSetValueWithoutOverwrite :}
\DoxyCodeLine{04749                     \textcolor{keywordflow}{if}( ucOriginalNotifyState != taskNOTIFICATION\_RECEIVED )}
\DoxyCodeLine{04750                     \{}
\DoxyCodeLine{04751                         pxTCB-\/>ulNotifiedValue = ulValue;}
\DoxyCodeLine{04752                     \}}
\DoxyCodeLine{04753                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{04754                     \{}
\DoxyCodeLine{04755                         \textcolor{comment}{/* The value could not be written to the task. */}}
\DoxyCodeLine{04756                         xReturn = pdFAIL;}
\DoxyCodeLine{04757                     \}}
\DoxyCodeLine{04758                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04759 }
\DoxyCodeLine{04760                 \textcolor{keywordflow}{case} eNoAction:}
\DoxyCodeLine{04761                     \textcolor{comment}{/* The task is being notified without its notify value being}}
\DoxyCodeLine{04762 \textcolor{comment}{                    updated. */}}
\DoxyCodeLine{04763                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04764 }
\DoxyCodeLine{04765                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{04766                     \textcolor{comment}{/* Should not get here if all enums are handled.}}
\DoxyCodeLine{04767 \textcolor{comment}{                    Artificially force an assert by testing a value the}}
\DoxyCodeLine{04768 \textcolor{comment}{                    compiler can't assume is const. */}}
\DoxyCodeLine{04769                     configASSERT( pxTCB-\/>ulNotifiedValue == \string~0UL );}
\DoxyCodeLine{04770 }
\DoxyCodeLine{04771                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04772             \}}
\DoxyCodeLine{04773 }
\DoxyCodeLine{04774             traceTASK\_NOTIFY();}
\DoxyCodeLine{04775 }
\DoxyCodeLine{04776             \textcolor{comment}{/* If the task is in the blocked state specifically to wait for a}}
\DoxyCodeLine{04777 \textcolor{comment}{            notification then unblock it now. */}}
\DoxyCodeLine{04778             \textcolor{keywordflow}{if}( ucOriginalNotifyState == taskWAITING\_NOTIFICATION )}
\DoxyCodeLine{04779             \{}
\DoxyCodeLine{04780                 ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{04781                 prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{04782 }
\DoxyCodeLine{04783                 \textcolor{comment}{/* The task should not have been on an event list. */}}
\DoxyCodeLine{04784                 configASSERT( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) == NULL );}
\DoxyCodeLine{04785 }
\DoxyCodeLine{04786 \textcolor{preprocessor}{                \#if( configUSE\_TICKLESS\_IDLE != 0 )}}
\DoxyCodeLine{04787                 \{}
\DoxyCodeLine{04788                     \textcolor{comment}{/* If a task is blocked waiting for a notification then}}
\DoxyCodeLine{04789 \textcolor{comment}{                    xNextTaskUnblockTime might be set to the blocked task's time}}
\DoxyCodeLine{04790 \textcolor{comment}{                    out time.  If the task is unblocked for a reason other than}}
\DoxyCodeLine{04791 \textcolor{comment}{                    a timeout xNextTaskUnblockTime is normally left unchanged,}}
\DoxyCodeLine{04792 \textcolor{comment}{                    because it will automatically get reset to a new value when}}
\DoxyCodeLine{04793 \textcolor{comment}{                    the tick count equals xNextTaskUnblockTime.  However if}}
\DoxyCodeLine{04794 \textcolor{comment}{                    tickless idling is used it might be more important to enter}}
\DoxyCodeLine{04795 \textcolor{comment}{                    sleep mode at the earliest possible time -\/ so reset}}
\DoxyCodeLine{04796 \textcolor{comment}{                    xNextTaskUnblockTime here to ensure it is updated at the}}
\DoxyCodeLine{04797 \textcolor{comment}{                    earliest possible time. */}}
\DoxyCodeLine{04798                     prvResetNextTaskUnblockTime();}
\DoxyCodeLine{04799                 \}}
\DoxyCodeLine{04800 \textcolor{preprocessor}{                \#endif}}
\DoxyCodeLine{04801 }
\DoxyCodeLine{04802                 \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority > pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{04803                 \{}
\DoxyCodeLine{04804                     \textcolor{comment}{/* The notified task has a priority above the currently}}
\DoxyCodeLine{04805 \textcolor{comment}{                    executing task so a yield is required. */}}
\DoxyCodeLine{04806                     taskYIELD\_IF\_USING\_PREEMPTION();}
\DoxyCodeLine{04807                 \}}
\DoxyCodeLine{04808                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04809                 \{}
\DoxyCodeLine{04810                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04811                 \}}
\DoxyCodeLine{04812             \}}
\DoxyCodeLine{04813             \textcolor{keywordflow}{else}}
\DoxyCodeLine{04814             \{}
\DoxyCodeLine{04815                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04816             \}}
\DoxyCodeLine{04817         \}}
\DoxyCodeLine{04818         taskEXIT\_CRITICAL();}
\DoxyCodeLine{04819 }
\DoxyCodeLine{04820         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{04821     \}}
\DoxyCodeLine{04822 }
\DoxyCodeLine{04823 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TASK\_NOTIFICATIONS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04824 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04825 }
\DoxyCodeLine{04826 \textcolor{preprocessor}{\#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{04827 }
\DoxyCodeLine{04828     BaseType\_t xTaskGenericNotifyFromISR( TaskHandle\_t xTaskToNotify, uint32\_t ulValue, eNotifyAction eAction, uint32\_t *pulPreviousNotificationValue, BaseType\_t *pxHigherPriorityTaskWoken )}
\DoxyCodeLine{04829     \{}
\DoxyCodeLine{04830     TCB\_t * pxTCB;}
\DoxyCodeLine{04831     uint8\_t ucOriginalNotifyState;}
\DoxyCodeLine{04832     BaseType\_t xReturn = pdPASS;}
\DoxyCodeLine{04833     UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{04834 }
\DoxyCodeLine{04835         configASSERT( xTaskToNotify );}
\DoxyCodeLine{04836 }
\DoxyCodeLine{04837         \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a}}
\DoxyCodeLine{04838 \textcolor{comment}{        maximum system call (or maximum API call) interrupt priority.}}
\DoxyCodeLine{04839 \textcolor{comment}{        Interrupts that are above the maximum system call priority are keep}}
\DoxyCodeLine{04840 \textcolor{comment}{        permanently enabled, even when the RTOS kernel is in a critical section,}}
\DoxyCodeLine{04841 \textcolor{comment}{        but cannot make any calls to FreeRTOS API functions.  If configASSERT()}}
\DoxyCodeLine{04842 \textcolor{comment}{        is defined in FreeRTOSConfig.h then}}
\DoxyCodeLine{04843 \textcolor{comment}{        portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{04844 \textcolor{comment}{        failure if a FreeRTOS API function is called from an interrupt that has}}
\DoxyCodeLine{04845 \textcolor{comment}{        been assigned a priority above the configured maximum system call}}
\DoxyCodeLine{04846 \textcolor{comment}{        priority.  Only FreeRTOS functions that end in FromISR can be called}}
\DoxyCodeLine{04847 \textcolor{comment}{        from interrupts that have been assigned a priority at or (logically)}}
\DoxyCodeLine{04848 \textcolor{comment}{        below the maximum system call interrupt priority.  FreeRTOS maintains a}}
\DoxyCodeLine{04849 \textcolor{comment}{        separate interrupt safe API to ensure interrupt entry is as fast and as}}
\DoxyCodeLine{04850 \textcolor{comment}{        simple as possible.  More information (albeit Cortex-\/M specific) is}}
\DoxyCodeLine{04851 \textcolor{comment}{        provided on the following link:}}
\DoxyCodeLine{04852 \textcolor{comment}{        http://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{04853         portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{04854 }
\DoxyCodeLine{04855         pxTCB = xTaskToNotify;}
\DoxyCodeLine{04856 }
\DoxyCodeLine{04857         uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{04858         \{}
\DoxyCodeLine{04859             \textcolor{keywordflow}{if}( pulPreviousNotificationValue != NULL )}
\DoxyCodeLine{04860             \{}
\DoxyCodeLine{04861                 *pulPreviousNotificationValue = pxTCB-\/>ulNotifiedValue;}
\DoxyCodeLine{04862             \}}
\DoxyCodeLine{04863 }
\DoxyCodeLine{04864             ucOriginalNotifyState = pxTCB-\/>ucNotifyState;}
\DoxyCodeLine{04865             pxTCB-\/>ucNotifyState = taskNOTIFICATION\_RECEIVED;}
\DoxyCodeLine{04866 }
\DoxyCodeLine{04867             \textcolor{keywordflow}{switch}( eAction )}
\DoxyCodeLine{04868             \{}
\DoxyCodeLine{04869                 \textcolor{keywordflow}{case} eSetBits   :}
\DoxyCodeLine{04870                     pxTCB-\/>ulNotifiedValue |= ulValue;}
\DoxyCodeLine{04871                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04872 }
\DoxyCodeLine{04873                 \textcolor{keywordflow}{case} eIncrement :}
\DoxyCodeLine{04874                     ( pxTCB-\/>ulNotifiedValue )++;}
\DoxyCodeLine{04875                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04876 }
\DoxyCodeLine{04877                 \textcolor{keywordflow}{case} eSetValueWithOverwrite :}
\DoxyCodeLine{04878                     pxTCB-\/>ulNotifiedValue = ulValue;}
\DoxyCodeLine{04879                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04880 }
\DoxyCodeLine{04881                 \textcolor{keywordflow}{case} eSetValueWithoutOverwrite :}
\DoxyCodeLine{04882                     \textcolor{keywordflow}{if}( ucOriginalNotifyState != taskNOTIFICATION\_RECEIVED )}
\DoxyCodeLine{04883                     \{}
\DoxyCodeLine{04884                         pxTCB-\/>ulNotifiedValue = ulValue;}
\DoxyCodeLine{04885                     \}}
\DoxyCodeLine{04886                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{04887                     \{}
\DoxyCodeLine{04888                         \textcolor{comment}{/* The value could not be written to the task. */}}
\DoxyCodeLine{04889                         xReturn = pdFAIL;}
\DoxyCodeLine{04890                     \}}
\DoxyCodeLine{04891                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04892 }
\DoxyCodeLine{04893                 \textcolor{keywordflow}{case} eNoAction :}
\DoxyCodeLine{04894                     \textcolor{comment}{/* The task is being notified without its notify value being}}
\DoxyCodeLine{04895 \textcolor{comment}{                    updated. */}}
\DoxyCodeLine{04896                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04897 }
\DoxyCodeLine{04898                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{04899                     \textcolor{comment}{/* Should not get here if all enums are handled.}}
\DoxyCodeLine{04900 \textcolor{comment}{                    Artificially force an assert by testing a value the}}
\DoxyCodeLine{04901 \textcolor{comment}{                    compiler can't assume is const. */}}
\DoxyCodeLine{04902                     configASSERT( pxTCB-\/>ulNotifiedValue == \string~0UL );}
\DoxyCodeLine{04903                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{04904             \}}
\DoxyCodeLine{04905 }
\DoxyCodeLine{04906             traceTASK\_NOTIFY\_FROM\_ISR();}
\DoxyCodeLine{04907 }
\DoxyCodeLine{04908             \textcolor{comment}{/* If the task is in the blocked state specifically to wait for a}}
\DoxyCodeLine{04909 \textcolor{comment}{            notification then unblock it now. */}}
\DoxyCodeLine{04910             \textcolor{keywordflow}{if}( ucOriginalNotifyState == taskWAITING\_NOTIFICATION )}
\DoxyCodeLine{04911             \{}
\DoxyCodeLine{04912                 \textcolor{comment}{/* The task should not have been on an event list. */}}
\DoxyCodeLine{04913                 configASSERT( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) == NULL );}
\DoxyCodeLine{04914 }
\DoxyCodeLine{04915                 \textcolor{keywordflow}{if}( uxSchedulerSuspended == ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{04916                 \{}
\DoxyCodeLine{04917                     ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{04918                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{04919                 \}}
\DoxyCodeLine{04920                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04921                 \{}
\DoxyCodeLine{04922                     \textcolor{comment}{/* The delayed and ready lists cannot be accessed, so hold}}
\DoxyCodeLine{04923 \textcolor{comment}{                    this task pending until the scheduler is resumed. */}}
\DoxyCodeLine{04924                     vListInsertEnd( \&( xPendingReadyList ), \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{04925                 \}}
\DoxyCodeLine{04926 }
\DoxyCodeLine{04927                 \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority > pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{04928                 \{}
\DoxyCodeLine{04929                     \textcolor{comment}{/* The notified task has a priority above the currently}}
\DoxyCodeLine{04930 \textcolor{comment}{                    executing task so a yield is required. */}}
\DoxyCodeLine{04931                     \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{04932                     \{}
\DoxyCodeLine{04933                         *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{04934                     \}}
\DoxyCodeLine{04935 }
\DoxyCodeLine{04936                     \textcolor{comment}{/* Mark that a yield is pending in case the user is not}}
\DoxyCodeLine{04937 \textcolor{comment}{                    using the "{}xHigherPriorityTaskWoken"{} parameter to an ISR}}
\DoxyCodeLine{04938 \textcolor{comment}{                    safe FreeRTOS function. */}}
\DoxyCodeLine{04939                     xYieldPending = pdTRUE;}
\DoxyCodeLine{04940                 \}}
\DoxyCodeLine{04941                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04942                 \{}
\DoxyCodeLine{04943                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{04944                 \}}
\DoxyCodeLine{04945             \}}
\DoxyCodeLine{04946         \}}
\DoxyCodeLine{04947         portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{04948 }
\DoxyCodeLine{04949         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{04950     \}}
\DoxyCodeLine{04951 }
\DoxyCodeLine{04952 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TASK\_NOTIFICATIONS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{04953 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{04954 }
\DoxyCodeLine{04955 \textcolor{preprocessor}{\#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{04956 }
\DoxyCodeLine{04957     \textcolor{keywordtype}{void} vTaskNotifyGiveFromISR( TaskHandle\_t xTaskToNotify, BaseType\_t *pxHigherPriorityTaskWoken )}
\DoxyCodeLine{04958     \{}
\DoxyCodeLine{04959     TCB\_t * pxTCB;}
\DoxyCodeLine{04960     uint8\_t ucOriginalNotifyState;}
\DoxyCodeLine{04961     UBaseType\_t uxSavedInterruptStatus;}
\DoxyCodeLine{04962 }
\DoxyCodeLine{04963         configASSERT( xTaskToNotify );}
\DoxyCodeLine{04964 }
\DoxyCodeLine{04965         \textcolor{comment}{/* RTOS ports that support interrupt nesting have the concept of a}}
\DoxyCodeLine{04966 \textcolor{comment}{        maximum system call (or maximum API call) interrupt priority.}}
\DoxyCodeLine{04967 \textcolor{comment}{        Interrupts that are above the maximum system call priority are keep}}
\DoxyCodeLine{04968 \textcolor{comment}{        permanently enabled, even when the RTOS kernel is in a critical section,}}
\DoxyCodeLine{04969 \textcolor{comment}{        but cannot make any calls to FreeRTOS API functions.  If configASSERT()}}
\DoxyCodeLine{04970 \textcolor{comment}{        is defined in FreeRTOSConfig.h then}}
\DoxyCodeLine{04971 \textcolor{comment}{        portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID() will result in an assertion}}
\DoxyCodeLine{04972 \textcolor{comment}{        failure if a FreeRTOS API function is called from an interrupt that has}}
\DoxyCodeLine{04973 \textcolor{comment}{        been assigned a priority above the configured maximum system call}}
\DoxyCodeLine{04974 \textcolor{comment}{        priority.  Only FreeRTOS functions that end in FromISR can be called}}
\DoxyCodeLine{04975 \textcolor{comment}{        from interrupts that have been assigned a priority at or (logically)}}
\DoxyCodeLine{04976 \textcolor{comment}{        below the maximum system call interrupt priority.  FreeRTOS maintains a}}
\DoxyCodeLine{04977 \textcolor{comment}{        separate interrupt safe API to ensure interrupt entry is as fast and as}}
\DoxyCodeLine{04978 \textcolor{comment}{        simple as possible.  More information (albeit Cortex-\/M specific) is}}
\DoxyCodeLine{04979 \textcolor{comment}{        provided on the following link:}}
\DoxyCodeLine{04980 \textcolor{comment}{        http://www.freertos.org/RTOS-\/Cortex-\/M3-\/M4.html */}}
\DoxyCodeLine{04981         portASSERT\_IF\_INTERRUPT\_PRIORITY\_INVALID();}
\DoxyCodeLine{04982 }
\DoxyCodeLine{04983         pxTCB = xTaskToNotify;}
\DoxyCodeLine{04984 }
\DoxyCodeLine{04985         uxSavedInterruptStatus = portSET\_INTERRUPT\_MASK\_FROM\_ISR();}
\DoxyCodeLine{04986         \{}
\DoxyCodeLine{04987             ucOriginalNotifyState = pxTCB-\/>ucNotifyState;}
\DoxyCodeLine{04988             pxTCB-\/>ucNotifyState = taskNOTIFICATION\_RECEIVED;}
\DoxyCodeLine{04989 }
\DoxyCodeLine{04990             \textcolor{comment}{/* 'Giving' is equivalent to incrementing a count in a counting}}
\DoxyCodeLine{04991 \textcolor{comment}{            semaphore. */}}
\DoxyCodeLine{04992             ( pxTCB-\/>ulNotifiedValue )++;}
\DoxyCodeLine{04993 }
\DoxyCodeLine{04994             traceTASK\_NOTIFY\_GIVE\_FROM\_ISR();}
\DoxyCodeLine{04995 }
\DoxyCodeLine{04996             \textcolor{comment}{/* If the task is in the blocked state specifically to wait for a}}
\DoxyCodeLine{04997 \textcolor{comment}{            notification then unblock it now. */}}
\DoxyCodeLine{04998             \textcolor{keywordflow}{if}( ucOriginalNotifyState == taskWAITING\_NOTIFICATION )}
\DoxyCodeLine{04999             \{}
\DoxyCodeLine{05000                 \textcolor{comment}{/* The task should not have been on an event list. */}}
\DoxyCodeLine{05001                 configASSERT( listLIST\_ITEM\_CONTAINER( \&( pxTCB-\/>xEventListItem ) ) == NULL );}
\DoxyCodeLine{05002 }
\DoxyCodeLine{05003                 \textcolor{keywordflow}{if}( uxSchedulerSuspended == ( UBaseType\_t ) pdFALSE )}
\DoxyCodeLine{05004                 \{}
\DoxyCodeLine{05005                     ( void ) uxListRemove( \&( pxTCB-\/>xStateListItem ) );}
\DoxyCodeLine{05006                     prvAddTaskToReadyList( pxTCB );}
\DoxyCodeLine{05007                 \}}
\DoxyCodeLine{05008                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{05009                 \{}
\DoxyCodeLine{05010                     \textcolor{comment}{/* The delayed and ready lists cannot be accessed, so hold}}
\DoxyCodeLine{05011 \textcolor{comment}{                    this task pending until the scheduler is resumed. */}}
\DoxyCodeLine{05012                     vListInsertEnd( \&( xPendingReadyList ), \&( pxTCB-\/>xEventListItem ) );}
\DoxyCodeLine{05013                 \}}
\DoxyCodeLine{05014 }
\DoxyCodeLine{05015                 \textcolor{keywordflow}{if}( pxTCB-\/>uxPriority > pxCurrentTCB-\/>uxPriority )}
\DoxyCodeLine{05016                 \{}
\DoxyCodeLine{05017                     \textcolor{comment}{/* The notified task has a priority above the currently}}
\DoxyCodeLine{05018 \textcolor{comment}{                    executing task so a yield is required. */}}
\DoxyCodeLine{05019                     \textcolor{keywordflow}{if}( pxHigherPriorityTaskWoken != NULL )}
\DoxyCodeLine{05020                     \{}
\DoxyCodeLine{05021                         *pxHigherPriorityTaskWoken = pdTRUE;}
\DoxyCodeLine{05022                     \}}
\DoxyCodeLine{05023 }
\DoxyCodeLine{05024                     \textcolor{comment}{/* Mark that a yield is pending in case the user is not}}
\DoxyCodeLine{05025 \textcolor{comment}{                    using the "{}xHigherPriorityTaskWoken"{} parameter in an ISR}}
\DoxyCodeLine{05026 \textcolor{comment}{                    safe FreeRTOS function. */}}
\DoxyCodeLine{05027                     xYieldPending = pdTRUE;}
\DoxyCodeLine{05028                 \}}
\DoxyCodeLine{05029                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{05030                 \{}
\DoxyCodeLine{05031                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{05032                 \}}
\DoxyCodeLine{05033             \}}
\DoxyCodeLine{05034         \}}
\DoxyCodeLine{05035         portCLEAR\_INTERRUPT\_MASK\_FROM\_ISR( uxSavedInterruptStatus );}
\DoxyCodeLine{05036     \}}
\DoxyCodeLine{05037 }
\DoxyCodeLine{05038 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TASK\_NOTIFICATIONS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{05039 }
\DoxyCodeLine{05040 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{05041 }
\DoxyCodeLine{05042 \textcolor{preprocessor}{\#if( configUSE\_TASK\_NOTIFICATIONS == 1 )}}
\DoxyCodeLine{05043 }
\DoxyCodeLine{05044     BaseType\_t xTaskNotifyStateClear( TaskHandle\_t xTask )}
\DoxyCodeLine{05045     \{}
\DoxyCodeLine{05046     TCB\_t *pxTCB;}
\DoxyCodeLine{05047     BaseType\_t xReturn;}
\DoxyCodeLine{05048 }
\DoxyCodeLine{05049         \textcolor{comment}{/* If null is passed in here then it is the calling task that is having}}
\DoxyCodeLine{05050 \textcolor{comment}{        its notification state cleared. */}}
\DoxyCodeLine{05051         pxTCB = prvGetTCBFromHandle( xTask );}
\DoxyCodeLine{05052 }
\DoxyCodeLine{05053         taskENTER\_CRITICAL();}
\DoxyCodeLine{05054         \{}
\DoxyCodeLine{05055             \textcolor{keywordflow}{if}( pxTCB-\/>ucNotifyState == taskNOTIFICATION\_RECEIVED )}
\DoxyCodeLine{05056             \{}
\DoxyCodeLine{05057                 pxTCB-\/>ucNotifyState = taskNOT\_WAITING\_NOTIFICATION;}
\DoxyCodeLine{05058                 xReturn = pdPASS;}
\DoxyCodeLine{05059             \}}
\DoxyCodeLine{05060             \textcolor{keywordflow}{else}}
\DoxyCodeLine{05061             \{}
\DoxyCodeLine{05062                 xReturn = pdFAIL;}
\DoxyCodeLine{05063             \}}
\DoxyCodeLine{05064         \}}
\DoxyCodeLine{05065         taskEXIT\_CRITICAL();}
\DoxyCodeLine{05066 }
\DoxyCodeLine{05067         \textcolor{keywordflow}{return} xReturn;}
\DoxyCodeLine{05068     \}}
\DoxyCodeLine{05069 }
\DoxyCodeLine{05070 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* configUSE\_TASK\_NOTIFICATIONS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{05071 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{05072 }
\DoxyCodeLine{05073 \textcolor{preprocessor}{\#if( ( configGENERATE\_RUN\_TIME\_STATS == 1 ) \&\& ( INCLUDE\_xTaskGetIdleTaskHandle == 1 ) )}}
\DoxyCodeLine{05074     TickType\_t xTaskGetIdleRunTimeCounter( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{05075     \{}
\DoxyCodeLine{05076         \textcolor{keywordflow}{return} xIdleTaskHandle-\/>ulRunTimeCounter;}
\DoxyCodeLine{05077     \}}
\DoxyCodeLine{05078 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05079 \textcolor{comment}{/*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{05080 }
\DoxyCodeLine{05081 \textcolor{keyword}{static} \textcolor{keywordtype}{void} prvAddCurrentTaskToDelayedList( TickType\_t xTicksToWait, \textcolor{keyword}{const} BaseType\_t xCanBlockIndefinitely )}
\DoxyCodeLine{05082 \{}
\DoxyCodeLine{05083 TickType\_t xTimeToWake;}
\DoxyCodeLine{05084 \textcolor{keyword}{const} TickType\_t xConstTickCount = xTickCount;}
\DoxyCodeLine{05085 }
\DoxyCodeLine{05086 \textcolor{preprocessor}{    \#if( INCLUDE\_xTaskAbortDelay == 1 )}}
\DoxyCodeLine{05087     \{}
\DoxyCodeLine{05088         \textcolor{comment}{/* About to enter a delayed list, so ensure the ucDelayAborted flag is}}
\DoxyCodeLine{05089 \textcolor{comment}{        reset to pdFALSE so it can be detected as having been set to pdTRUE}}
\DoxyCodeLine{05090 \textcolor{comment}{        when the task leaves the Blocked state. */}}
\DoxyCodeLine{05091         pxCurrentTCB-\/>ucDelayAborted = pdFALSE;}
\DoxyCodeLine{05092     \}}
\DoxyCodeLine{05093 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{05094 }
\DoxyCodeLine{05095     \textcolor{comment}{/* Remove the task from the ready list before adding it to the blocked list}}
\DoxyCodeLine{05096 \textcolor{comment}{    as the same list item is used for both lists. */}}
\DoxyCodeLine{05097     \textcolor{keywordflow}{if}( uxListRemove( \&( pxCurrentTCB-\/>xStateListItem ) ) == ( UBaseType\_t ) 0 )}
\DoxyCodeLine{05098     \{}
\DoxyCodeLine{05099         \textcolor{comment}{/* The current task must be in a ready list, so there is no need to}}
\DoxyCodeLine{05100 \textcolor{comment}{        check, and the port reset macro can be called directly. */}}
\DoxyCodeLine{05101         portRESET\_READY\_PRIORITY( pxCurrentTCB-\/>uxPriority, uxTopReadyPriority ); \textcolor{comment}{/*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB-\/>uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */}}
\DoxyCodeLine{05102     \}}
\DoxyCodeLine{05103     \textcolor{keywordflow}{else}}
\DoxyCodeLine{05104     \{}
\DoxyCodeLine{05105         mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{05106     \}}
\DoxyCodeLine{05107 }
\DoxyCodeLine{05108 \textcolor{preprocessor}{    \#if ( INCLUDE\_vTaskSuspend == 1 )}}
\DoxyCodeLine{05109     \{}
\DoxyCodeLine{05110         \textcolor{keywordflow}{if}( ( xTicksToWait == portMAX\_DELAY ) \&\& ( xCanBlockIndefinitely != pdFALSE ) )}
\DoxyCodeLine{05111         \{}
\DoxyCodeLine{05112             \textcolor{comment}{/* Add the task to the suspended task list instead of a delayed task}}
\DoxyCodeLine{05113 \textcolor{comment}{            list to ensure it is not woken by a timing event.  It will block}}
\DoxyCodeLine{05114 \textcolor{comment}{            indefinitely. */}}
\DoxyCodeLine{05115             vListInsertEnd( \&xSuspendedTaskList, \&( pxCurrentTCB-\/>xStateListItem ) );}
\DoxyCodeLine{05116         \}}
\DoxyCodeLine{05117         \textcolor{keywordflow}{else}}
\DoxyCodeLine{05118         \{}
\DoxyCodeLine{05119             \textcolor{comment}{/* Calculate the time at which the task should be woken if the event}}
\DoxyCodeLine{05120 \textcolor{comment}{            does not occur.  This may overflow but this doesn't matter, the}}
\DoxyCodeLine{05121 \textcolor{comment}{            kernel will manage it correctly. */}}
\DoxyCodeLine{05122             xTimeToWake = xConstTickCount + xTicksToWait;}
\DoxyCodeLine{05123 }
\DoxyCodeLine{05124             \textcolor{comment}{/* The list item will be inserted in wake time order. */}}
\DoxyCodeLine{05125             listSET\_LIST\_ITEM\_VALUE( \&( pxCurrentTCB-\/>xStateListItem ), xTimeToWake );}
\DoxyCodeLine{05126 }
\DoxyCodeLine{05127             \textcolor{keywordflow}{if}( xTimeToWake < xConstTickCount )}
\DoxyCodeLine{05128             \{}
\DoxyCodeLine{05129                 \textcolor{comment}{/* Wake time has overflowed.  Place this item in the overflow}}
\DoxyCodeLine{05130 \textcolor{comment}{                list. */}}
\DoxyCodeLine{05131                 vListInsert( pxOverflowDelayedTaskList, \&( pxCurrentTCB-\/>xStateListItem ) );}
\DoxyCodeLine{05132             \}}
\DoxyCodeLine{05133             \textcolor{keywordflow}{else}}
\DoxyCodeLine{05134             \{}
\DoxyCodeLine{05135                 \textcolor{comment}{/* The wake time has not overflowed, so the current block list}}
\DoxyCodeLine{05136 \textcolor{comment}{                is used. */}}
\DoxyCodeLine{05137                 vListInsert( pxDelayedTaskList, \&( pxCurrentTCB-\/>xStateListItem ) );}
\DoxyCodeLine{05138 }
\DoxyCodeLine{05139                 \textcolor{comment}{/* If the task entering the blocked state was placed at the}}
\DoxyCodeLine{05140 \textcolor{comment}{                head of the list of blocked tasks then xNextTaskUnblockTime}}
\DoxyCodeLine{05141 \textcolor{comment}{                needs to be updated too. */}}
\DoxyCodeLine{05142                 \textcolor{keywordflow}{if}( xTimeToWake < xNextTaskUnblockTime )}
\DoxyCodeLine{05143                 \{}
\DoxyCodeLine{05144                     xNextTaskUnblockTime = xTimeToWake;}
\DoxyCodeLine{05145                 \}}
\DoxyCodeLine{05146                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{05147                 \{}
\DoxyCodeLine{05148                     mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{05149                 \}}
\DoxyCodeLine{05150             \}}
\DoxyCodeLine{05151         \}}
\DoxyCodeLine{05152     \}}
\DoxyCodeLine{05153 \textcolor{preprocessor}{    \#else }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{05154     \{}
\DoxyCodeLine{05155         \textcolor{comment}{/* Calculate the time at which the task should be woken if the event}}
\DoxyCodeLine{05156 \textcolor{comment}{        does not occur.  This may overflow but this doesn't matter, the kernel}}
\DoxyCodeLine{05157 \textcolor{comment}{        will manage it correctly. */}}
\DoxyCodeLine{05158         xTimeToWake = xConstTickCount + xTicksToWait;}
\DoxyCodeLine{05159 }
\DoxyCodeLine{05160         \textcolor{comment}{/* The list item will be inserted in wake time order. */}}
\DoxyCodeLine{05161         listSET\_LIST\_ITEM\_VALUE( \&( pxCurrentTCB-\/>xStateListItem ), xTimeToWake );}
\DoxyCodeLine{05162 }
\DoxyCodeLine{05163         \textcolor{keywordflow}{if}( xTimeToWake < xConstTickCount )}
\DoxyCodeLine{05164         \{}
\DoxyCodeLine{05165             \textcolor{comment}{/* Wake time has overflowed.  Place this item in the overflow list. */}}
\DoxyCodeLine{05166             vListInsert( pxOverflowDelayedTaskList, \&( pxCurrentTCB-\/>xStateListItem ) );}
\DoxyCodeLine{05167         \}}
\DoxyCodeLine{05168         \textcolor{keywordflow}{else}}
\DoxyCodeLine{05169         \{}
\DoxyCodeLine{05170             \textcolor{comment}{/* The wake time has not overflowed, so the current block list is used. */}}
\DoxyCodeLine{05171             vListInsert( pxDelayedTaskList, \&( pxCurrentTCB-\/>xStateListItem ) );}
\DoxyCodeLine{05172 }
\DoxyCodeLine{05173             \textcolor{comment}{/* If the task entering the blocked state was placed at the head of the}}
\DoxyCodeLine{05174 \textcolor{comment}{            list of blocked tasks then xNextTaskUnblockTime needs to be updated}}
\DoxyCodeLine{05175 \textcolor{comment}{            too. */}}
\DoxyCodeLine{05176             \textcolor{keywordflow}{if}( xTimeToWake < xNextTaskUnblockTime )}
\DoxyCodeLine{05177             \{}
\DoxyCodeLine{05178                 xNextTaskUnblockTime = xTimeToWake;}
\DoxyCodeLine{05179             \}}
\DoxyCodeLine{05180             \textcolor{keywordflow}{else}}
\DoxyCodeLine{05181             \{}
\DoxyCodeLine{05182                 mtCOVERAGE\_TEST\_MARKER();}
\DoxyCodeLine{05183             \}}
\DoxyCodeLine{05184         \}}
\DoxyCodeLine{05185 }
\DoxyCodeLine{05186         \textcolor{comment}{/* Avoid compiler warning when INCLUDE\_vTaskSuspend is not 1. */}}
\DoxyCodeLine{05187         ( void ) xCanBlockIndefinitely;}
\DoxyCodeLine{05188     \}}
\DoxyCodeLine{05189 \textcolor{preprocessor}{    \#endif }\textcolor{comment}{/* INCLUDE\_vTaskSuspend */}\textcolor{preprocessor}{}}
\DoxyCodeLine{05190 \}}
\DoxyCodeLine{05191 }
\DoxyCodeLine{05192 \textcolor{comment}{/* Code below here allows additional code to be inserted into this source file,}}
\DoxyCodeLine{05193 \textcolor{comment}{especially where access to file scope functions and data is needed (for example}}
\DoxyCodeLine{05194 \textcolor{comment}{when performing module tests). */}}
\DoxyCodeLine{05195 }
\DoxyCodeLine{05196 \textcolor{preprocessor}{\#ifdef FREERTOS\_MODULE\_TEST}}
\DoxyCodeLine{05197 \textcolor{preprocessor}{    \#include "{}tasks\_test\_access\_functions.h"{}}}
\DoxyCodeLine{05198 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05199 }
\DoxyCodeLine{05200 }
\DoxyCodeLine{05201 \textcolor{preprocessor}{\#if( configINCLUDE\_FREERTOS\_TASK\_C\_ADDITIONS\_H == 1 )}}
\DoxyCodeLine{05202 }
\DoxyCodeLine{05203 \textcolor{preprocessor}{    \#include "{}freertos\_tasks\_c\_additions.h"{}}}
\DoxyCodeLine{05204 }
\DoxyCodeLine{05205 \textcolor{preprocessor}{    \#ifdef FREERTOS\_TASKS\_C\_ADDITIONS\_INIT}}
\DoxyCodeLine{05206         \textcolor{keyword}{static} \textcolor{keywordtype}{void} freertos\_tasks\_c\_additions\_init( \textcolor{keywordtype}{void} )}
\DoxyCodeLine{05207         \{}
\DoxyCodeLine{05208             FREERTOS\_TASKS\_C\_ADDITIONS\_INIT();}
\DoxyCodeLine{05209         \}}
\DoxyCodeLine{05210 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{05211 }
\DoxyCodeLine{05212 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05213 }
\DoxyCodeLine{05214 }

\end{DoxyCode}
